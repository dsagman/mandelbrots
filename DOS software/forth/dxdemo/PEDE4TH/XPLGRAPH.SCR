\ XPL0 compatible graphics and sound functions                                                                                  SETVID   ( mode -- )        set video mode                      SETPAGE  ( page -- )        set video page                      CLEAR    ( -- )             clear screen (text & graphics)      PALETTE  ( palette -- )     set color palette                   SETPAL   ( addr -- )        set all 16 palette registers        MOVETO   ( x y -- )         move to coordinate XY               POINT    ( x y color -- )   plot pixel at XY                    READPIX  ( x y -- color )   read pixel at XY                    LINE     ( x y color -- )   draw line to XY                     SOUNDX   ( volume slen sfreq -- )   generate sound or delay                                                                     These routines were adapted from the XPL0 sources.              For information on the XPL0 programming language see:           www.idcomm.com/personal/lorenblaney/                                                                                            forth definitions  decimal                                      application                                                                                                                     marker -XPLGRAPH                                                                                                                2 #screens 1- thru                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \ tools                                                         forth definitions system                                                                                                        : EVEN    ( -- )  here 1 and if $90 c, then ;                   : 4ALIGN  ( -- )  here dup 3 + $FFFC and swap ?do $90 c, loop ;                                                                 : EQU  ( x -- )  sys @  dup >r  0= sys !  value  r> sys ! ;                                                                     : DW  ( word -- )  here  swap  ,  equ ;                         : DB  ( byte -- )  here  swap  c, equ ;                                                                                         application                                                                                                                                                                                                                                                                                                                     \ variables                                                     even                                                            0  dw startx   \ beginning x position                           0  dw endx     \ ending x position                              0  dw starty   \ beginning y position                           0  dw endy     \ ending y position                              0  db color    \ color atribute                                 0  db dash     \ high byte of color for dotted lines            80 dw linsiz   \ number of bytes on a line                      0  dw scrpar   \ page paragraph                                 3  db vidmod   \ current video mode                             even                                                            0  dw daginx   \ diagonal x increment                           0  dw daginy   \ diagonal y increment                           0  dw strinx   \ straight x increment                                                                                           \ variables                                                     0  dw striny   \ straight y increment                           0  dw strcnt   \ straight count                                 0  dw dagcnt   \ diagonal count                                 0  dw colorx2  \ pre-adjusted color (no xor)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \ subroutines                                                   \ get current video page in bh                                  label getpag                                                      es push  bx bx sub  bx es mov                                   es: $462 ) bh mov  es pop  ret                                end-code                                                                                                                        \ perform int $10 saving bp si                                  label int10                                                       bp push  si push  $10 int  si pop  bp pop  ret                end-code                                                                                                                                                                                                                                                                                                                                                                                        \ subroutines                                                   \ reset VGA registers to default                                label vgarst                                                      ax push  dx push  $3CE # dx mov                                 $FF08 # ax mov  ax dx out  \ bit mask                           $0003 # ax mov  ax dx out  \ data rotate                        $0001 # ax mov  ax dx out  \ enable set/reset                   dx pop  ax pop  ret                                           end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \ SETVID SETPAGE                                                \ Set video mode                                                code SETVID  ( mode -- )                                          ax pop  ah ah sub  int10 ) call  next                         end-code                                                                                                                        \ Set video page                                                code SETPAGE  ( page -- )                                         ax pop  5 # ah mov  int10 ) call  next                        end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                        \ CLEAR                                                         \ Clear screen (graphics and text)                              code CLEAR  ( -- )                                                bp push  si push                                                cx cx sub             \ window upper left                       cx es mov  es: $484 ) dh mov  \ bottom row number               36 # dh cmp  1 $ jnz  \ clr bottom 8 lines for mode 6A                       \ when character height = 16.  16*(36+1) = 592     dh inc                \ (16*38*800/8 = 60800 which is < F000    es: dh $484 ) mov     \ for Compaq Presario 1240              1 $:  41 # dh cmp  2 $ jnz  \ clr bottom 12 lines for mode 6A                           \ when char height = 14. 14*(41+1) = 588  dh inc                \ (14*43*800/8 = 60200 which is < F000    es: dh $484 ) mov     \ for Compaq Presario 1240                                                                                                                                                                                                              \ out of range? (1024 pixels / 8 pixels/char)                   2 $:  127 # dh cmp  3 $ jna                                       127 # dh mov  \ set largest possible screen (1024/8 = 128)    3 $: 0 # dh cmp  4 $ jnz  \ skip if advanced bios                 24 # dh mov             \ must be CGA etc                     4 $:  es: $44A ) dl mov  dl dec  \ # columns                    \ select proper attribute for graphics or text mode               attrib ) bh mov         \ current text attribute                es: $449 ) bl mov                                               3 # bl cmp  5 $ jng     \ mode 0-3 or 7?                        7 # bl cmp  5 $ jz                                              bh bh sub               \ attribute for graphics mode                                                                                                                                                                                                                                                                         5 $:  vgarst ) call       \ for nVidia                            $0600 # ax mov  $10 int                                         dh dec                  \ restore $484 if changed above         36 # dh cmp  6 $ jnz    \ for Compaq Presario 1240              es: dh $484 ) mov                                             6 $:  41 # dh cmp  7 $ jnz                                         dh es: $484 ) mov                                            7 $:  es: $462 ) bh mov   \ get current page                      dx dx sub  2 # ah mov  $10 int  \ home cursor                   si pop  bp pop  next                                          end-code                                                                                                                                                                                                                                                                                                                        \ PALETTE                                                       \ Set color palette                                             code PALETTE  ( palette -- )                                      bx pop  1 # bh mov  $0B # ah mov  int10 ) call  next          end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \ SETPAL                                                        \ Set all 16 palette registers - faster than bios               code SETPAL  ( addr -- )                                          si bx mov  si pop  ax ax sub                                    ax es mov  es: $463 ) dx mov  \ get CRTC port                   6 # dx add  dx al in          \ reset data/addr flip flop       here 2+ ju                                                      $3C0 # dx mov  16 # cx mov  ax ax sub                         1 $:  al dx out                 \ sel palette register            here 2+ ju                                                      al ah xchg  al lods  al dx out  \ set palette                   here 2+ ju                                                      al ah xchg  al inc  1 $ loop                                    $20 # al mov  al dx out       \ attribute controller on         bx si mov  next                                               end-code                                                        \ MOVETO                                                        \ Move to new coordinate                                        code MOVETO  ( x y -- )                                           starty ) pop  startx ) pop  next                              end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \ POINT                                                         \ Plot pixel                                                    code POINT  ( x y color -- )                                      bx pop  dx pop  cx pop  bp push  si push                        dx starty ) mov  cx startx ) mov                                ax ax sub  ax es mov  es: $449 ) al mov                         $0C # al cmp  1 $ jna  $13 # al cmp  2 $ jz                     3 $ jb  $6A # al cmp  3 $ jz                                  \ draw dot - using bios                                         1 $:  bl al mov  $0C # ah mov  getpag ) call                      $10 int  5 $ ju                                                                                                               \ draw dot - mode 13h                                           2 $:  $A000 # ax mov  ax es mov                                   320 # ax mov  dx mul  cx ax add  ax di mov                      bl al mov  al stos  5 $ ju                                                                                                    \ draw dot - planar modes 0D..12h,6Ah                           3 $:  es: $44A ) ax mov ( bytes/line)  dx mul                     cx shr  cx shr  cx shr  cx ax add  ax push  \ addr                                                                              es: $44E ) ax mov ( page offs)  ax shr  ax shr                  ax shr  ax shr  $A000 # ax add  ax es mov                                                                                       $3CE # dx mov  $8008 # ax mov  \ set mask                       startx ) cx mov  7 # cl and  ah cl shr  ax dx out                                                                               $1803 # ax mov  $80 # bl test  \ set mode                       4 $ jnz  ah ah sub  4 $:  ax dx out                                                                                                                                                                                                                                                                                             bl ah mov  $7F00 # ax and  ax dx out  \ set color                                                                               $0F01 # ax mov  ax dx out  \ enable set/reset reg                                                                               di pop  es: 0 [di] al xchg  \ modify                            vgarst ) call                                                                                                                 5 $:  si pop  bp pop  next                                      end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                        \ READPIX                                                       \ Read a pixel on the graphic screen                            code READPIX  ( x y -- color )                                    dx pop  cx pop  getpag ) call  $0D # ah mov                     int10 ) call  ah ah sub  ax push  next                        end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \ line draw subroutines                                         \ Plot line using bios                                          \ assumes bios preserves SI DI CX DX ?                          label bline                                                     1 $:  byte dash ) rol  2 $ jnc  \ between dots?                   $0C # ah mov  color ) al mov  $10 int  \ plot                                                                                 2 $:  di di test  3 $ jnl  \ decision                             strinx ) cx add  striny ) dx add                                strcnt ) di add  si dec  1 $ jnz  ret                                                                                         3 $:  daginx ) cx add  daginy ) dx add                            dagcnt ) di add  si dec  1 $ jnz  ret                         end-code                                                                                                                                                                                                                                                        \ patch points                                                  0 dw clin1  0 dw clin2  0 dw clin3                              0 dw clin4  0 dw clin5  0 dw clin6                              0 dw clin7  0 dw clin8  0 dw clin9                                                                                              0 dw xlin1  0 dw xlin2                                                                                                          0 dw oct0a  0 dw oct0b  0 dw oct0c                              0 dw oct1a  0 dw oct1b                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          \ Plot line - CGA modes 4-6                                     label (cline)                                                     4align                                                        1 $:  bh rol  3 $ jnc  \ between dots?                            cx si mov  si shl  si shl  si shl  \ x pos in byte            here to clin1   si shl                                            bx si add  $3F # si and  \ add adjusted color                 \ get pixel color and mask                                      here to clin2   $1234 [si] ax mov                                 cx si mov  si shr  si shr                                     here to clin3   si shr                                            dx si add  $08 # dl test  2 $ jz  \ odd/even bank?              $2000 40 - # si add                                                                                                                                                                                                                                           2 $:  es: 0 [si] al and                                           ah al xor  es: al 0 [si] mov                                  3 $:  di di test  4 $ jnl  \ decision                           here to clin4   $1234 # cx add                                  here to clin5   $1234 # dx add                                  here to clin6   $1234 # di add                                    bp dec  1 $ jnz  ret                                          4 $:                                                            here to clin7   $1234 # cx add                                  here to clin8   $1234 # dx add                                  here to clin9   $1234 # di add                                    bp dec  1 $ jnz  ret                                          end-code                                                                                                                                                                                                                                                        \ Setup for line draw CGA modes 4-6                             label cline                                                       40 # bx mov  bx ax mov  dx imul  ax push                        bx ax mov  striny ) imul  ax clin5 2+ ) mov                     bx ax mov  daginy ) imul  ax clin8 2+ ) mov                     strinx ) ax mov  ax clin4 2+ ) mov                              strcnt ) ax mov  ax clin6 2+ ) mov                              daginx ) ax mov  ax clin7 2+ ) mov                              dagcnt ) ax mov  ax clin9 2+ ) mov                              here 2+ ju  \ flush instruction cache                                                                                           dash ) bh mov  colorx2 ) bl mov                                 si bp mov  dx pop  (cline) ) jmp                              end-code                                                                                                                                                                                        \ Color/mask table - mode 4,5                                   even                                                            here equ ctab5                                                                                                                  \  low byte = mask, high byte = color                           \          normal                       xor                     \  0      1      2      3      0      1      2      3           hex                                                               003F , 403F , 803F , C03F , 00FF , 40FF , 80FF , C0FF ,         00CF , 10CF , 20CF , 30CF , 00FF , 10FF , 20FF , 30FF ,         00F3 , 04F3 , 08F3 , 0CF3 , 00FF , 04FF , 08FF , 0CFF ,         00FC , 01FC , 02FC , 03FC , 00FF , 01FF , 02FF , 03FF ,       decimal                                                                                                                                                                                                                                                         \ Color/mask table - mode 6                                     even                                                            here equ ctab6                                                                                                                  \  low byte = mask, high byte = color                           \    normal          xor         normal          xor            \  off    on     off    on     off    on     off    on          hex                                                               007F , 807F , 00FF , 80FF , 00BF , 40BF , 00FF , 40FF ,         00DF , 20DF , 00FF , 20FF , 00EF , 10EF , 00FF , 10FF ,         00F7 , 08F7 , 00FF , 08FF , 00FB , 04FB , 00FF , 04FF ,         00FD , 02FD , 00FF , 02FF , 00FE , 01FE , 00FF , 01FF ,       decimal                                                                                                                                                                                                                                                         \ Setup line draw mode 4,5                                      label line5                                                       $E6D1 # ax mov  ax clin1 ) mov     \ SHL SI,1                   ctab5 # ax mov  ax clin2 2+ ) mov                               $C08B # ax mov  ax clin3 ) mov     \ MOV AX,AX                  cline ) jmp                                                   end-code                                                                                                                        \ Setup line draw mode 6                                        label line6                                                       $C08B # ax mov  ax clin1 ) mov     \ MOV AX,AX                  ctab6 # ax mov  ax clin2 2+ ) mov                               $EED1 # ax mov  ax clin3 ) mov     \ SHR SI,1                   cline ) jmp                                                   end-code                                                                                                                        \ Plot line - mode 13h                                          label (xline)                                                     cs push  dx dx test  \ decision                                 4align                                                        1 $:  bh rol  2 $ jnc  \ between dots?                            bl 0 [si] mov  bl 0 [di] mov  \ plot each end                 2 $:  3 $ jns                                                     ax si add  ax di sub                                          here to xlin1   $1234 # dx add                                    1 $ loop  ds pop  ret                                                                                                         3 $:  bp si add  bp di sub                                      here to xlin2   $1234 # dx add                                    1 $ loop  ds pop  ret                                         end-code                                                                                                                        \ Setup line draw - mode 13h                                    label xline                                                       strcnt ) ax mov  ax xlin1 2+ ) mov                              dagcnt ) ax mov  ax xlin2 2+ ) mov                              here 2+ ju  \ flush instruction cache                                                                                           si cx xchg  cx inc  cx shr                                      320 # bx mov  bx ax mov  dx imul  ax si add                     di push                                                         bx ax mov  endy ) imul  endx ) ax add  ax di mov                bx ax mov  daginy ) imul  daginx ) ax add  ax bp mov                                                                                                                                                                                                                                                                                                                                            bx ax mov  striny ) imul  strinx ) ax add                       color ) bx mov  \ color dotdash                                 $A000 # dx mov  dx ds mov                                       dx pop  (xline) ) jmp                                         end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \ CGA line draw                                                 label cgaline                                                     vidmod ) ah mov  6 # ah cmp  5 $ ja                             2 $ jz  4 # ah cmp  6 $ jb                                                                                                      line5 ) bp lea  \ mode 4,5                                      color ) al mov  $83 # al and  1 $ jns                           4 # al or  1 $:  7 # ax and  4 $ ju  ( bit 2 = xor)                                                                           2 $:  line6 ) bp lea  \ mode 6                                    color ) al mov  $81 # al and  3 $ jns                           2 # al or  3 $:  3 # ax and  ( bit 1 = xor)                   4 $:  ax shl  ax colorx2 ) mov  \ word index                      $B800 # ax mov  scrpar ) ax add  \ page seg                     ax es mov  7 $ ju                                                                                                             5 $:  $13 # ah cmp  6 $ jnz  \ mode 13h ?                         xline ) bp lea  7 $ ju                                                                                                        6 $:  bline ) bp lea     \ other modes use bios                                                                                 7 $:  getpag ) call      \ current page                           1 # cx mov  cx dx mov  \ initial increments                                                                                   \ calc vert/horiz diff: SI,DI = delta x,y                         endy ) di mov  starty ) di sub  8 $ jnl  \ end-start            dx neg  di neg  8 $:  dx daginy ) mov                                                                                           endx ) si mov  startx ) si sub  9 $ jnl  \ end-start            cx neg  si neg  9 $:  cx daginx ) mov                                                                                                                                                         \ test line segments                                              di si cmp  10 $ jnl  \ horiz longer than vert?                  cx cx sub  di si xchg  11 $ ju                                10 $:  dx dx sub                                                11 $:  cx strinx ) mov  dx striny ) mov                                                                                         \ calc adjustment factors for decision variable                 \ strcnt= 2*di  dagcnt= 2*di - 2*si  decision= 2*di - si          di ax mov  ax shl  ax strcnt ) mov  \ double short value        si ax sub  ax di mov                \ decision                  si ax sub  ax dagcnt ) mov          \ sub long distance again   startx ) cx mov  starty ) dx mov    \ starting x y              si inc  bp jmp                      \ inc long for endpoint   end-code                                                                                                                        \ VGA line subroutines                                          \ Draw line in octants 0,3                                      label oct0                                                        bx si mov          \ bytes/line                                 cs: dash ) bl mov  \                                            al ah xchg         \ ah = bit mask, al = 0                      bp bp test         \ decision                                                                                                   4align                                                        1 $:  3 $ jns                                                     ah al or  ( combine bits)  ah ror  2 $ jc                     here to oct0a   $1234 # bp add                                    1 $ loop                                                        bl al and  al dx out  \ dotted line                             0 [di] al xchg  ret                                                                                                                                                                             4align                                                        2 $:  bl al and  al dx out  \ dotted line                         0 [di] al xchg                                                  al al sub  di inc                                             here to oct0b   $1234 # bp add                                    1 $ loop  ret                                                                                                                   4align                                                        3 $:  ah al or  ( combine bits)                                   bl al and  al dx out  \ dotted line                             0 [di] al xchg                                                  al al sub  ah ror  si di adc                                  here to oct0c   $1234 # bp add                                    1 $ loop  ret                                                 end-code                                                                                                                        \ Draw line in octants 1,2                                      label oct1                                                        bx si mov          \ bytes/line                                 cs: dash ) bl mov  \                                            bp bp test         \ decision                                                                                                   4align                                                        1 $:  bl rol  2 $ jnc  \ between dots?                            0 [di] ah xchg                                                2 $:  3 $ jns                                                     si di add ( offset)                                           here to oct1a   $1234 # bp add                                    1 $ loop  ret                                                                                                                                                                                                                                                   4align                                                        3 $:  al ror ( mask)  al dx out                                   si di adc ( offset)                                           here to oct1b   $1234 # bp add                                    1 $ loop  ret                                                 end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \  octants:                                                     \         ------------+------------                             \                    /|\                                        \            3     /  |  \     0                                \                /    |    \                                    \              /   2  |  1   \                                  \                     |                                                                                                         \ draw diagonal line                                            label dline                                                       di si cmp  1 $ jng                                                                                                                                                                                                                                                                                                                                                                            \ compute constants for octants 0,3                               si cx mov  cx inc      \ counter = dx+1                         di shl                 \ d1 = dy*2                              di bp mov  si bp sub   \ d  = dy*2-dx                           si neg  bp si add      \ d2 = dy*2-dx-dx                        di cs: oct0a 2+ ) mov  \ save d1                                di cs: oct0b 2+ ) mov  \ save d1                                si cs: oct0c 2+ ) mov  \ save d2                                here 2+ ju  \ flush instruction cache                                                                                           $3CE # dx mov  8 # al mov  al dx out                            dx inc  ax pop ( mask)  \ not used                              di pop ( addr)  oct0 ) jmp                                                                                                                                                                                                                                    \ compute constants for octants 1,2                             1 $:  di cx mov  cx inc  \ counter = dy+1                         si shl                 \ d1 = dx*2                              si bp mov  di bp sub   \ d  = dx*2-dy                           di neg  bp di add      \ d2 = dx*2-dy-dy                        si cs: oct1a 2+ ) mov  \ save d1                                di cs: oct1b 2+ ) mov  \ save d2                                here 2+ ju  \ flush instruction cache                                                                                           $3CE # dx mov  8 # al mov  ax dx out                            dx inc  ax pop ( mask)  al dx out                               di pop ( addr)  oct1 ) jmp                                    end-code                                                                                                                                                                                                                                                        \ VGA line draw                                                 label vgaline                                                     ds push  14 $ ) ax lea  ax push  \ setup for exit               \ ensure endx >= startx                                         startx ) ax mov  endx ) cx mov  ax cx cmp  1 $ jnl              starty ) bp mov  endy ) dx mov  cx startx ) mov                 dx starty ) mov  ax endx ) mov  bp endy ) mov                                                                                 \ compute offset                                                1 $:  linsiz ) ax mov  starty ) mul  startx ) bx mov              3 # cl mov  bx cl shr  bx ax add  ax push ( offset)                                                                                                                                                                                                                                                                                                                                           \ compute mask for first pixel                                    startx ) cx mov  7 # cl and  \ compute bit to modify            $80 # bx mov  bx cl shr  bx push ( mask)                                                                                        $3CE # dx mov  8 # al mov  al dx out  \ mask                    dx inc  ah al mov  al dx out                                                                                                    dx dec  color ) bl mov  \ set registers for current color       3 # al mov  al dx out  \ sel rotate/function                    dx inc  al al sub  $80 # bl test  2 $ jz  \ xor?                2 $ jz  $18 # al mov  2 $: al dx out  \ write mode                                                                                                                                                                                                                                                                                                                                              dx dec  al al sub  al dx out  \ sel set/reset                   dx inc  bl al mov  \ enable planes corresp. to color            $7F # al and  al dx out     \ mask out xor bit                                                                                  dx dec  1 # al mov  al dx out  \ enable set/reset reg           dx inc  $0F # al mov  al dx out  \ enable 4 bit planes                                                                          $3C4 # dx mov  2 # al mov  al dx out  \ sel map mask            dx inc  $0F # al mov  al dx out  \ enable for mem write                                                                       \ point to video page                                             $A000 # dx mov  scrpar ) dx add  dx es mov  dx ds mov                                                                                                                                                                                                                                                                         \ determine horiz, vert or diagonal line                          cs: linsiz ) bx mov  \ bytes/line                               cs: endx ) si mov  cs: startx ) si sub  \ compute dx si         cs: endy ) di mov  cs: starty ) di sub  \ compute dy di         3 $ jnl  bx neg  di neg                                       3 $:  si si or  4 $ jz  \ vert?                                   di di or  8 $ jz      \ horiz?                                  dline ) jmp           \ diagonal                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \ draw vertical line                                            4 $:  di cx mov  cx inc ( count)  bx bp mov  ( bytes/line)        si pop ( mask)  di pop ( offs)  cs: dash ) bl mov               $3CE # dx mov  8 # al mov  al dx out  \ set mask                dx inc  si ax mov  al dx out                                    $FF # bl cmp  6 $ jnz  \ solid line?                            4align                                                        5 $:  0 [di] al xchg                                              bp di add  5 $ loop  ret                                        4align                                                        6 $:  bl rol  7 $ jnc  \ between dots?                            0 [di] al xchg                                                7 $:  bp di add  6 $ loop  ret                                                                                                                                                                                                                                  \ draw horizontal line                                          8 $:  si cx mov  cx inc  \ add one for end point                  si pop  di pop         \ mask, offset                                                                                         \ draw pixels from leading partial byte                           cs: startx ) ax mov  7 # ax and  10 $ jz  \ partial byte?       $FF # bp mov  cx push  ax cx mov  bp cl shr  \ compute mask     cx pop  ax cx add      \ update pixel counter                   8 # cx sub  9 $ jnl    \ modify mask if only one byte           cx neg  bp cl shr  bp cl shl                                    cx cx sub              \ restore counter                      9 $:  $3CE # dx mov  8 # al mov  al dx out  \ set mask            dx inc  bp ax mov  cs: dash ) al and  al dx out  \ dotted line  0 [di] al xchg  di inc  \ latch and write new data                                                                                                                                            \ draw pixels from middle complete bytes                        10 $:  cx bp mov  8 # bp cmp  12 $ jl  \ bytes to set?            cx shr  cx shr  cx shr                                          $3CE # dx mov  8 # al mov  al dx out  \ set mask                dx inc  cs: dash ) al mov  al dx out  \ dotted line                                                                             di si mov  ( cld )  \ point at screen                                                                                         \ fill complete bytes                                             $FF # al cmp  11 $ jnz  \ solid line?                           byte $80 # cs: color ) test  11 $ jnz  \ xor?                   al ah mov  cx shr  rep  ax stos                                 12 $ jnc  al stos  12 $ ju  \ handle odd bytes                11 $:  rep  byte movs  \ VGA latch is 8-bit                                                                                                                                                     \ draw pixels from trailing partial byte                        12 $:  7 # bp and  13 $ jz                                        $FFFF # ax mov  bp cx mov  ax cl shr  \ compute mask            $FF # ah xor                                                    $3CE # dx mov  8 # al mov  al dx out  \ set mask                dx inc  ah al mov  cs: dash ) al and  al dx out  \ dotted line  0 [di] al xchg   \ latch,set new data                         13 $: ret                                                                                                                       \ exit                                                          14 $:  ds pop  vgarst ) jmp                                     end-code                                                                                                                                                                                                                                                        \ LINE                                                          \ Draw line to X Y                                              code LINE  ( x y color -- )                                       ax pop  ah not  ax color ) mov  \ color                         bp push  si push  sp bp mov                                     4 [bp] ax mov  ax endy ) mov  \ x y                             6 [bp] ax mov  ax endx ) mov                                    ax ax sub  ax es mov                                            es: $44A ) ax mov  ax linsiz ) mov   \ bytes/line               es: $449 ) al mov  al vidmod ) mov   \ mode                     es: $44E ) bx mov  \ page offs                                  bx shr  bx shr  bx shr  bx shr  bx scrpar ) mov                                                                                                                                                                                                                                                                                                                                               \ dispatch to proper routine                                      $0D # al cmp  1 $ jb  \ mode 0-0C                               $13 # al cmp  2 $ jb  \ mode 0D-12                              $6A # al cmp  1 $ jb  \ mode 13-69                              2 $ jz                \ mode 6A (VESA)                        1 $: cgaline ) call  3 $ ju  \ CGA                              2 $: vgaline ) call          \ VGA                              3 $: si pop  bp pop                                               starty ) pop  startx ) pop  \ save end coords                   next                                                          end-code                                                                                                                                                                                                                                                                                                                        \ SOUNDX                                                        \ Length of the sound is SLENG/18.2 in seconds                  \ Frequency is 1.19 million / SFREQ                             \ Volume= 0 = No sound, Other = Sound                           code SOUNDX  ( volume sleng sfreq -- )                            4 $ ) pop  5 $ ) pop  ax pop  ax ax or  1 $ jz                  $61 # al in  $03 # al or  al $61 # out  \ enable speaker        $B6 # al mov  al $43 # out  \ channel-2 mode 3                  4 $ ) ax mov  al $42 # out  ah al mov  al $42 # out  \ start  1 $: ah ah sub  $1A int  dx 5 $ ) add  \ add time of day        2 $: ah ah sub  $1A int  al al test  3 $ jz                       $B0 # 5 $ ) sub  \ adj if midnight passed since last read     3 $: 5 $ ) dx cmp  2 $ js  \ loop until done (signed compare)     $61 # al in  $FC # al and  al $61 # out  next  \ speaker off  4 $:  0 , ( frequency) 5 $:  0 , ( length of note)              end-code                                                        \ discard heads                                                 excise even vgarst                                              excise bline vgaline                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            