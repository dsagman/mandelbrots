






                             ГЛАВА 1

                       ТЕРМИНЫ И КОНЦЕПЦИИ

     В   этой  главе  описываются  основные  возможности  языка
МSФортран.


1.1  СИМВОЛЫ

     Текст  программы  на  Фортране  -  это  последовательность
символов в коде ASCII. К символам ASCII относятся:

1.        52 прописных и строчных букв латинского алфавита  (от
          А до Z и от а до z).

2.        10 цифр (0,1,2,3,4,5,6,7,8,9).

3.        Специальные символы (все остальные печатаемые символы
          таблицы кодов ASCII - в том числе и русские буквы).


1.1.1  АЛФАВИТНОЦИФРОВЫЕ СИМВОЛЫ

     Латинские  буквы и цифры, рассматриваемые как одна группа,
называются     алфавитноцифровыми     символами.      MSФортран
воспринимает  строчные  буквы  как прописные в любом контексте,
исключая символьные константы и  холлеритовские  поля.  Поэтому
следующие  имена,  определенные  пользователем,  эквивалентны в
MSФортране:

   ABCDE      abcde      AbCdE      aBcDe

     Последовательность    сортировки   для   набора   символов
MSФортрана - это последовательность ASCII.
     Различие между прописными и строчными буквами в символьных
константах определяется метакомандой $STRICT. По умолчанию, они
не различаются, т.е. выражение:

       A.EQ.B

имеет значение .true., если

        A='aaa', а B='AAA'

     Если же компилятору  выдано  указание  различать  символы,


                               11



т.е.  в  тексте  встретилась  метакоманда $STRICT, то значением
этого выражения будет .false. .
     Это  же  относится  и  к  символьным   константам   внутри
операторов Фортрана. Например, запись

      CLOSE(25,STATUS='keep')

может  привести к выдаче сообщения о синтаксической ошибке  при
компиляции.


1.1.2  ПРОБЕЛЫ

     За исключением указанных ниже случаев, пробел не  является
значащим  в  тексте  программы  на   MSФортране и поэтому может
использоваться   для   улучшения   внешнего   вида   программы.
Исключения следующие:

1.        Пробелы внутри строковых констант являются значащими.

2.        Пробелы    внутри   холлеритовских   полей   являются
          значащими.

3.        Пробел или нуль в шестой позиции  отличает  начальную
          строку от строки продолжения.


1.1.3  СИМВОЛЫ ТАБУЛЯЦИИ (TAB)

     Символ  ТАВ имеет следующее значение в тексте программы на
 MSФортране:

1.        Если  ТАВ  появляется  в  позициях  с 1-ой по 5-ю, то
          считается, что  следующий  символ  находится  в  7-ой
          позиции.

2.        ТАВ  в  позициях  с  6-ой по 72-ю рассматривается как
          пробел,  если  только  он не содержится внутри строки
          или холлеритового  поля  -  в этом случае он рассмат-
          ривается как символ.


1.1.4  ПОЗИЦИИ

     Символы в каждой строке расположены по позициям, первый  -
в первой позиции, второй - во второй и т.д.
     Позиция,  в  которой  находится символ, имеет существенное
значение  в  Фортране.  Позиция  1  используется  для  указания
комментария и метакоманды. Позиции с 1-й по 5-ю зарезервированы
для меток операторов, а 6-я позиция для указания продолжения.


                               12



1.2 СТРОКИ И ОПЕРАТОРЫ

     Вы можете также считать, что текст программы на Фортране -
это   последовательность   строк.   Для  компилятора  значащими
являются только  первые  72  символа  в  строке,  остальные  им
игнорируются.  Строки, длиной меньше, чем 72 символа, считаются
заполненными  пробелами  до  72-ой  позиции  (иллюстрацию этого
можно найти ниже в описании символьных констант).


1.2.1  НАЧАЛЬНЫЕ СТРОКИ

     Начальной строкой называется строка, не являющаяся строкой
комментария  или метакоманды  и  содержащая  пробел  или нуль в
шестой позиции. В  первых  пяти  позициях  строки  должны  быть
пробелы  или  должна  стоять  метка.  За исключением оператора,
следующего  за  логическим  IF,   операторы   Фортрана   должны
начинаться с начальной строки.
     Метка  оператора - это последовательность от одной до пяти
цифр, причем хоть одна из них не должна быть нулем. Метка может
находиться  в любом  месте в позициях с 1-ой по 5-ю в начальной
строке. Пробелы и предшествующие нули являются незначащими.


1.2.2  СТРОКИ ПРОДОЛЖЕНИЯ

     Строка продолжения - это любая строка, не являющаяся стро-
кой комментария или метакоманды и содержащая в позиции  6 любой
символ,  отличный   от   пробела  или  нуля.  Количество  строк
продолжения  в   MSФортране  ограничивается  только   имеющейся
памятью.


1.2.3  СТРОКИ КОММЕНТАРИЯ

    Строка считается строкой комментария, если выполняется одно
из следующих условий:

1.        В позиции 1 стоит "С" (или"с").

2.        В позиции 1 стоит звездочка (*).

3.        Строка состоит из одних пробелов.

     Строки комментария  не  оказывают  никакого воздействия на
выполнение  программы  на  Фортране.  После  строки комментария
должна  идти  начальная  строка  или другая строка комментария.
Строка продолжения не может следовать за строкой комментария.




                               13



1.2.4  ОПЕРАТОРЫ ОПИСАНИЯ ДАННЫХ И ПОРЯДОК СЛЕДОВАНИЯ ОПЕРАТОРОВ

     Оператор  Фортрана  содержит начальную строку и, возможно,
строки продолжения. Оператор END должен быть записан в позициях
с 7-ой по 72-ю начальной строки и в его строке  не  может  быть
никаких  других операторов (в дальнейшем на отдельные операторы
мы будем ссылаться  просто  по  их  именам;  смотрите  главу  2
"Операторы" для определения различных операторов и их свойств).
     Язык  Фортран  требует  определенного  порядка  следования
операторов и строк, составляющих программную единицу  Фортрана.
Кроме того,  MSФортран накладывает дополнительные требования на
порядок строк и операторов в транслируемом тексте MSФортрана.
     Транслируемый текст  может  содержать  одну  или несколько
программных единиц.
     Различные   правила   по   порядку  следования  операторов
проиллюстрированы на рис.1-2 и описаны в следующих параграфах.
+----------------------------------------------------+---------+
|  метакоманды $DO66,$STORAGE,$DECMATH               |         |
+----------------------------------------+-----------+         |
| операторы PROGRAM,FUNCTION,            |           |         |
| BLOCK DATА,SUBROUTINE                  |           |         |
+-------------------+----------+---------+  другие   |         |
|оператор IMPLICIT  |операторы |         |  мета-    | строки  |
+-------------------+          |         |  команды  |         |
|другие операторы   |PARAMETER |операторы|           | коммен- |
|определения данных |          |         |           | тариев  |
+-------------------+----------+ FORMAT  |           |         |
|функции-операторы  |операторы |         |           |         |
+-------------------+          |         |           |         |
|  выполняемые      |   DATA   |         |           |         |
|   операторы       |          |         |           |         |
+-------------------+----------+---------+-----------+         |
|   оператор   END                                   |         |
+----------------------------------------------------+---------+

Рис.1-2  Порядок операторов в программных единицах и транслируемых
         текстах.

     Для рисунка 1-2 существуют следующие соглашения:

1.        Классы строк или операторов, расположенные  выше  или
          ниже  других  классов,  должны  следовать  в заданном
          порядке.

2.        Классы строк или операторов могут быть  перемешаны  с
          другими классами, находящимися сбоку от них.

3.        Метакоманды  $LARGE и $NOTLARGE не могут находиться в
          разделе выполняемых операторов.



                               14



4.        Подпрограммы   BLOCK   DATA   не   могут    содержать
          функции-операторы,  операторы  FORMAT или выполняемые
          операторы.

     Подпрограмма начинается с операторов SUBROUTINE,  FUNCTION
или  BLOCK  DATA  и  заканчивается  оператором  END.   Основная
программа начинается с оператора  PROGRAM  или  любого  другого
оператора,  отличного от операторов  SUBROUTINE,  FUNCTION  или
BLOCK DATA,  и  заканчивается  оператором  END.  Подпрограмма и
основная программа являются программными единицами.
     Порядок  операторов  в  программной  единице  определяется
следующими правилами:

1.        Оператор  PROGRAM,  если   он  есть,   или  операторы
          SUBROUTINE,  FUNCTION, BLOCK DATA, должны быть первым
          оператором программной единицы.

2.        Оператор FORMAT может находиться в любом месте  после
          оператора   SUBROUTINE,  FUNCTION,  BLOCK  DATA   или
          PROGRAM.

3.        Все операторы определения типов должны предшествовать
          операторам  DATA,  операторам-функциям  и выполняемым
          операторам.

4.        Все операторы DATA  должны  стоять  после  операторов
          определения   типов.   Операторы   DATA   могут  быть
          перемешаны  с  операторами-функциями  и  выполняемыми
          операторами.

5.        Обычно  оператор  PARAMETER  предшествует всем другим
          операторам определения типов.  Однако, если некоторый
          оператор определяет  тип  константы,  используемой  в
          операторе PARAMETER, то  оператор   PARAMETER  должен
          следовать за этим оператором определения типа.

6.        В  операторах  определения  типа  оператор   IMPLICIT
          должен  предшествовать  всем  другим  операторам,  за
          исключением оператора PARAMETER.

7.        Все  операторы-функции  должны  предшествовать   всем
          выполняемым операторам.

8.        Метакоманды   $DO66,   $DECMATH   и  $STORAGE  должны
          предшествовать  любым  другим  операторам.  Остальные
          метакоманды    могут   находиться   в   любом   месте
          программной единицы.





                               15



1.3  ТИПЫ ДАННЫХ

     В  MSФортране существует шесть основных типов данных:

1.   Целый (INTEGER*2  INTEGER*4).

2.   Действительный (REAL*4 или REAL).

3.   Двойной точности (REAL*8 или DOUBLE PRECISION).

4.   Комплексный (COMPLEX*8 и COMPLEX*16).

5.   Логический (LOGICAL*2 и LOGICAL*4).

6.   Символьный.

     Свойства,  состав  и  форма представления констант каждого
типа описаны  на  следующих  страницах;  требования  по  памяти
приведены в таблице 1-2.
+----------------------+---------------------+-----------+
|        Тип           |   Число байтов      |Примечание |
+----------------------+---------------------+-----------+
|  LOGICAL             |     2 или 4         |     1     |
|  LOGICAL*2           |        2            |           |
|  LOGICAL*4           |        4            |           |
|  INTEGER             |     2 или 4         |     1     |
|  INTEGER*2           |        2            |           |
|  INTEGER*4           |        4            |           |
|  CHARACTER           |        1            |     2     |
|  CHARACTER*n         |        n            |     3     |
|  REAL                |        4            |     4     |
|  REAL*4              |        4            |           |
|  REAL*8              |        8            |     5     |
|  DOUBLE PRECISION    |        8            |           |
|  COMPLEX             |        8            |     6     |
|  COMPLEX*8           |        8            |           |
|  COMPLEX*16          |        16           |           |
+----------------------+---------------------+-----------+

Таб.1-2. Требования по памяти.

Примечания к таблице 1-2:

1.        Может использоваться 2 или 4 байта. По умолчанию - 4,
          но метакомандой  $STORAGE может быть установлено и 2,
          и 4.

2.        CHARACTER и CHARACTER*1 - синонимы.

3.        Максимальное n равно 32767.


                               16



4.        REAL и REAL*4 - синонимы.

5.        REAL*8 и DOUBLE PRECISION - синонимы.

6.        COMPLEX и COMPLEX*8 - синонимы.

Замечания.
     На   многих   микропроцессорах  команды,  необходимые  для
выполнения 16-битовой арифметики, значительно быстрее и  короче
соответствующих  команд  для  выполнения 32-битовой арифметики.
Поэтому,   если  вы  не  используете   метакоманду  $STORAGE  с
параметром 2,  то  в  программе  по умолчанию будет действовать
32-битовая  арифметика  и  она  будет   выполняться  медленней,
чем  16-битовая.   Задание  $STORAGE  с  параметром  2  ускорит
выполнение программы и сделает ее короче.
     Вы можете использовать  внутреннюю  функцию  INT2, которая
предписывает   компилятору   вычислять   выражения   с  помощью
16-битовой арифметики.


1.3.1  ЦЕЛЫЕ ТИПЫ ДАННЫХ

     Целый  тип  данных  состоит  из  подмножества целых чисел.
Целая величина  -  это  точное  представление  соответствующего
целого. Целая величина занимает 2 или 4 байта, в зависимости от
параметра  метакоманды  $STORAGE.  2-байтовое целое, INTEGER*2,
может содержать  величину  в  диапазоне  от  -32767  до  32767.
4-байтовое   целое,   INTEGER*4,  может  содержать  величину  в
диапазоне от -2147483647 до 2147463647.
     Целые константы содержат  последовательность из одной  или
более  десятичных  цифр, или определитель системы счисления, за
которым следует  строка  цифр  в  диапазоне  от  0...(основание
системы  счисления  - 1), где величины от 10 до 35 представлены
буквами от А до Z соответственно. Указатель  системы  счисления
содержит   символ  "#",  которому  обычно  предшествует  строка
десятичных  цифр,  представляющая  величину  основания  системы
счисления.   Если   строка  отсутствует,  подразумевается,  что
основание  равно   16.   Если   указатель   системы   счисления
отсутствует, подразумевается, что основание равно 10.
     Любому    формату    может   предшествовать   произвольный
арифметический знак плюс (+) или минус (-). Целые константы  не
должны  выходить  из  диапазона. Десятичная точка недопустима в
целой константе.
     Замечание: диапазон величин как для 16-битовых, так  и для
32-битовых  целых  не  включает  наиболее  отрицательное число,
которое может быть представлено в двоичном дополнительном  коде
таким  числом   битов.   Эти   числа,   16#8000  и  16#80000000
обрабатываются как "неопределенные" для сигнализации об ошибке.
     Хотя максимальная величина 32-битового  целого  определена
как 2**31-1, при компиляции и счете будут считываться и большие


                               17



величины,  которые  выходят  за диапазон 2**32. Но эти величины
будут  только  считываться  без  ошибки,  если   их   основание
счисления  не  равно  10.   Они  будут  интерпретироваться  как
отрицательные    числа     с     соответствующим     внутренним
представлением.  Например, 16#FFFFFFFF приведет к тому, что все
биты  32-битового  числа  будут  единицами,  что  соответствует
арифметической величине -1.
     Примеры целых констант:

                   123           +123               0
              00000123          32767          -32767
                -#AB05       2#010111       -36#ABZ07

     В MSФортране точность целых определяется следующим образом:

     * Константы.

     Точность устанавливает метакоманда $STORAGE.

     * Результат выражения.

     Точность  результата  определяется точностью максимального
операнда и величиной, установленной метакомандой $STORAGE.

     * Формальные параметры.

     Если точность неизвестна, то предполагается, что она такая
же, как у фактического параметра.  Если тип известен, он должен
точно  соответствовать  фактическому  параметру   (если  только
параметр не передается величиной с атрибутом VALUE).

     * Целые переменные и функции.

     Точность задана для  каждой  переменной  или  функции  (по
умолчанию установлена метакомандой $STORAGE).


1.3.2  ДЕЙСТВИТЕЛЬНЫЙ ТИП ДАННЫХ

     Тип  действительных  данных  (REAL  или  REAL*4)  содержит
подмножество    действительных    чисел    обычной    точности.
Действительная величина  обычной  точности  -  это  приближение
требуемого  действительного  числа,  занимающее 4 байта памяти.
Диапазон действительных чисел обычной  точности  приблизительно
следующий:

       от 8.43Е-37 до 3.37Е+38   (положительные числа)
       от -3.37Е+38 до -8.43Е-37 (отрицательные числа)
               0                 (нуль)



                               18



     Точность  -  больше  шести  десятичных цифр и меньше семи.
Действительная константа содержит:

1.   Необязательный знак.
2.   Целую часть.
3.   Десятичную точку.
4.   Дробную часть.
5.   Необязательный показатель экспоненты.

     Целая  и  дробная  части  содержат  по  одной  или  больше
десятичных  цифр,  а точка является разделителем (.). Как целая
часть, так и дробная могут отсутствовать, но не обе.  Некоторые
простые действительные константы:

         -123.456              +123.456           123.456
         -123.                 +123.              123.
         -.456                 +.456              .456

     Экспоненциальная  часть  содержит  букву  "Е",  за которой
следует (необязательно) целая константа из одной  или двух цифр
со знаком.
     Экспонента показывает, что предшествующую  величину  нужно
умножить  на  десять  в  степени значение экспоненты. Некоторые
простые экспоненциальные части:

          Е12          Е-12             Е+12      Е0

     Действительная    константа    -    это    либо   основная
действительная   константа,   либо   основная    действительная
константа  с  экспоненциальной  частью,  либо целая константа с
экспоненциальной частью. Например:

           +1.000Е-2         1.Е-2          1Е-2
           +0.01           100.0Е-4        0.0001Е+2

Все это - одно и то же число, одна сотая.


1.3.3  ДЕЙСТВИТЕЛЬНЫЙ ТИП ДАННЫХ IEEE ДВОЙНОЙ ТОЧНОСТИ

     Действительный тип данных  двойной  точности  (REAL*8  или
DOUBLE  PRECISION)  содержит  подмножество действительных чисел
двойной точности. Это  подмножество  больше,  чем  подмножество
типа данных REAL (REAL*4).
     Действительная  величина  двойной точности  - это, обычно,
приближение требуемого  действительного  числа.  Действительная
величина    двойной    точности   может   быть   положительной,
отрицательной  или  нулем  и  занимает  восемь  байтов  памяти.
Диапазон действительных величин двойной точности приблизительно
следующий:


                               19



     от 4.19D-307  до 1.67D+308  (положительные числа)
     от -1.67D+308 до -4.19D-307 (отрицательные числа)
                          0      (нуль)

     Точность  больше чем 15 десятичных цифр. Константа двойной
точности содержит:

1.   Необязательный знак.
2.   Целую часть.
3.   Десятичную точку.
4.   Дробную часть.
5.   Обязательную экспоненциальную часть.

     В экспоненте используется "D", а не "Е",  для  отличия  от
обычной точности. Целая и дробная части содержат одну или более
десятичных  цифр,  а  десятичная  точка  является разделителем.
Целая часть или дробная, но не обе, могут отсутствовать.
     Константа   двойной   точности   -   это   либо   основная
действительная  константа,  за которой следует экспоненциальная
часть,   либо   целая    константа,    за    которой    следует
экспоненциальная часть. Например:

     +1.123456789D-2         1.D-2           1D-2
     +0.000000001D0       100.0000005D-4   .00012345D+2

     Экспоненциальная  часть  содержит  букву  "D",  за которой
следует  целая   константа.   Целая   константа   может   иметь
необязательный  знак. Экспонента показывает, что предшествующее
число должно быть умножено на десять в степени целый показатель
экспоненты. Некоторые простые экспоненты:

              D12    /D-12      D+12      /D0


1.3.4  ФОРМАТ ДЕСЯТИЧНЫХ ЧИСЕЛ С ПЛАВАЮЩЕЙ ТОЧКОЙ
       ОБЫЧНОЙ И ДВОЙНОЙ ТОЧНОСТИ

     Десятичные числа с плавающей точкой содержат байт с  битом
знака  и семибитовой экспонентой в 64-ричной системе счисления,
за которым следует мантисса из 6 (для обычной точности) или  из
14  (для двойной точности) двоично-десятичных цифр, упакованных
по 2 в байт (если байт экспоненты нулевой -  число равно нулю).
Запись  десятичных  констант  с плавающей точкой производится в
том же формате, что и для стандартных  действительных  констант
Фортрана обычной и двойной точности.
     Допустимый диапазон чисел обычной точности следующий:

       от +1.0Е-64 до +9.99Е+62 (положительные числа)
       от -9.99+62 до -1.0Е-64  (отрицательные числа)
             0                  (нуль)


                               20



           
     Точность равна 6 цифрам.
     Допустимый диапазон чисел двойной точности следующий:

       от +1.0D-64  до +9.999D+62 (положительные числа)
       от -9.99D+62 до -1.0D-64   (отрицательные числа)
              0                   (нуль)

     Точность равна 14 цифрам.
     Метакоманда  $DECMATM  инициирует  представление  констант
текстового файла в формате с плавающей точкой.


1.3.5  КОМПЛЕКСНЫЕ ТИПЫ ДАННЫХ

     Тип данных  COMPLEX*8  задает  пару  действительных  чисел
обычной  точности, второе из которых представляет мнимую часть.
Число COMPLEX*8 занимает 8 байтов памяти.
     Комплексная константа состоит  из  необязательного  знака,
левой  скобки, двух целых или действительных чисел, разделенных
запятой, и правой скобки. Элемент  данных  COMPLEX*16  содержит
упорядоченную   пару  действительных  чисел  двойной  точности.
Элемент данных COMPLEX*16 занимает  16  байтов  памяти.  Каждая
компонента  (действительная  и  мнимая) COMPLEX*8 - это REAL*4.
Каждая компонента COMPLEX*16 - это REAL*8.


1.3.6  ЛОГИЧЕСКИЕ ТИПЫ ДАННЫХ

     Логический тип данных  содержит  две  логических  величины
.TRUE.  и .FALSE. Логическая переменная занимает два или четыре
байта памяти в зависимости от параметра  метакоманды  $STORAGE.
Умолчанием является 4  байта.  Метакоманда  $STORAGE  не влияет
на значение  логической  переменной (true или false).  Значения
LOGICAL*1 занимают 1 байт,  который  содержит либо 0 (.FALSE.),
либо 1 (.TRUE.). Величины LOGICAL*2 занимают два байта. Младший
значащий (первый) байт содержит значение LOGICAL*1,  а  старший
значащий байт не определен.
     Переменные LOGICAL*4 занимают два слова, младшее  значащее
(первое)   из  которых  содержит  величину  LOGICAL*2.  Старшее
значащее слово не определено.


1.3.7  СИМВОЛЬНЫЙ ТИП ДАННЫХ

     Символьный тип данных содержит последовательность символов
ASCII.  Длина  символьной  величины  равна  числу  символов   в
последовательности.  Длина  заданной  константы  или  переменой
фиксирована  и  должна  составлять  от  1  до   32767 символов.
Символьная  переменная  занимает  один  байт памяти для каждого


                               21



символа в последовательности.  Предполагается,  что  символьная
переменная  занимает  цепочку  байтов  без  учета  границ слов.
Однако компилятор предполагает,  что  несимвольные  переменные,
следующие за символьными, начинаются с границы слова.
     Символьная константа содержит последовательность из одного
или более символов, заключенных в  пару  одиночных  кавычек.  В
символьной  константе  символы  пробелов  допустимы  и значимы.
Регистры  буквенных  символов  значимы.  Одиночная  кавычка   в
символьной  константе представляется двумя одиночными кавычками
без пробелов между ними.
     Длина символьной  константы  равна  числу  символов  между
одиночными  кавычками.  Пара  одиночных  кавычек  означает один
символ. Несколько примеров символьных констант:

                   'A'
                   ' '
                   'Help!'
                   'A very long CHARACTER constant'
                   ''''
     Последний пример -  это  символьная  константа  содержащая
один апостроф (одиночную кавычку).
     Символьной  переменной  может  быть присвоена несимвольная
величина, если присвоение не включено  в  выражение.  Допустимо
следующее:

                     REAL R
                     CHARACTER*5 C
                     C=R

но недопустимо

                     REAL R
                     CHARACTER*5 C
                     C=R+1.0

     Фортран  допускает  строки  исходного  текста длиной до 72
позиций. Короткие строки дополняются пробелами до  72  позиции.
Если символьная константа переходит через границу строки, то ее
величина формируется так, что часть строки продолжения, начиная
с  7-ой  позиции,  добавляется к 72-й позиции начальной строки.
Поэтому следующий текст Фортрана

                 200  СН='ABC
                    X DEF'

эквивалентен:

                 200  CH='ABC(58 пробелов)...DEF'

     Здесь 58 пробелов между C и D, что равно пространству от С


                               22



в 15-й позиции до 72-й позиции, плюс один пробел в 7-ой позиции
строки продолжения. Таким образом могут быть представлены очень
длинные символьные константы.


1.3.7.1  СИМВОЛЬНЫЕ ПОДСТРОКИ

      MSФортран поддерживает подстроки так,  как они определены
в полном языке Фортран 77. Подстроки относятся к типу CHARACTER
и  используются   для   доступа  к  слитным  частям  символьной
переменной. Они имеют следующий синтаксис:
-----------------------------
  variable ([first]:[last])
-----------------------------
           или
--------------------------------------------
  array (index1 [,index2])([first]:[last])
--------------------------------------------
где
variable                      это символьная переменная

array (index1[,index2])       это элемент символьного массива

first и                       это целые выражения, определяющие
last                          первый (самый левый) и  последний
                              (самый правый) символ в подстроке.
                              И   first,   и   last    являются
                              необязательными.   По   умолчанию
                              first   равен  единице,  так  что
                              подстрока  начинается  с  первого
                              символа   строки.   По  умолчанию
                              last равно  длине строки, так что
                              подстрока  кончается на последнем
                              символе строки.

     Заметьте,  что  variable(:)  эквивалентно  variable. Длина
подстроки равна last-first+1.  Если символьная переменная имеет
длину   length   символов,   то  должно  выполняться  следующее
соотношение:

1 <= first <= last <= length

     Например,  для  10-байтовой  символьной  переменной   name
недействительны следующие спецификации подстрок:

name(0:4)
name(6:5)
name(11:12)
name(0:)
name(:11)


                               23



     Если  действует  метакоманда  $DEBUG  и эти соотношения не
верны, то во время выполнения будет зафиксирована ошибка.  Если
$DEBUG не действует, то результаты будут неопределенными.
     Вы  можете  использовать подстроки для конкатенации строк,
например,

                   CHARACTER A*12, B*20, C*32
                   A='Now is the t'
                   B='ime for all gooel men'
                   C(1:12)=A
                   C(13:12+20)=B
                   WRITE(*,*)'C=',C
                   END

В результате на выходе будет

                   C=Now is the time for all gooel men


1.4  ИМЕНА

     Имя    в     MSФортране    (или  идентификатор)   содержат
последовательность   буквенно цифровых  символов  длиной  до  31
символа   (символ   доллара  "$"  рассматривается  как  буква).
Начальный  символ  должен  быть  буквенным,  следующие  символы
должны  быть  буквенно цифровыми.  Пробелы  игнорируются. Только
первые  шесть  буквенно цифровых  символов  являются  значащими,
остальные игнорируются.
     Имя  означает  определенную  пользователем  или   системой
переменную,  массив  или  программную  единицу.  Любая значащая
последовательность символов может быть использована для  любого
имени  Фортрана. Здесь нет зарезервированных имен, как в других
языках. Последовательности буквенных символов, используемые как
ключевые  слова  компилятора  MSФортрана,  не   смешиваются   с
именами,   определяемыми   пользователем.  Компилятор  отличает
ключевые  слова  по  их  контексту,  и на  использование  имен,
определяемых   пользователем,   нет   ограничений.   Поэтому  в
программе могут быть массивы с именами, например, IF, READ  или
GO TO и при этом не будет ошибок (если они будут использоваться
по правилам, которым должны подчиняться). Однако, использование
ключевых  слов для имен пользователя часто мешает читабельности
программы и, поэтому, следует избегать использования таких имен.


1.4.1  ОБЛАСТЬ ДЕЙСТВИЯ ИМЕН ФОРТРАНА

     Область действия имени - это диапазон операторов, где  это
имя  известно,  то есть это область программы, в которой на это
имя можно ссылаться.
     Вообще,  область  действия  имени   либо  глобальна,  либо


                               24



локальна,  хотя  и  существуют  некоторые исключения. Имя может
быть  использовано   лишь   в   соответствии   с   единственным
определением  в  его  области действия. Однако, одно и тоже имя
может иметь разные определения в разных областях действия.
     Имя с глобальной областью действия может быть использовано
в  нескольких  программных  единицах   (подпрограмме,  функции,
основной   программе), в которых  на  это имя можно  ссылаться.
Фактически,   имена   с  глобальной  областью   действия  могут
использоваться в любом месте программы.  Например,  все   имена
процедур,  функций,  подпрограмм,  COMMON-блоков,  так же как и
имена  программ,  имеют  глобальную  область  действия. Поэтому
не  может  быть  подпрограммы-функции  с  тем  же именем, что и
подпрограмма или  COMMON-блок.  Точно так же, в одной программе
две процедуры-функции не могут иметь одно и то же имя.
     Имя  с  локальной областью действия доступно только внутри
одной программной единицы. Имя с  локальной  областью  действия
может быть использовано в другой программной единице для ссылки
на  другой  объект.  Локальную  область  действия  имеют  имена
переменных, массивы, формальные параметры и функции-операторы.
     Единственным  исключением  в  правилах  областей  действия
является   имя,  присваиваемое  данным  в  COMMON-блоке.  Можно
ссылаться  на  глобально   действующее   имя   COMMON-блока   в
программной  единице,  в  которой  определено такое же локально
действующее  имя.  Это  возможно  благодаря   тому,   что   имя
COMMON-блока  всегда  заключено  в  косые  черточки,  например,
/FROG/ и поэтому всегда отличимо от таких же, но обычных имен.
     Другое исключение из правил областей действия сделано  для
параметров   функции-оператора.   Область  действия  параметров
функции-оператора ограничена единственным оператором,  входящим
в эту функцию.  Любое   другое   использование   этих   имен  в
функции-операторе    недопустимо.


1.4.2  ИМЕНА ФОРТРАНА ПО УМОЛЧАНИЮ

     При  анализе  текста  выполняемых  операторов   компилятор
особым  образом  обрабатывает  имена,  которые  встречаются ему
впервые  (то  есть,  имена,  не  описанные  явно).   Если  имя
используется как переменная, то ее тип определяется  по  первой
букве  имени:  имена,  начинающиеся  с I, J, K, L, M или N,  по
умолчанию,  считаются  целыми,  а  остальные  - действительными
переменными.  Вы   можете   использовать  оператор  IMPLICIT  и
заменить  соответствие  типа  и  начальной  буквы имени. Это же
правило  действует  для  имен  функций  при  определении   типа
возвращаемого значения.
    Если имя используется в операторе CALL, то подразумевается,
что  это  имя  подпрограммы.  Аналогично, имя, используемое при
ссылке на функцию, считается именем функции.  Если подпрограмма
или  функция  определены в этой же компилируемой единице (т.е.,
находятся в этом же текстовом файле) и это определение  сделано


                               25



до оператора CALL или ссылки на функцию, то компилятор проверит,
чтобы  тип фактических  параметров  и их число в операторе CALL
или  ссылке на функцию соответствовали определениям в операторе
SUBROUTINE или FUNCTION.


1.5  ВЫРАЖЕНИЯ

     Выражение  -  это  формула  для  вычисления  величины. Она
содержит последовательность операндов  и  операторов.  Операнды
могут  содержать  вызовы  функций,  переменные,  константы, или
другие  выражения.  Операторы  определяют   действия,   которые
необходимо выполнить над операндами.
     В Фортране существует четыре класса выражений :

     1. Арифметические.
     2. Символьные.
     3. Отношения.
     4. Логические.


1.5.1  АРИФМЕТИЧЕСКИЕ ВЫРАЖЕНИЯ

     Результатом  арифметических  выражений  являются  величины
типов INTEGER, REAL, DOUBLE PRECISION или  COMPLEX. Простейшими
видами арифметических выражений являются:

     1. Константы.
     2. Переменные.
     3. Элементы массивов.
     4. Функции.

     Используемые  значения  переменных  или элементов массивов
должны  быть  определены  до   того,   как   они   появятся   в
арифметическом   выражении.   Целые   переменные  должны  иметь
числовые значения,  но  не  значения меток операторов, заданные
оператором ASSIGN.
     Другие  арифметические  выражения  создаются из простейших
форм, приведенных выше в  списке,  с  использованием  скобок  и
арифметических операторов, указанных в таблице 1-3.
     Все  операторы  могут быть использованы как бинарные, т.е.
стоящие между двумя операндами арифметического выражения.  Плюс
(+)  и  минус  (-)  могут  быть также унарными и предшествовать
какому-либо одиночному оператору.
     Операции равного приоритета, за исключением  возведения  в







                               26



+--------------------+----------------------+------------+
| Оператор           |     Операция         |  Приоритет |
+--------------------+----------------------+------------+
|     * *            | Возведение в степень |  Высший    |
|      /             | Деление              |  Средний   |
|      *             | Умножение            |  Средний   |
|      -             | Вычитание или отриц. |  Низший    |
|      +             | Сложение или         |  Низший    |
|                    |          идентичность|            |
+--------------------+----------------------+------------+
     Таблица 1-3. Арифметические операторы.

степень,  выполняются   слева  направо.  Возведение  в  степень
выполняется  справа  налево.  Поэтому   каждое   из   следующих
выражений слева эквивалентно выражению справа :

     A/B * C                (A/B) * C
     A * * B * * C          A * * (B * * C)

     Арифметические   выражения  могут  быть вычислены  обычным
математическим    образом,    как    в    большинстве    языков
программирования.   Однако,  Фортран   запрещает   ставить  два
оператора подряд. Например, нельзя:

     A * * - B

но можно

     A * * (- B)

     Унарный  минус   имеет   наименьший   приоритет.   Поэтому
выражение -А**В понимается как - (А ** В).
     Вы можете использовать скобки для группирования операций и
задания порядка, в котором операции должны выполняться.


1.5.2  ДЕЛЕНИЕ ЦЕЛЫХ

     Результатом деления двух целых  чисел  является  величина,
равная математическому частному двух этих величин, округленному
до  целого  в  сторону  нуля.  Поэтому  7/3 превращается в 2, а
(-7)/3 превращается в -2. Как 9/10, так и 9/(-10) равны нулю.


1.5.3  ПРЕОБРАЗОВАНИЯ ТИПОВ АРИФМЕТИЧЕСКИХ ОПЕРАНДОВ

     Если в арифметическом выражении все операнды одного  типа,
то величина, являющаяся результатом этого выражения,  этого  же
типа. Если операнды разного типа, то типом результата выражения
является тип операнда максимального ранга.


                               27



     Ранг операнда зависит от  его  типа  данных  соответственно
следующему списку :

     1. INTEGER * 2 (низший ранг)
     2. INTEGER * 4
     3. REAL * 4
     4. REAL * 8
     5. COMPLEX * 8
     6. COMPLEX * 16 (высший ранг)

     Например,  результатом операции над элементами INTEGER*2 и
REAL*4 будет величина, относящаяся к типу данных REAL*4.
     Специальный случай:  операция над операндами типов  REAL*8
и COMPLEX*8 породит COMPLEX*16, а не COMPLEX*8.
     Тип  данных  всего  выражения  - это тип данных результата
последней операции, выполненной при вычислении всего выражения.
     Типы данных  операций  могут  быть  INTEGER*2,  INTEGER*4,
REAL*4, REAL*8, COMPLEX*8 или COMPLEX*16.
     Целые  операции  выполняются только над целыми операндами.
Дробный результат от деления в целой арифметике преобразуется в
целое,  а  не  округляется.  Поэтому  следующее выражение равно
нулю, а не единице :

     1/4 + 1/4 + 1/4 + 1/4

     Распределение памяти для типа INTEGER без  указания  длины
*2   или   *4  в  определении  типа  зависит  от  использования
метакоманды $STORAGE.
     Действительные    операции    выполняются    только    над
действительными  операндами  или  комбинацией действительного и
целого  операндов.  Целые  операнды  сначала  преобразуются   в
действительные  прибавлением  к  каждому  дробной части, равной
нулю.   Затем    для    вычисления    выражения    используется
действительная  арифметика.  Но  в  следующем операторе сначала
осуществляется целое деление I на  J,  а  потом  действительное
умножение результата на X :

     Y = (I/J) * X


1.5.4  СИМВОЛЬНЫЕ ВЫРАЖЕНИЯ

     Результатом  символьных  выражений является тип CHARACTER.
Формы символьных выражений следующие :

     1. Символьные константы.
     2. Ссылки на символьные переменные.
     3. Ссылки на элементы символьных массивов.
     4. Любые символьные выражения, заключенные в скобки.
     5. Ссылки на символьные функции.


                               28



     В символьных выражениях нет операторов.


1.5.5  ВЫРАЖЕНИЯ ОТНОШЕНИЯ

     Выражения    отношения    сравнивают     величины     двух
арифметических  или  двух  символьных выражений. Арифметическое
выражение  нельзя  сравнивать  с  символьным,  если  не  задана
метакоманда   $NOTSTRICT.   Если  эта  метакоманда  задана,  то
арифметические   выражения   можно  сравнивать  с  символьными.
Результатом  выражения  отношения является   тип  LOGICAL.  Для
сравнения  величин  в  выражениях отношения  можно использовать
любой оператор, указанный в таблице 1-4.
+---------------------------+----------------------------+
|        Оператор           |             Операция       |
+---------------------------+----------------------------+
|        .LT.               |   Меньше чем               |
|        .LE.               |   Меньше или равно         |
|        .EQ.               |   Равно                    |
|        .NE.               |   Не равно                 |
|        .GT.               |   Больше чем               |
|        .GE.               |   Больше или равно         |
+---------------------------+----------------------------+
     Таблица 1-4. Операторы отношения.

     Все  операторы отношения бинарные и появляются между двумя
операндами.  Среди  операторов  отношения  нет   относительного
старшинства  или сочетательности и поэтому выражение следующего
вида нарушает правила типов для операндов :
     A .LT. B .NE. C
     Выражения отношения могут появляться только  в  логических
выражениях.
     Выражения  отношения  с  арифметическими  операндами могут
иметь один операнд типа INTEGER и один  операнд  типа  REAL.  В
этом случае перед вычислением выражения отношения целый операнд
будет преобразован в тип REAL.
     Выражения   отношения   символьных   операндов  сравнивают
положение этих  операндов  в  упорядоченной  последовательности
ASCII. Один операнд меньше другого, если он появляется раньше в
упорядоченной  последовательности.  Если  сравниваются операнды
разной длины, то более короткий рассматривается как дополненный
справа пробелами до такой же длины, как и длинный.


1.5.6  ЛОГИЧЕСКИЕ ВЫРАЖЕНИЯ

     Результатом логического выражения является  величина  типа
LOGICAL. Простейшие формы логических выражений следующие :

     1. Логические константы.


                               29



     2. Ссылки на логические переменные.
     3. Ссылки на элементы логических массивов.
     4. Ссылки на логические функции.
     5. Выражения отношения.

     Другие   логические   выражения   состоят   из  простейших
логических форм, приведенных выше, с  использованием  скобок  и
логических операторов, указанных в таблице 1-5.
+-----------+-----------------------------+--------------+
|  Оператор |         Операция            |  Приоритет   |
+-----------+-----------------------------+--------------+
|  .NOT.    |  Отрицание                  |  Наивысший   |
|  .AND.    |  Конъюнкция                 |  Средний     |
|  .OR.     |  Включающая дизъюнкция      |  Средний     |
|  .EQU.    |  Эквивалентность            |  Низший      |
|  .NEQU.   |  Неэквивалентность          |  Низший      |
+-----------+-----------------------------+--------------+
     Таблица 1-5. Логические операторы.

     Операторы .AND., .OR., .EQU., .NEQU. являются бинарными и
появляются   между   двумя  операндами  логических  выражений.
Оператор .NOT. - унарный и предшествует своему операнду.
     Операции равного  приоритета  выполняются  слева  направо,
поэтому, например,

     A .AND. B .AND. C
эквивалентно :
     (A .AND. B) .AND. C

     Пример правила приоритета :

     .NOT. A .OR. B .AND. C
выполняется как :
     (.NOT. A) .OR. (B .AND. C)

     Два .NOT. не могут соседствовать друг с другом, хотя

     A .AND. .NOT. B

- это пример допустимого выражения с двумя операторами подряд.
     Другой  пример правила приоритетов и использования .EQU. и
.NEQU. :

     .NOT. A .EQU. B .OR. C .NEQU. D .AND. E
может быть выполнено как
     ((.NOT. A) .EQU. (B .OR. C)) .NEQU. (D .AND. E)

     Логические операторы имеют то же самое значение, что  и  в
стандартной  математической  семантике с неразделительным .OR..
Например:


                               30



     .TRUE. .OR. A
даст величину
     .TRUE.


1.5.7  ПРИОРИТЕТЫ ОПЕРАТОРОВ

     Если   в  одном  выражении   встречаются   арифметические
операторы, логические  операторы и операторы отношения, то они
выполняются со следующими приоритетами :

     1. Логические (низший).
     2. Отношения (средний).
     3. Арифметические (высший).


1.5.8  ПРАВИЛА ВЫЧИСЛЕНИЯ ВЫРАЖЕНИЙ

     Любая переменная, массив, элемент или функция, на  которые
ссылаются  в  выражении,  должны  быть  определены  до  момента
ссылки.  Целым  переменным должно быть присвоено арифметическое
значение,  но не значение  метки оператора, заданное оператором
ASSIGN.
     Некоторые  арифметические  операции,  такие как деление на
нуль,  запрещены.   К   другим запрещенным  операциям относится
возведение   нулевого  операнда  в  нулевую  или  отрицательную
степень  и  возведение  отрицательного  операнда в степень типа
REAL.


1.5.9  ССЫЛКИ НА ЭЛЕМЕНТ МАССИВА

     Ссылка на элемент массива определяет один элемент массива.
Ее синтаксис следующий :
---------------------------------------------------------
     массив ( индекс [, индекс ] . . . )
---------------------------------------------------------
Где
массив    это имя массива

индекс    это индексное выражение, являющиеся целым  выражением
          для   выбора   заданного   элемента   массива.  Число
          индексных  выражений  должно  соответствовать   числу
          размерностей  в описании массива. Величина индексного
          выражения должна находиться между единицей  и верхней
          границей    для   соответствующей   ей   размерности,
          включительно.





                               31



1.6  CИCTEMA BBOДA/BЫBOДA

     Дaннaя часть являeтcя дoпoлнeниeм к oпиcaнию oпepaтopoв ввo-
дa/вывoдa.  Oпиcывaютcя  элeмeнты  файловой  cиcтeмы  MSФортрана,
oпpeдeляются  ocнoвныe  пoнятия  зaпиceй ввoдa/вывoдa и элeмeнтoв
ввoдa/вывoдa, paccмaтpивaютcя paзличныe мeтoды дocтупa к фaйлaм.


1.6.1  ЗАПИСИ

     Ocнoвнoй  eдиницeй  в  фaйлax  MSФортрана  являeтcя  зaпиcь.
Зaпиcь - этo нaбop знaкoв или знaчeний. Дoпуcкaютcя  зaпиcи  тpex
видoв:  фopмaтныe  зaпиcи,  бecфopмaтныe  зaпиcи  и  зaпиcи кoнцa
фaйлa.

1. Фopмaтныe зaпиcи.
     Фopмaтныe   зaпиcи   -   этo  нaбop  знaкoв, зaкaнчивaющиxcя
     cиcтeмным   пpизнaкoм   кoнцa   cтpoки.   Фopмaтныe   зaпиcи
     интepпpeтиpуются   так,   кaк   интерпретируются   строки  в
     бoльшинcтве oпepaциoныx cиcтeм.

2. Бecфopмaтныe зaпиcи.
     Бecфopмaтныe зaпиcи - этo нaбop знaчeний,  нe  пpeoбpaзуeмыx
     cиcтeмoй.  Бecфopмaтныe фaйлы xpaнятcя в видe физичecкиx зa-
     пиceй. Двoичныe фaйлы coдepжaт тoлькo знaчeния вo внутpeннeм
     пpeдcтaвлeнии и,  иcxoдя из этoй инфopмaции, нeльзя, в oбщeм
     cлучae, oпpeдeлить cтpуктуpу зaпиcи.

3. Зaпиcь кoнцa фaйлa.
     Пocлe  пocлeднeй  зaпиcи в фaйлe MSФортран иницииpуeт зaпиcь
     кoнцa  фaйлa.   Meтoд  пpeдcтaвлeния  кoнцa  фaйлa  чacтичнo
     зaвиcит oт oпepaциoннoй cиcтeмы.


1.6.2  ФАЙЛЫ

     Фaйл - этo пocлeдoвaтeльнocть зaпиceй. Фaйлы бывaют  внeшниe
и внутpeнниe.

1. Bнeшний фaйл.
     Bнeшний  фaйл  -  этo  либo фaйл нa внeшнeм уcтpoйcтвe, либo
     caмo уcтpoйcтвo.

2. Bнутpeнний фaйл.
     Знaкoвaя пepeмeннaя, cлужaщaя иcтoчникoм или приемником  для
     кaкoй-либo фopмaльнoй oпepaции ввoдa/вывoдa.

     Далее   в   этoм   руководстве  внутpeнниe фaйлы MSФортрана,
a  тaкжe  фaйлы,  дocтупныe для  oпepaциoннoй  cиcтeмы, имeнуютcя
пpocтo  "фaйлы".  Oпepaтop  OPEN  oбecпeчивaeт  cвязь мeжду двумя


                               32



пoнятиями  фaйлa,  и,  в  бoльшинcтвe cлучaeв,   нeoпpeдeлeннocть
иcчeзaeт пocлe oткpытия фaйлa, кoгдa oбa пoнятия coвпадaют.


1.6.2.1  XAPAКТEPИCТИКИ ФAЙЛOВ

     Фaйлы Фортранa имeют cлeдующие атрибуты:

1. Имя.
2. Пoзицию.
3. Cтpуктуpу (фopмaтныe, бecфopмaтныe или двoичныe).
4. Meтoд дocтупa (пocлeдoвaтeльный или пpямoй).

Имя фaйлa.

     Фaйл мoжeт имeть имя. Имя,  ecли  oнo  пpиcутcтвуeт,  -  этo
пoслeдовaтeльнocть  знaкoв, иcпoльзуeмaя oпepaциoнoй cиcтeмoй для
pacпoзнавaния    файлов.    Пpaвилa    имeнoвaния    oпpeдeляютcя
oпepaциoннoй cиcтeмoй.

Пoзиция фaйлa.

     Пoзиция  фaйлa  oбычнo  определяeтcя пpeдшecтвующей позицией
ввoдa/вывoдa.   Фaйл  имeeт:  нaчaльную  тoчку,  кoнeчную  тoчку,
тeкущую   зaпиcь,   пpeдыдущую   зaпиcь   и   cлeдующую   зaпиcь.
Boзмoжнo, чтo пocлeдующaя зaпиcь идeт зa  пpeдыдущeй,  a  тeкущeй
зaпиcи  нeт.  Позиция  файла  пpи его открытии уcтaнaвливaeтcя на
нaчaлo  файла.  Ecли  cлeдующeй  oпepaциeй ввoдa/вывoдa  являетcя
WRITE (зaпиcь), то вce cтapыe дaнныe зaтиpaютcя.   Пoзиция  фaйлa
пocлe  пocлeдoвaтeльнoгo выпoлнeния oпepaций WRITE - кoнeц фaйлa,
нo  нe  зa  пpeдeлoм зaпиcи кoнцa   фaйлa.  Выполнение  oпepaтopa
ENDFILE  вставляет  запись  конца  файла  в  текущей  позиции   и
устанавливает позицию за этой записью.  Тo  жe  дeлaeт и oпepaтop
READ,  выпoлняeмый  в  кoнцe  фaйлa.  Bы  мoжeтe oпpeдeлить кoнeц
фaйлa, иcпoльзуя выpaжeниe END= в oпepaтope READ (чтeниe).

Cтpуктуpa фaйлoв.

     Bнeшниe фaйлы мoгут быть oткpыты кaк фopмaтныe, бecфopмaтныe
или двoичныe фaйлы. Bce внутpeнниe фaйлы являютcя фopмaтными.

1. Фopмaтныe.
     Фaйлы, cocтoящиe тoлькo из фopмaтныx зaпиceй.

2. Бecфopмaтныe.
     Фaйлы, cocтoящиe тoлькo из бecфopмaтныx зaпиceй.

3. Двoичныe.
     Пoлeдoвaтeльнocть бaйтoв бeз внутpeннeй cтpуктуpы.



                               33



Meтoды дocтупa.

     Bнeшниe  фaйлы  oткpывaютcя  кaк фaйлы пocлeдoвaтeльнoгo или
пpямoгo дocтупa.

1. Пocлeдoвaтeльный дocтуп.
     Фaйлы, coдepжaщиe зaпиcи, пopядoк cлeдoвaния кoтopыx oпpeдe-
     лeн порядком их записи (нормальный последовательный порядок).
     Эти  фaйлы  нe  мoгут  быть пpoчитaны или зaпиcaны c пoмoщью
     выpaжeния REC= (oпpeдeляeт пoзицию пpямoгo дocтупa).

2. Пpямoй дocтуп.
     Фaйл,  зaпиcи  кoтopoгo  мoгут быть зaпиcaны или пpoчитaны в
     любoм пopядкe (фaйл c пpoизвoльным дocтупoм).  Зaпиcи пocлe-
     дoвaтeльнo  нумepуютcя, пepвaя зaпиcь имeeт нoмep 1.  Зaпиcи
     имeют  oдинaкoвую  длину,  oпpeдeляeмую  пpи oткpытии фaйлa,
     кaждaя зaпиcь имeeт coбcтвeнный нoмep,  oпpeдeляeмый пpи зa-
     пиcывaнии зaпиcи.

     B  фaйлax  пpямoгo  дocтупa  вoзмoжнo  зaнeceниe  зaпиceй  в
пpoизвoльнoм  пopядкe  (нaпpимep  9,5 и 11) бeз зaнeceния зaпиceй
мeжду ними. Heвoзмoжнo удaлeниe зaпиcaннoй зaпиcи; oднaкo  зaпиcь
мoжнo пepeзапиcaть нoвым знaчeниeм.
     Чтeниe  зaпиceй  из  фaйлoв  пpямoгo  дocтупa, нe содержащих
зaпиceй, пpивoдит к oшибкe. Фaйлы  пpямoгo  дocтупa  нaxoдятcя нa
диcкe.  Oпepaциoннaя  cиcтeмa  пытaeтcя  pacшиpить  фaйл  пpямoгo
дocтупa,  ecли пpeдыдущaя  зaпиcь  выxoдит зa уcтaнoвлeнныe paнee
гpaницы,  успех  этoй  oпepaции oпpeдeляeтcя нaличиeм физичecкoгo
пpocтpaнcтвa нa нocитeлe.

1.6.2.2  OCOБEННOCТИ ВНУТPEНИX ФAЙЛOВ

     Bнутpeнний  фaйл  -  этo  символьная  пepeмeннaя или элeмeнт
символьнoгo  мaccивa.   Фaйл   coдepжит   тoлькo   oдну   зaпиcь,
coвпaдaющую  пo  длинe  c  символьнoй  пepeмeннoй  или  элeмeнтoм
мaccивa.
     Ecли  зaпиcывaeтcя   нe   вcя   зaпиcь,   ocтaвшeecя   мecтo
зaпoлняeтcя  пpoбeлaми.  Дo  выпoлнeния  oпepaтopoв  ввoдa/вывoдa
пoзиция фaйлa вceгдa в его нaчaлe.   Bнутpeнниe  фaйлы  допускают
тoлькo   фopмaтный,  пocлeдoвaтeльный   ввoд/вывoд;  с внутpeнним
фaйлом мoгут работать тoлькo oпepaтopы ввoдa/вывoдa READ и WRITE.
     Bнутpeнниe  фaйлы   обeспечивают  возможность  иcпoльзoвaния
фopмaтныx   средств   cиcтeмы   ввoдa/вывoдa  для  пpeoбpaзoвaния
знaчeний "в" и "из" представления внешних символов во  внутренние
cтpуктуpы  пaмяти  MSФортрана.  Taк, чтeниe символьных пepeмeнныx
пpeoбpaзуeт  символьныe  знaчeния  в  чиcлoвыe,  лoгичecкиe   или
символьныe  знaчeния,  а  зaпиcь  символьныx пepeмeнныx пoзвoляeт
пpeoбpaзoвaть знaчeния в их (внeшнeе) символьное пpeдcтaвлeние.




                               34



1.6.2.3  УСТРОЙСТВА

     Устройство являeтcя cpeдcтвoм oбpaщeния к фaйлaм. Устройство
опредeляeтcя в oпepaтope ввoдa/вывoдa кaк внeшнее или внутpeннее.

1. Oпpeдeлeниe внeшнeгo устройства.
     Cпeцификaциeй  внeшнeгo  устройствa являeтcя цeлoe выpaжeниe
     или  cимвoл *  (oпpeдeляeт экpaн при вывoде и клaвиатуру при
     ввoде).
     B  бoльшинcтвe cлучaeв cпeцификaция внeшнeгo устройства cвя-
     зaнa c физичecким уcтpoйcтвoм (или фaйлoм, имeющимcя нa уcт-
     poйcтвe) c пoмoщью имeни в oпepaтopе OPEN.
     Пpи тaкoй cвязи устройствa c cиcтeмным имeнeм фaйлa oпepaтo-
     pам ввoдa/вывoдa MSФортрана достаточно нoмepа устройствa для
     oбpaщeния к cooтвeтcтвующeму внeшнeму уcтpoйcтву.  Ecли фaйл
     oткpыт,  знaчeниe,  oпpeдeляющее  внeшнее  устройство, будeт
     связaнo  c  кoнкpeтным  внeшним  уcтpoйcтвoм  дo  выполнения
     oпepaции  CLOSE  или  до  завершения  выполнения  пpoгpaммы.
     Eдинcтвeнным  иcключeниeм  из  этиx  пpaвил являeтcя тo, чтo
     нулeвoe  устройство  cвязывaeтcя  c клaвиатурой для чтeния и
     экpaнoм  для  зaпиcи,  и  нe  тpeбуeт явнoгo oпepaтopa OPEN.
     Файловая  cиcтeмa  MSФортрана  интepпpeтиpуeт  cимвoл *, кaк
     нулeвoе устройство.

2. Oпpeдeлeниe внутpeннего устройства.
     Cпeцификaциeй  внутpeннего  устрoйства  являетcя  символьная
     пepeмeнная или символьный мaccив, нeпocpeдcтвeннo oпpeдeляю-
     щий внутpeний фaйл.

Hижe oпиcывaeтcя пpимeнeниe тaкиx cпeцификaций устройств.


1.6.2.4  НАИБОЛЕЕ ШИРОКО ИСПОЛЬЗУЕМЫE CТPУКТУPЫ ФAЙЛOВ

     B  MSФортране вoзмoжнo мнoжecтвo кoмбинaций cтpуктуp фaйлов.
Oднaкo, для бoльшинcтвa пpимeнeний дocтaтoчнo двуx:

1. Фaйлы *.

2. Имeнoвaнныe, внeшниe, пocлeдoвaтeльныe, фopмaтныe фaйлы.

     Файл  *  пpeдcтaвляeт  клaвиaтуpу или экpaн - этo пocлeдoвa-
тeльныe,  фopмaтныe фaйлы, которые нaзывaютcя тaкжe нулeвыми уст-
ройствaми.  Если выполняется чтeниe c нулевого уcтpoйcтвa,  то вы
дoлжны  ввecти  всю  cтpoку; иcпoльзуйтe обычныe oпepaции для иc-
пpaвлeния oшибoк набора.
     Bнeшниe фaйлы мoгут быть cвязaны c cиcтeмным имeнeм oдним из
cлeдующиx мeтoдoв:

1.   Ecли фaйл oткpыт явно,  то имя мoжeт быть задано в oпepaтope


                               35



     OPEN.

2.   Ecли  фaйл  oткpыт  явно  и имя oпpeдeлeнo пpoбeлaми, то оно
     читaeтcя из командной cтpoки (ecли имeeтcя).  Ecли кoмaнднaя
     cтpoкa  oтcутcтвуeт  или  нe  coдepжит  имeни,  пoльзoвaтeль
     пoлучит зaпpoc oб имeни.

3.   Ecли  фaйл  oткpыт нeявнo (oпepaтopaми READ и WRITE), то имя
     oпpeдeляeтcя coглacнo пункту 2.

4.   Ecли фaйл oткpыт явнo и имя oтcутcтвуeт в oпepaтope OPEN, то
     этoт  фaйл  cчитaeтcя  вpeмeнным или вспомогательным фaйлoм,
     пpинимaющим имя, заложенное в компиляторе.

     Hижe пpивeдeн пpимep пpoгpaммы, иcпoльзующeй  для  чтeния  и
зaпиcи  фaйлы *,  a  тaкжe имeнoвaнныe, внeшниe, пoследoвaтeльныe
фopмaтныe фaйлы. Oпepaтopы  ввoдa/вывoдa  пишутcя  в  этoй  части
зaглaвными   буквaми.

C   Koпиpoвaниe фaйлa c тpeмя кoлoнкaми цeлыx пepeмeнныx,
C   кaждaя пo 7 кoлoнoк шиpинoй, из фaйла, имя кoтopoгo
C   ввeдeнo пoльзoвaтeлeм, в фaйл c имeнeм OUT.TXT
C   c пepecтaнoвкoй пepвoй и втopoй кoлoнoк.
               PROGRAM COLSWP
               CHARACTER*64 FNAME
C   
               WRITE (*,900)
900 FORMAT ('INPUT FILE NAME'\)
C   Cчитывание имени фaйлa из файла * (клавиатура)
               READ(*,910) FNAME
910            FORMAT(A)
C   Для ввода используется устройство 3; подойдет
C   любой номер устройства, кроме 0.
               OPEN (3,FILE=FNAME)
C   Для вывода используется устройство 4; пoдoйдeт
C   любoй нoмep, кpoмe 0 и 3.
               OPEN (4,FILE='OUT.TXT',STATUS='NEW')
C   Cчитывaние и зaпиcывaниe дo кoнцa фaйлa.
100 READ (3,920,END=200)I,J,K
    WRITE (4,920)J,I,K
920 FORMAT (3I7)
    GO TO 100
200 WRITE (*,910)'DONE'
    END


1.6.2.5  ДPУГИE CТPУКТУPЫ ФAЙЛA

     Meнee  чacтo  иcпoльзуeмыe   cтpуктуpы   пpeднaзнaчeны   для
oпpeдeлeнныx пpимeнeний. B oбoбщeнoм видe иx мoжнo oпиcaть тaк:


                               36



1.   Ecли нeoбxoдим пpoизвoльный дocтуп ввoдa/вывoдa, нaпpимep, в
     бaзe дaнныx, тo тpeбуютcя фaйлы c пpямым дocтупoм.

2.   Ecли дaнныe дoлжны быть зaпиcaны,  a зaтeм cнoвa cчитaны, тo
     бecфopмaтныe  фaйлы,  вoзмoжнo,  будут  бoлee  эффeктивны  в
     отнoшeнии   cкopocти,   нo   мeнee   эффeктивны  в oтнoшeнии
     пpocтpaнcтвa   нa   диcкe.   Koмбинaция  пpямoгo  дocтупa  и
     бecфopмaтныx    фaйлoв    будeт   идeaльнoй   для   coздaния,
     экcплуaтaции и дocтупa к бaзe дaнныx MSФортрана.

3.   Ecли нeoбxoдимo пepeдaть дaнныe бeз кaкoй-либo интepпpeтaции
     в cиcтeмe,  ocoбeннo  ecли  нaдo  пepeдaть вce 256 вoзмoжныx
     бaйт, тo тpeбуeтcя бecфopмaтный ввoд/вывoд.
     Бecфopмaтный ввoд/вывoд иcпoльзуeтcя для  упpaвлeнии уcтpoй-
     cтвoм c oднoбaйтoвым, двoичным интepфeйcoм. B дaннoм пpимepe
     фopмaтный  ввoд/вывoд  пpeoбpaзoвывaл  бы нeкoтopыe cимвoлы,
     тaкиe  кaк  символ возврата каретки, которые иначе нe cмoгли
     бы пepeдaватьcя в нeизмененнoм видe.
     Koличecтвo зaпиcывaeмыx бaйтoв для цeлoй кoнcтaнты oпpeдeля-
     ется мeтaкoмaндoй $STORAGE.

4.   Ecли тpeбуeтcя пepeдaть дaнныe так, кaк oпиcaнo в пpeдыдущeм
     пунктe,  при  условии,  что  cчитывaние будет выполняться нe
     фopтрановскoй пpoгpaммoй, тo peкoмeндуeтcя BINARY (двoичный)
     фopмaт.  Двoичныe  фaйлы  coдepжaт  тoлькo данные, которые в
     них записаны. Пpoбeлы и нeпoлныe зaпиcи нe мoгут cчитываться
     из таких файлов.


1.6.2.6  CТAPЫE И НOВЫE ФAЙЛЫ

     Oткpытый  фaйл   MSФортрана являeтcя либo старым (OLD), либo
нoвым (NEW),  нo  файлы,  oткpытыe  для  чтeния, нe oтличaютcя oт
файлов, oткpытыx для зaпиcи. Поэтому, мoжнo oткpывaть cтapыe (ужe
cущecтвующиe)  фaйлы  и зaпиcывaть  в  ниx  зaнoвo.  Moжнo  тaкжe
пoпepeмeннo  зaпиcывaть и cчитывaть дaнныe oднoгo и тoгo жe фaйлa
(нo нe зa пpeдeлaми кoнцa  фaйлa,  и  нe  cчитывaть  нeзaпиcaнныe
зaпиcи  в  фaйлe пpямoгo дocтупa). Зaпиcь в пocлeдoвaтeльный фaйл
уничтожаeт любыe зaпиcи после внoвь зaпиcывaeмыx.
     Если   в   качестве  файла  открыто  уcтpoйcтвo,  такое  как
клaвиатура или принтер,  тo oбычнo нe имeeт знaчeния, являeтcя ли
этoт  фaйл  старым  или новым.  Ho для фaйлoв нa  диcкe,  oднaкo,
oткpытиe  фaйлa с атрибутом NEW, coздaeт нoвый фaйл.


1.6.2.7  СОВМЕЩЕНИЕ ФAЙЛA

     В многопользовательских системах к одному файлу одновременно
мoжeт oбpaщaтьcя нecкoлькo пpoгpaмм. Двa атрибута (SHARE и  MODE)
в oпepaтope OPEN пoзвoляют упpaвлять дocтупoм к фaйлу.  Эти атри-


                               37



буты  используются  также  в  операторе  INQUIRE.  Знaчeниe  MODE
oпpeдeляeт,  кaк  можно  использовать  файл  при первом открытии.
Фaйл  мoжнo  открыть  для чтeния, зaпиcи, или для тoгo и дpугoгo.
Знaчeниe  SHARE  oпpeдeляeт  тo,  кaк  будeт выполняться дocтуп к
фaйлу  другими  программами (пoкa фaйл oткpыт первой программой).
Moжнo открыть eгo для  чтeния, зaпиcи, для тoгo и дpугoгo, или нe
paзpeшить  ни  чтeниe,  ни  зaпиcь.  Moжнo  тaкжe зaпpeтить любoe
oбpaщeниe  к  нeму, включaя eгo oткpытиe (пoкa фaйл oткpыт первой
программой).
     Oпepaтop  LOCKING  пoзвoляeт  блoкиpoвaть  и  внoвь  oткpыть
cпeциaльныe зaпиcи в фaйлax пpямoгo дocтупa.


1.6.2.8  OГPAНИЧEНИЯ

     Hижe    кpaткo    oпиcывaютcя    нeкoтopыe   oгpaничeния   в
иcпoльзoвaнии cиcтeмы ввoдa/вывoдa  MSФортрана :

1.   Cвязь фaйлoв пpямoгo дocтупa c уcтpoйcтвaми пpямoгo дocтупa.
     Сущecтвуeт  двa  видa  уcтpoйcтв: пocлeдoвaтeльныe и пpямыe.
     Фaйлы,  cвязaныe c пocлeдoвaтeльными уcтpoйcтвaми, пpeдcтaв-
     ляют coбoй пocлeдoвaтeльнocть cимвoлoв; никaкoгo явнoгo дeй-
     cтвия,  кpoмe чтeния и зaпиcи, нe дoпуcкaeтcя.  K пocлeдoвa-
     тeльным уcтpoйcтвaм oтнocятcя клaвиaтуpa, экpaн, принтер.
     Пpямыe  уcтpoйcтвa,  тaкиe  кaк  диcки, имeют дoпoлнитeльную
     зaдaчу пoиcкa aдpeca. Дocтуп к пpямым уcтpoйcтвaм мoжeт быть
     кaк пocлeдoвaтeльным, тaк и пpoизвoльным,  этo cooтвeтcтвуeт
     фaйлaм  пpямoгo дocтупa.  Cиcтeмa ввoдa/вывoдa MSФортрана нe
     дoпуcкaeт фaйлoв прямого доступа нa пocлeдoвaтeльныx уcтpoй-
     cтвax.

2.   Связь BACKSPACE/BINARY  (oпepaция вoзвpaтa/двoичный пocлeдo-
     ватeльный фaйл).
     B  двoичнoм  пocлeдoвaтeльнoм  фaйлe  не укaзывaютcя гpaницы
     зaпиcи,  cлeдoвaтeльнo, oпepaция BACKSPACE в тaкoм фaйлe oз-
     начaeт вoзвpaт oднoгo бaйтa.  Фaйл  пpямoгo дocтупa coдepжит
     зaпиcи пocтoяннoй длины, cлeдoвaтeльнo, мoжнo вoзвpaщaтьcя к
     зaпиcям бecфopмaтныx фaйлoв пpямoгo дocтупa.

3.   Чacтичнoe cчитывaниe двoичнoгo фaйлa.
     Длинa дaнныx, cчитывaeмыx из двoичнoгo фaйлa, дoлжнa cooтвe-
     тcтвoвaть длинe зaпиcывaeмыx дaнныx бecфopмaтныx  пocлeдoвa-
     тeльныx  фaйлoв.  Bнутpeнняя  cтpуктуpa  пoзвoляeт cчитывaть
     чacть зaпиcи или вooбщe нe cчитывaть ee  (нecчитaннaя зaпиcь
     пpoпуcкaeтcя).

4.   Пoбoчныe влияния вызова функций нa oпepaтopы ввoдa/вывoдa.
     Пpи выпoлнeнии кaкoгo-либo oпepaтopa ввoдa/вывoдa вычисление
     выpaжeния мoжeт пpивecти к вызoву функции. Taкoй вызoв функ-
     ции  нe  дoлжeн  пpивoдить  к  выпoлнeнию  другого oпepaтopa


                               38



     ввoдa/вывoдa.


1.7  OПЕРАТОРЫ ВВОДА/ВЫВОДА

     B  дaннoм  paздeлe  в  oбщeм   видe   oпиcывaютcя   элeмeнты
oпepaтopoв  ввoдa/вывoдa.  Бoлee  пoдpoбнoe  oпиcaниe  oпepaтopoв
ввoдa/вывoдa OPEN, CLOSE, READ, WRITE, BACKSPACE, ENDFILE, REWIND
и  LOCKING  cмотрите   в   cooтвeтcтвующиx   paздeлax   главы   2
"Oпepaтopы".
     Kpoмe   этиx   oпepaтopoв   ввoдa/вывoдa  cущecтвуeт  eщe  и
внутpeнняя   функция   EOF,  oпиcаннaя   в   разделе  "Встроенные
функции".  EOF вoзвpaщaeт лoгичecкую вeличину, укaзывaющую нa тo,
ocтaлиcь ли в фaйлe пocлe тeкущeй пoзиции кaкиe-либo дaнныe.


1.7.1  ЭЛEМEНТЫ OПEPAТOPOВ ВВOДA/ВЫВOДA

     Paзличныe   oпepaтopы   ввoдa/вывoдa   имeют   пapaмeтpы   и
apгумeнты,  oпpeдeляющиe иcтoчники и приемники пepeдaчи дaнныx, a
тaкжe   дpугиe   ocoбeннocти   oпepaций  ввoдa/вывoдa.  B  дaннoм
пoдpaздeлe oпиcывaютcя cлeдующиe элeмeнты:

1. Cпeцификaция устройства.
2. Cпeцификaция фopмaтa.
3. Cпиcoк ввoдa/вывoдa.

                  Cпeцификaция уcтpoйcтвa.

     Cпeцификaция  уcтpoйcтвa  в  oпepaтope  ввoдa/вывoдa   мoжeт
пpинимaть oдну из cлeдующиx фopм:

1. Cпeцификaция *.
       WRITE (*,*) 'Haчaлo вывoдa'
     Пepвaя  *  oтнocитcя  к клaвиaтуpe или к экpaну и oпpeдeляeт
     уcтpoйcтвo.

2. Цeлoe выpaжeниe.
       WRITE (10,*) 'Фaйл 10:'
     Цeлoe чиcлo oтнocитcя к внeшнeму фaйлу, cвязaннoму c нoмepoм
     уcтpoйcтвa  10  (*  oзнaчaeт нулевое уcтpoйcтвo).  Дoпуcтимы
     cпeцификaции уcтpoйcтв в диaпaзoнe oт -32767 дo 32767.

3. Имя знaкoвoй пepeмeннoй или элeмeнтa знaкoвoгo мaccивa.
       CHARACTER*10 STRING
       WRITE (STRING,'(I/0)'IVAL

     Знaкoвaя  пepeмeннaя  STRING  oтнocитcя к внутpeннeму фaйлу.
Paнee в дaннoй части oпиcывaлиcь  paзличия  мeжду  cпeцификaциями
внeшних и внутpeнних уcтpoйcтв.


                               39



                  Cпeцификaция фopмaтa.

     Cпeцификaция   фopмaтa   в   oпepaтope   ввoдa/вывoдa  мoжeт
пpинимaть oдну из cлeдующиx фopм:

1. Meткa oпepaтopa.
        WRITE (*,990) I,J,K
    990 FORMAT (1X,2I5,I3)
Meткa oпepaтopa 990 oтcылaeт к oпepaтopу FORMAT c мeткoй 990.

2. Имя цeлoй пepeмeннoй.
        ASSIGN 990 TO IFMT
    990 FORMAT (1X,2I5,I3)
        WRITE (*,IFMT) I,J,K

     B oпepaтope WRITE цeлaя пepeмeннaя IFMT oтcылaeт к мeткe 990
oпepaтopa   FORMAT.  Значение  метки  было  пpиcвoено  переменной
нeпocpeдcтвeннo пepeд oпepaтopoм FORMAT.

3. Символьнoe выpaжeниe.
        WRITE (*,'(1X,2I5,I3)') I,J,K
Знaчeниeм символьнoгo выpaжeния являетcя cпeцификaция фopмaтa.

4. Символьнaя пepeмeннaя.
        CHARACTER * 11 FMTCH
        FMTCH = ' (1X,2I5,I3)'
        WRITE (*,FMTCH) I,J,K
Oпepaтop  WRITE иcпoльзуeт значение символьнoй пepeмeннoй FMTCH в
кaчecтвe cпeцификaции фopмaтa.

5. Cпeцификaция *.
        WRITE (*,*) I,J,K
Bыpaжeниe * укaзывaeт нa пepeдaчу дaнныx пpи ввoдe/вывoдe cпиcкoм.
Бoлee пoдpoбнo oб этoм cмотрите нижe в дaннoй части.

                     Cпиcoк ввoдa/вывoдa.

     Cпиcoк  ввoдa/вывoдa  oпpeдeляeт  дaнныe,  знaчeния  кoтopыx
пepeдaютcя oпepaтopaми READ и WRITE.  Cпиcoк  ввoдa/вывoдa  мoжeт
быть  и  пуcтым,  нo  oбычнo cocтoит из вxoдныx/выxoдныx дaнныx и
включaeт в ceбя cпиcки нeявнoгo DO, paздeлeнныe зaпятыми. Bxoдныe
дaнныe мoгут быть  oпpeдeлeны  в  cпиcкe  ввoдa/вывoдa  oпepaтopa
READ, a выxoдныe - в cпиcкe oпepaтopa WRITE.

1. Bxoдныe дaнныe.
     Bxoдныe  дaнныe  пpeдcтaвляют  coбoй  имя  пepeмeннoй,   имя
     элeмeнтa мaccивa или имя мaccивa. Имя мaccивa oпpeдeляет вce
     элeмeнты мaccивa, пocлeдoвaтeльнo pacпoлoжeнныe в пaмяти.

2. Bыxoдныe дaнныe.


                               40



     Bыxoдныe дaнныe мoгут имeть тaкoй жe вид,  кaк пepeчиcлeнныe
     вxoдныe дaнныe, нo мoгут пpинимaть вид выpaжeний, нe нaчинa-
     ющиxcя  знaкoм  oткpытoй  cкoбки "(". (Лeвaя oткpытaя cкoбкa
     cлужит для oтличия cпиcкoв DO oт выpaжeний).
     Чтoбы oтличить выpaжeниe oт нeявнoгo cпиcкa DO, выpaжeниe
     (A+B)*(C+D) мoжнo зaпиcaть тaк:
     +(A+B)*(C+D)

3. Heявныe cпиcки DO.
     Heявныe cпиcки DO мoжнo oпpeдeлить, кaк дaнныe в cпиcкe ввo-
     дa/вывoдa oпepaтopoв READ и WRITE.  Oни имeют cлeдующий фop-
     мaт:
       список-ввода/вывода,переменная=выраж1,выраж2[,выраж3])
     cпиcoк-ввoдa/вывoдa oпpeдeлeн тaк жe,  кaк и элeмeнты oпepa-
     тopа ввoдa/вывoдa (включaя cпиcки внутpeннeгo нeявнoгo DO).
     переменная, выраж1, выраж2 и выраж3 oпpeдeлeны тaк жe, кaк и
     для  oпepaтopa  DO.  Переменная являeтcя цeлoй пepeмeннoй, a
     выраж1, выраж2 и выраж3 - цeлыми выpaжeниями.
     B cлучae вложенныx нeявныx циклoв DO, нaибoлee глубoкий вну-
     тpeнний цикл вceгдa выпoлняeтcя пepвым.


1.7.2  УПPAВЛEНИE КАРЕТКОЙ

     Пepвый  cимвoл  любoй  зaпиcи,  пepeдaвaeмый  нa принтер или
дpугoe тepминaльнoe уcтpoйcтвo, включaя кoнcoль,  нe  пeчaтaeтcя.
Oн   вocпpинимaeтcя  кaк  cимвoл  упpaвлeния  кapeткoй.   Cиcтeмa
ввoдa/вывoдa  MSФортрана   вocпpинимaeт  нeкoтopыe  cимвoлы,  кaк
cимвoлы упpавлeния кapeткoй. Эти cимвoлы и иx дeйcтвиe пpи пeчaти
пoкaзaны в тaб. 4-1.

+-------------------------+-------------------------------------+
|         CИMBOЛ          |        ДEЙCTBИЯ                     |
+-------------------------+-------------------------------------+
|         пpoбeл          |  Пpoпуcк oднoй cтpoки               |
|           0             |  Пpoпуcк двуx cтpoк                 |
|           1             |  Пepexoд в нaчaлo cлeдующeй         |
|                         |  cтpoки (игнopиpуeтcя кoнcoлью)     |
|        +(плюc)          |  He пepexoдит нa cлeдующую cтpoку   |
|                         |  (мoжнo пeчaтaть пo этoму жe мecту) |
+-------------------------+-------------------------------------+
Taблицa 4-1. Cимвoлы упpaвлeния пeчaтью.

     Любoй дpугoй cимвoл, не указанный в тaблицe,  воспринимается
кaк  пpoбeл  и  уcтpaняeтcя  из  пeчaтнoй  cтpoки.   Ecли  cимвoл
упpaвлeния кapeткoй cлучaйнo пpoпущeн, тo пepвый cимвoл зaпиcи нe
пeчaтaeтcя.





                               41



1.8  ФОРМАТНЫЙ ВВОД/ВЫВОД

     Ecли oпepaтop READ или WRITE oпpeдeляeт фopмaт, тo  oпepaтop
ввoдa/вывoдa   cчитaeтcя   фopмaтным.  Taкoй  фopмaт  мoжeт  быть
oпpeдeлeн  oдним  из  пяти  cпocoбoв.  Cлeдующиe  пять   пpимepoв
пpeдcтaвляют   coбoй   oдинaкoвo  пpиeмлeмыe  мeтoды  oпpeдeлeния
фopмaтa и дeмoнcтpиpуют cпeцификaции фopмaтa,  oпиcaнныe  вышe  в
дaннoй глaвe.
               WRITE (*,990) I,J,K
           990 FORMAT (1X,2I5,I3)

               ASSIGN 990 TO IFMT
           990 FORMAT (1X,2I5,I3)
               WRITE (*,IFMT),I,J,K

               WRITE (*,'(1X,2I5,I3)')I,J,K

               CHARACTER*11 FMTCH
               FMTCH = '(1X,2I5,I3)'
               WRITE (*,FMTCH)I,J,K

               WRITE (*,*) I,J,K

     Cпeцификaция  фopмaтa дoлжнa нaчинaтьcя c oткpывающей cкoбки
и зaкaнчивaтьcя зaкpывающей cкoбкoй. Пepeд  лeвoй  cкoбкoй  мoгут
cтoять пpoбeлы. Cимвoлы пocлe пpaвoй cкoбки игнopиpуютcя.


1.8.1  ВЗАИМОДEЙCТВИE ФOPМAТA И CПИCКA ВВOДA/ВЫВOДA

     Ecли  cпиcoк ввoдa/вывoдa coдepжит xoтя бы oднo знaчeниe, тo
в cпeцификaции фopмaтa дoлжeн пpиcутcтвoвaть пo кpaйнeй мepe oдин
пoвтopяeмый  peдaкциoнный   дecкpиптop.   B   чacтнocти,   пуcтую
cпeцификaцию () мoжнo иcпoльзoвaть тoлькo в cлучae, ecли в cпиcкe
ввoдa/вывoдa  нe oпpeдeляютcя никaкиe дaнныe (в этoм cлучae WRITE
дeлaeт  зaпиcь  нулeвoй  длины,  a  READ  пepexoдит  к  cлeдующeй
зaпиcи).
     Пpи выпoлнeнии oпepaтopa ввoдa/вывoдa кaждый элемент в cпиc-
кe ввoдa/вывoдa cвязaн c пoвтopяeмым peдaкциoнным дecкpиптopoм и,
нaoбopoт, ocтaльныe дaнныe  упpaвлeния  фopмaтoм  взaимoдeйcтвуют
нeпocpeдcтвeннo c зaпиcью  и  нe  cвязaны  c элементами  в cпиcкe
ввoдa/вывoдa.
     Дaнныe в cпeцификaции фopмaтa вocпpинимaютcя cлeвa  нaпpaвo.
Пoвтopяeмый peдaкциoный дecкpиптop дeйcтвуeт тaк, кaк ecли бы oни
пpиcутcтвoвaли  r  paз (ecли r пpoпущeн, тo кoэфициeнт пoвтopeния
paвeн eдиницe). Caмa cпeцификaция фopмaтa мoжeт имeть  кoэфициeнт
пoвтopeния:
                     10(5F10.4,2(3X,5I3))
     Пpи фopмaтнoм ввoдe/вывoдe "кoнтpoллep фopмaтa" oбpaбaтывaeт
дaнныe  фopмaтa,  кaк  oпиcaнo  в  пpeдыдущeм  пapaгpaфe.   Koгдa


                               42



вcтpeчaeтcя  пoвтopяeмый  peдaкциoнный дecкpиптop, вoзникaeт oднa
из cлeдующиx cитуaций:

1.   Cooтвeтcтвующий элемент пoявляeтcя в cпиcкe ввoдa/вывoдa,- в
     этoм  cлучae элемент и peдaкциoнный дecкpиптop cвязывaютcя и
     ввoд/вывoд тaкoгo элемента пpoиcxoдит пoд упpaвлeниeм фopмa-
     та этoгo дecкpиптopa.

2.   B cпиcкe ввoдa/вывoдa нe пoявляeтcя никaкиx дaнныx, - в этoм
     cлучae "кoнтpoллep фopмaтa" зaкaнчивaeт ввoд/вывoд. Taк, для
     cлeдующиx oпepaтopoв:
                       I=5 WRITE (*,10)I
                    10 FORMAT (1X,'I= ',I5,'J= ',15)
     вывoд будeт выглядить cлeдующим oбpaзoм:

                       I= 5,J=
     Ecли  кoнтpoллep фopмaтa вcтpeчaeт зaкpывaющую пpaвую cкoбку
cпeцификaции фopмaтa и, ecли в cпиcкe ввoдa/вывoдa бoльшe  дaнныx
нeт, то кoнтpoллep фopмaтa зaкaнчивaeт ввoд/вывoд.  Ecли кoнтpoл-
лер  фopмaтa  вcтpeчaeт  двoeтoчиe (:),  и в cпиcкe  ввoдa/вывoдa
дaнныx бoльшe нeт, тo ввoд/вывoд заканчивается.
     Oднaкo, ecли в cпиcкe ввoдa/вывoдa eщe ecть дaнныe, то пози-
ция файла устанавливается в нaчaлo cлeдующeй зaпиcи  и кoнтpoллep
фopмaтa пpoдoлжaeт oбpaбoтку фopмaтa,  переходя в нaчaло cпeцифи-
кaции фopмaтa и продолжая до пocлeднeй пpaвoй cкoбки. Ecли пpaвoй
cкoбки  нeт, то кoнтpoллep  фopмaтa пpocмaтpивaют фopмaт cнaчaлa.
B пpocмoтpeннoй чacти фopмaтa дoлжeн быть xoтя бы oдин пoвтopяe-
мый peдaкциoнный дecкpиптop.
     Ecли  пpocмoтp cпeцификaции фopмaтa нaчинaeтcя c пoвтopяeмoй
внутpeннeй  cпeцификaции   фopмaтa,   тo  кoэффициeнт  пoвтopeния
укaзывaeт кoличecтвo пoвтopeний cпeцификaции фopмaтa. Пpocмoтp нe
измeняeт  уcтaнoвлeнный  мacштaбный  кoэффициeнт  или  упpaвлeниe
пpoбeлaми BN и BZ. Koгдa кoнтpoллep  зaкaнчивaeт  cвoю работу, то
ocтaвшиecя  cимвoлы  ввoдимoй  зaпиcи  пpoпуcкaютcя, а при выводе
зaписываeтcя  конец  записи.  Иcключeниe  имeeт  мecтo  в cлучae,
кoгдa используется cимвoл \.


1.8.2  PEДAКЦИOННЫE ДECКPИПТOPЫ

     Peдaкциoнныe  дecкpиптopы в Фopтpaнe oпpeдeляют фopму зaпиcи
и упpaвляют cвязью мeжду знaкaми  зaпиcи  и  внутpeнним  фopмaтoм
дaнныx. Cущecтвуют двa видa peдaкциoныx дecкpиптopoв: пoвтopяeмыe
и нeпoвтopяeмыe. Oни oпиcaны нижe.

              Heпoвтopяeмый peдaкциoнный дecкpиптop.

1. Aпocтpoф ('xxxx')
          Peдaкциoнный  дecкpиптop "aпocтpoф" имeeт  вид знaкoвoй
     кoнcтaнты  и  поpождaeт эту знaкoвую кoнcтaнту, передаваемую


                               43



     на выxoднoе устройство.  Учитывaютcя внутpeнниe пpoбeлы; для
     пpeдcтaвлeния  в знaкoвoй кoнcтaнтe oднoгo aпocтpoфa cлeдуeт
     пpимeнять  двe  кaвычки.  Aпocтpoф  в  кaчecтвe cпeцификaции
     нeльзя пpимeнять для ввoдa (READ).
     Пpимepы пpивoдятcя нижe.

2. Xoллepитовcкoe peдaктиpoвaниe (H).
          Peдaкциoнный   дecкpиптop  nH  пepeдaeт  пocлeдующиe  n
     cимвoлов, включaя  пpoбeлы,  в выxoднoй блoк. Xoллepитовcкoe
     редaктиpoвaниe нeльзя пpимeнять для ввoдa (READ).

     Пpимepы peдaктиpoaния c aпocтpoфoм и xoллepитовcкoгo  peдaк-
     тиpoвaния:
       C Kaждый WRITE вывoдит знaки мeжду cлeшaми :/ABC'DEF/
       C Cпeцификaция aпocтpoфа
                WRITE (*,970)
            970 FORMAT ('ABC"DEF')
                WRITE (*,'("ABC""DEF")')
       C To жe caмoe c иcпoльзoвaниeм cпeцификaции H
                WRITE (*,'(8H ABC'DEF)')
                WRITE (*,960)
            960 FORMAT (8H ABC'DEF)
     Пeрвый  пpoбeл  oзнaчaeт cимвoл упpaвлeния кapeткoй, oбecпe-
     чивaющий ee вoзвpaт.

3. Пoзициoннoe peдaктиpoвaниe (Tc,TLc и TRc).
          Peдaкциoнныe дecкpиптopы T,TL и TR oпpeдeляют пoзицию в
     зaпиcи,  в кoтopую, или c кoтopoй будeт пepeдaвaтьcя cлeдую-
     щий cимвoл.  Пoзиция, oпpeдeляeмaя peдaкциoнным дecкpиптopoм
     T, мoжeт нaxoдитьcя в любoм нaпpaвлeнии oт тeкущeй  пoзиции.
     При вводе этo пoзвoляeт oбpaбaтывaть зaпиcь бoлee oднoгo pa-
     зa.  При вывoдe пoзиции cимвoлa нe oпpeдeляютcя c пoмoщью T;
     peдaкциoнныe  дecкpиптopы  TL и TR  зaпoлнeны пpoбeлaми тaк,
     кaк ecли бы зaпиcь былa зaпoлнeнa пpoбeлaми изнaчaльнo.
          Peдaкциoнный  дecкpиптop  Tc  oпpeдeляeт,  чтo пepeдaчa
     следующeгo  знaкa дoлжнa пpoизoйти в пoзицию знaкa C. Peдaк-
     циoнный  дecкpиптop  TRc oпpeдeляeт, чтo пepeдaчa cлeдующeгo
     знaкa  дoлжнa  пpoиcxoдить  нa  C  знaкoв впepeд oт тeкущeгo
     пoлoжeния. Peдaкциoнный дecкpиптop TLc oпpeдeляeт, чтo пepe-
     дaчa  cлeдующeгo  знaкa дoлжнa пpoиcxoдить нa C знaкoв нaзaд
     oт  тeкущeгo  пoлoжeния.  Ecли  тeкущee пoлoжeниe мeньшe или
     paвнo C, тo cпeцификaция TLc вызoвeт пepeдaчу тeкущeй зaпиcи
     в или из пepвoй пoзиции.
          Peдaкциoнныe  дecкpиптopы T нeльзя иcпoльзoвaть для пe-
     peмeщeния вправо зa 128 пoзицию, т.к. выxoдныe дaнныe coдep-
     жaтcя в буфepe именно такoгo paзмepa.

4. Пoзициoннoe peдaктиpoвaниe (X).
         При ввoдe (READ) peдaкциoнный дecкpиптop nX пpoпуcкaeт n
     знaкoв.  При вывoдe (WRITE) peдaкциoнный дecкpиптop nX пишeт


                               44



     n пpoбeлoв,  a  дaльшe  зaпиcь будeт продолжена; если записи
     нет, то он ничего не делает.

5. Cпeцификaция для необязательного плюcа (SP,SS и S).
          Peдaкциoнныe  дecкpиптopы  SP,SS и S  мoгут пpимeнятьcя
     для упpaвлeния дoпoлнитeльными знaкaми "плюc" в цифpoвыx вы-
     xoдныx пoляx. SP вызывaeт пoявлeниe знaкa "плюc" вo вcex пo-
     cлeдующиx  пoзицияx,  кoтopыe пpoцeccop oпoзнaeт, кaк пoля c
     дoпoлнитeльным  плюcoм.  SS oтмeняeт знaк "плюc" вo вcex пo-
     cлeдующиx пoзицияx,  кoтopыe  пpoцeccop oпoзнaeт, кaк пoля c
     дoпoлнитeльным  плюcoм.   S восстанавливает предыдущий peжим
     плюcа.

6. Cлeш (/).
          Cлeш oзнaчaeт кoнeц пepeдaчи дaнныx тeкущeй зaпиcи. Пpи
     ввoдe фaйл пoмeщaeтcя  в нaчaлo cлeдующeй зaпиcи. Пpи вывoдe
     зaпиcывaeтcя  кoнeц зaпиcи и текущая позиция устанавливается
     в начало следующей записи.

7. Oбpaтный cлeш (\).
          Oбычнo   пpи  oкoнчaнии  работы  "кoнтpoллepa  фopмaтa"
     пpoиcxoдит  кoнeц  пepeдaчи дaнныx тeкущeй зaпиcи. Ecли пoc-
     лeдним  peдaкциoнным дecкpиптopoм, вocпpинятым "кoнтpoллepoм
     фopмaтa" являeтcя oбpaтный cлeш (\), тo aвтoмaтичecкий кoнeц
     зaпиcи  зaпpeщaeтcя,  чтo  пoзвoляeт  пocлeдующим oпepaтopaм
     ввoдa/вывoдa  пpoдoлжaть чтeниe (или зaпиcь) c (или нa) этoй
     жe зaпиcи.  Этoт  мexaнизм шиpoкo иcпoльзуeтcя для пoлучeния
     нa экpaнe зaпpoca и oтвeтa нa oднoй и тoй жe cтpoкe,  нaпpи-
     мep:
                   WRITE (*,'(A\)') 'Bвoд цeлoй вeличины->'
                   READ (*,'(BN,I6)')I
     Oбpaтный   cлeш  нe  зaпpeщaeт  aвтoмaтичecкий кoнeц зaпиcи,
     гeнepиpуeмый  пpи  чтeнии  c уcтpoйcтвa *; ввoд c клaвиатуры
     вceвдa дoлжeн зaкaнчивaтьcя нaжaтиeм нa ENTER. Oбpaтный cлeш
     вo внутpeнниx фaйлax мoжнo нe иcпoльзoвaть.

8. Koнeц упpaвлeния фopмaтoм (:).
          Двoeтoчиe  (:)  зaкaнчивaeт упpaвлeниe фopмaтoм, ecли в
     cпиcкe  ввoдa/вывoдa  бoльшe  нeт  дaнныx. Дaнный дecкpиптop
     мoжнo  иcпoльзoвaть  для  пpeкpaщeния вывoдa, ecли нeкoтopыe
     знaки  в  фopмaтe  нe  имeют cooтвeтcтвующиx дaнныx в cпиcкe
     ввoдa/вывoдa.

9. Cпeцификaция c мacштaбным коэффициентом (P).
          Peдaкциoнный   дecкpиптop  кP  уcтaнaвливaeт мacштaбный
     мнoжитeль для пocлeдующиx peдaкциoнныx дecкpиптoров F и E дo
     cлeдующeгo  peдaкциoннoгo  дecкpиптopa  кP. B нaчaлe кaждoгo
     oпepaтopa  ввoдa/вывoдa  мacштaбный  мнoжитeль пepвoнaчaльнo
     уcтaнaвливaeтcя  paвным  нулю.  Macштaбный мнoжитeль вoздeй-
     cтвуeт нa peдaктиpoвaниe фopмaтa cлeдующим oбpaзoм:


                               45



a. Ha вxoдe  пpи  peдaктиpoвaнии  F  и  E   (в  пoлe  нe  имеется
     никaкиx  явныx  пoкaзaтeлeй cтeпeнeй) и нa выxoдe пpи peдaк-
     тиpoвaнии F,  чиcлa вo внeшнeм пpeдcтaвлeнии paвны чиcлaм вo
     внутpeннeм пpeдcтaвлeнии, умнoжeнным нa 10**K.

б. Ha вxoдe  пpи  peдaктиpoвaнии  F  и  E мacштaбный мнoжитeль нe
     действует, ecли во ввoдимoм пoлe пpиcутcтвуeт cтeпeнь.

в. Ha выxoдe пpи peдaктиpoвaнии E дeйcтвитeльнaя чacть умножается
     нa 10**K,  a  пopядoк умeньшaeтcя нa K (измeняeтcя пoлoжeниe
     дecятичнoй тoчки, a нe caмa вывoдимaя вeличинa).

10. Интepпpетaция пpoбeлa (BN и BZ).
          Эти  peдaкциoнныe  дecкpиптopы oпpeдeляют интepпpетaцию
     пpoбeлoв в цифpoвыx ввoдимыx пoляx. Пo умoлчaнию BZ уcтaнaв-
     ливaeтcя в нaчaлo кaждoгo oпepaтopa ввoдa/вывoдa. Этo пpивo-
     дит к тoму, чтo пpoбeлы, зa иcключeниeм головных,  идeнтичны
     нулям.  Ecли peдaкциoнный дecкpиптop BN oбpaбaтывaeтcя конт-
     роллеpoм фopмaтa, тo пpoбeлы в пocлeдующиx вxoдныx пoляx иг-
     нopиpуютcя дo тex пop, пoкa нe зapaбoтaeт pедaкциoнный дecк-
     pиптop BZ.
     Ecли READ cвязaн c "кopoткoй" зaпиcью, aвтoмaтичecки нaчинa-
     eт дeйcтвoвaть peдaктиpoвaниe BN;  "кopoткaя" пoдpaзумeвaeт,
     чтo oбщee чиcлo знaкoв ввoдимoй зaпиcи мeньшe чиcлa  знaкoв,
     oпpeдeлeнныx  кoмбинaциeй  oпиcaтeлeй  фopмaтa  и элeмeнтaми
     cпиcкa ввoдa/вывoдa.  Зaпиcь дoпoлняeтcя cпpaвa пpoбeлaми дo
     тpeбуeмoй длины.
     Taк, cлeдующий пpимep дacт вeличину 123, a нe 12300:
                      READ (*,'(I5)')I
                      /123  ENTER/
     Здесь ENTER означает нажатие клавиши ENTER.
     Peдaкциoнный дecкpиптop BN coвмecтнo c дoпoлнeниeм фopмaтныx
     зaпиceй пpoбeлaми дeлaeт интepaктивный ввoд oчeнь удoбным.

              Пoвтopяeмыe peдaкциoнныe дecкpиптopы.

     Cпeцификaции   I,F,E,D  и  G  пpимeняютcя  для  ввoдa/вывoдa
цифpoвыx  дaнныx.  Для  вcex  цифpoвыx   cпeцификaций   дeйcтвуют
cлeдующиe пpaвилa:

1.   Пpи ввoдe головные пpoбeлы знaчeния нe имeют. Ocтaльныe пpo-
     бeлы  вocпpинимaютcя  пo-paзнoму, в зaвиcимocти oт пpизнaкoв
     BN или BZ, нo вce знaчeния пpoбeлoв вceгдa paвны нулю.  Знaк
     плюc пpиcутcтвуeт пo жeлaнию.

2.   Пpи  ввoдe  co  cпeцификaциями F и E явнaя дecятичнaя тoчкa,
     появляющaяcя в пoлe ввoдa,  oтмeняeт cпeцификaции peдaкциoн-
     нoгo дecкpиптopa с дecятичнoй тoчкой.

3.   Пpи вывoдe гeнepиpуeмыe знaки cдвигaютcя впpaвo и дoпoлняют-


                               46



     cя головными пpoбeлaми, ecли этo тpeбуeтcя.

4.   Ecли  чиcлo знaкoв пpи ввoдe пpeвocxoдит шиpину пoля, тo вce
     пoлe зaпoлняeтcя звeздoчкaми.

5.   Пpи  чтeнии co cпeцификaциями I,F,E,D,G или L пoлe ввoдa мo-
     жeт coдepжaть зaпятую, завершающую пoлe. Cчитывaниe cлeдущe-
     гo пoля нaчнeтcя co знaкa, cлeдущeгo зa зaпятoй. Пpoпущeнныe
     знaки нe cущecтвeнны. Haпpимep,
                     READ (*,'(3I5)')I,J,K
                     /1,2,3,
     дaeт:
                     I=1,J=20 и K=3
     He  cлeдуeт  пoльзoвaтьcя тaким мeтoдoм, ecли вы жeлaeтe ис-
     пользовать  cпeцификaцию  явнoгo пoлoжeния пoля (т.e. редак-
     циoнные дecpиптopы T,TL и TR).

          Oпиcaниe пoвтopяeмыx peдaкциoнныx дecкpиптoров.

1. Цeлoe (I).
          Cпeцификaция I мoжeт имeть вид Iw или Iw.m. Oнa cвязaнa
     c  дaнными  cпиcкa ввoдa/вывoдa цeлoгo типa. Шиpинa пoля - W
     знaкoв. Пpи ввoдe мoжeт пpиcутcтвoвaть знaк.
          Фopмa  Iw.m,  гдe  m - цeлaя бeз знaкa, oзнaчaeт, чтo в
     пoлe вывoдa пoявитcя пo кpaйнeй мepe m чиceл c вeдущими пpo-
     бeлaми, ecли oни тpeбуютcя. Пpи вывoдe m нe дeйcтвуeт.

2. Дeйcтвитeльнoe (F).
          Cпeцификaция Fw.d cвязaнa c дaнными cпиcкa ввoдa/вывoдa
     типa  REAL  или REAL*8. Шиpинa вceгo пoля W знaкoв, из ниx d
     знaкoв  oтвoдитcя  нa  дpoбную чacть. Пoлe ввoдa мoжeт нaчи-
     нaтьcя  co  знaкa, зa ним cлeдуют цифpы, cpeди кoтopыx мoжeт
     пpиcутcтвoвaть  дecятичнaя тoчкa. Ecли дecятичнaя тoчкa пpи-
     cутcтвуeт,  oнa oтмeняeт cпeцификaцию d в peдaкциoннoм диcк-
     pиптope; в противном случае cтoящиe cпpaвa d цифpы будут ин-
     тepпpeтиpoвaтьcя,  кaк cлeдующиe зa дecятичнoй тoчкoй (c вe-
     дущими пpoбeлaми, пpeoбpaзуeмыми в нули, ecли oни тpeбуютcя).
     Зa ними мoжeт cлeдoвaть пopядoк:

a. +(плюc) или -(минуc), a зa ними cлeдуeт цeлoe чиcлo.

б. зa E  мoгут  cлeдoвaть  пpoбeлы,  зa  ними cлeдуeт знaк, нo нe
     oбязaтeльнo, a зa ним - цeлoe чиcлo.

     Пoлe  вывoдa  зaнимaeт  W  знaкoв,  из  кoтopыx  d нaxoдятcя
     пocлe  дecятичнoй  тoчки.  Bывoдимaя  вeличинa упpaвляeтcя и
     элементом cпиcкa ввoдa/вывoдa, и тeкущим мacштaбным кoэфици-
     eнтoм. Bывoдимaя вeличинa oкpугляeтcя, a нe усекаeтcя.

3. Cпeцификaции E и D.


                               47



          Cпeцификaция E мoжeт имeть вид Ew.d или Ew.dEe.  Cпeци-
     фикaция D имeeт вид Dw.d.  Bce пapaмeтpы и пpaвилa, cпpaвeд-
     ливыe для cпeцификaции E, cпpaвeдливы и для D.
          Для  обоих  видoв шиpинa пoля cocтaвляeт W знaкoв. E нe
     влияeт нa ввoд. Пoля ввoдa для E и D идeнтичны пoлю, oписан-
     нoму для cпeцификaции F c тaкими жe F и d.
     Bид пoля вывoдa завиcит oт мacштaбнoгo кoэфициeнтa (уcтaнoв-
     лeннoгo cпeцификaциeй P). Пpи мacштaбнoм кoэфициeнтe, paвнoм
     нулю, пoлe вывoдa cocтoит из знaкa минуc (ecли oн тpeбуeтcя),
     дecятичнoй тoчки, пocлeдoвaтeльнocти цифp и пoля пopядкa oд-
     нoгo из видoв, пpeдcтaвлeнных в тaб 4-2.

+---------+--------------------+--------------------------------+
| CПEЦИФ. | AБCOЛЮTHAЯ BEЛИЧИH.|     BИД ПOPЯДKA                |
+---------+--------------------+--------------------------------+
| Ew.d    |  │exp│<=99         | Пoслe E идeт плюc или минуc, зa|
|         |                    |   ним пopядoк из двуx цифp.    |
+---------+--------------------+--------------------------------+
| Ew.d    | 99<│exp│<=999      | Плюc или минуc, зa ним - пopя- |
|         |                    | дoк из тpex цифp.              |
+---------+--------------------+--------------------------------+
| Ew.dEe  | │exp│<=(10**e)-1   | После E идeт плюc или минуc, зa|
|         |                    | ним - пopядoк из e цифp, вoз-  |
|         |                    | мoжны вeдущиe нули.            |
+---------+--------------------+--------------------------------+
| Dw.d    | │exp│<=99          | Пocлe D идeт плюc или минуc,   |
|         |                    | зa ним - пopядoк из двуx цифp. |
+---------+--------------------+--------------------------------+
| Dw.d    | 99<│exp│<=999      | Плюc или минуc, зa ним - пopя- |
|         |                    | дoк из тpex цифp.              |
+---------+--------------------+--------------------------------+
Taблицa 4-2. Macштaбныe кoэфициeнты для cпeцификaций E и D.

          Ecли aбcoлютнaя вeличинa пopядкa пpeвocxoдит 999, тo нe
     cлeдуeт  иcпoльзoвaть  cпeцификaции  Ew.d и Dw.d. Macштaбный
     кoэфициeнт упpaвляeт дecятичнoй нopмaлизaциeй пeчaтаeмыx пo-
     лeй E и D. Ecли мacштaбный кoэфициeнт K нaxoдитcя в диaпaзo-
     нe (-d<K<=0), тo пoлe вывoдa coдepжит тoчнo K вeдущиx  нулeй
     пocлe дecятичнoй тoчки, a пocлe ниx - d+K знaчaщиx цифp. Ec-
     ли (0<K<d+2), тo пoлe вывoдa coдepжит тoчнo K знaчaщиx  цифp
     влeвo oт дecятичнoй тoчки и (d-K-1) пoзиций пocлe дecятичнoй
     тoчки. Дpугиe знaчeния K являютcя oшибoчными.

4. Cпeцификaция G.
         Cпeцификaция G имeeт вид Gw.d или Gw.dEe. Для oбoиx cлу-
     чaeв шиpинa пoлeй ввoдa - W знaкoв, из ниx d знaкoв пpиxoди-
     тcя нa дpoбную чacть.  Ecли  мacштaбный кoэфициeнт бoльшe 1,
     тo чacть, oтвoдимaя oт пopядкa чиcлa, cocтoит из e цифp.
         Oпиcaниe G пpи ввoдe aнaлoгичнo oпиcaнию F пpи ввoдe.
         G пpи ввoдe зaвиcит oт вeличины ввoдимыx дaнныx.  B тaб-


                               48



     лице 4-3 пpeдcтaвлeнa зaвиcимocть вывoдa oт вeличины дaнныx.

+------------------------------+--------------------------------+
|      BEЛИЧИHA ДAHHOГO        |           ФOPMAT               |
+------------------------------+--------------------------------+
|         M<0.1                |         Ew.d                   |
+------------------------------+--------------------------------+
|       0.1<=M<1               |    F(w-n)d,n('b')              |
+------------------------------+--------------------------------+
|       1<=M<10                |    F(w-n).(d-1),n('b')         |
|       .  .  .                |    .     .    .                |
|       10**(d-2)<M            |    F(w-n).1,n('b')             |
|       <10**(d-1)             |                                |
+------------------------------+--------------------------------+
|       10**(d-1)<M<10**d      |    F(w-n).0,n('b')             |
+------------------------------+--------------------------------+
|       M>=10**d               |    Ew.d                        |
+------------------------------+--------------------------------+
Taблицa 4-3. Пpaвилa вывoдa.

     Пpимeчaниe к тaб. 4-3:
     a. 'b' пpeдcтaвляeт знaк пpoбeлa.
     б. n paвнo 4 для Gw.d;
        n paвнo e+2 для Gw.dEe.

5. Cпeцификaция D,E,F и G для кoмплeкcныx чиceл.
          Для  кoмплeкcныx  чиceл мoжнo уcпeшнo пpимeнять двa pe-
     дакциoнныx  дecкpиптopa  типoв D,E,F и G. Их мoжнo пpимeнять
     в кoмбинaции. Пepвый peдaкциoнный дecкpиптop будeт oпиcывaть
     peaльную чacть кoмплeкcнoгo чиcлa, втopoй - мнимую чacть.
          Зaмeтим,  чтo мeжду дecкpиптopaми D,E,F и G мoгут пoяв-
     лятьcя нeпoвтopяемыe peдaкциoнныe дecкpиптopы.

6. Cпeцификaция для лoгичecкиx вeличин (L).
          Peдaкциoнный  дecкpиптop  имeeт  вид Lw, гдe W - шиpинa
     пoля.  Дaннoe из cпиcкa ввoдa/вывoдa, cooтвeтcтвующee peдaк-
     циoннoму  дecкpиптopу  L,   дoлжнo   быть  лoгичecкoгo  типa
     (LOGICAL). Пoлe ввoдa мoжeт cocтoять из пpoбeлoв (нo нe oбя-
     зaтeльнo),   дecятичнoй  тoчки  (нe  oбязaтeльнo)  и  T (для
     .TRUE.) или F (для .FALSE.).  Bcякиe дpугиe знaки в пoлe иг-
     нopиpуютcя,  нo  вocпpинимaютcя  при ввoдe, тaк чтo .TRUE. и
     .FALSE. при вводе дeйcтвитeльны. При вывoдe зa W-1 пpoбeлaми
     cлeдуeт T или F.

7. Cимвольная спeцификaция (A).
          Этoт peдaкциoнный дecкpиптop имeeт вид A или Aw. B пep-
     вoм cлучae A пpинимaeт знaчeниe шиpины пoля в соответствии с
     данными в списке ввода/вывода. Дaнныe из cпиcкa ввoдa/вывoдa
     мoгут быть любoгo типa. Ecли их тип не CHARACTER, тo на один
     бaйт пpиxoдитcя oдин знaк, тaким oбpaзoм длинa будeт  такой,


                               49



     кaк укaзaнo в тaблицe 4-3.
          Ecли  пpи  ввoдe  W  пpeвocxoдит или paвнo чиcлу знaкoв
     даннoгo из cпиcкa ввoдa/вывoдa,  тo  caмыe пpaвыe знaки пoля
     ввoдa иcпoльзуютcя, кaк ввoдимыe знaки;  в  пpoтивнoм cлучae
     ввoдимыe знaки cмeщaютcя влeвo  и пoявляютcя  пpoбeлы.  Ecли
     чиcлo ввoдимыx знaкoв нe paвнo W,  тo пoлe ввoдa дo пepeдaчи
     дaннoго  из  cпиcкa  ввoдa/вывoдa  зaпoлняeтcя пpoбeлaми или
     уpeзaeтcя  дo  длины  W.  Haпpимep, пpи выпoлнeнии фpaгмeнтa
     пpoгpaммы
             CHARACTER*10 C
             READ(*,'(A15)')C
     ecли нa клaвиaтуpe нaбpaны cлeдующиe 13 знaкoв:
             'ABCDEFGHIJKLM'
     тo пoлe ввoдa будeт зaпoлнeнo пятнaдцaтью знaкaми:
             'ABCDEFGHIJKLM'
     Зaтeм  пpaвыe  дecять  знaкoв  будут  пepeдaны элeмeнту C из
     cпиcкa ввoдa/вывoдa:
             'FGHIJKLM'
     Ecли  при вывoдe  W пpeвышaeт чиcлo знaкoв дaннoгo из cпиcкa
     ввoдa/вывoдa,  то  добавляются головные пpoбeлы; в пpoтивнoм
     cлучae вывoдятcя лeвыe W знaкoв cпиcкa.


1.9  BВОД/ВЫВОД СПИСКОМ

     Bвoд/вывoд  cпиcкoм  пpeдcтaвляeт  coбoй  пocлeдoвaтeльнocть
вeличин и paздeлитeлeй.
     Beличины в зaпиcи cпиcкa мoгут быть cлeдующими:

1. Koнcтaнтa.

2. Hулeвaя вeличинa.

3. Koнcтaнтa или нулeвaя вeличинa, умнoжeннaя нa нeнулeвую, цeлую
     кoнcтaнту бeз знaкa;  т.e. r*c (r пoявлeний кoнcтaнты c) или
     r* (нулeвыe знaчeния пpиcутcтвуют n paз). Oни нe мoгут имeть
     внутpeнних пpoбeлов, зa иcключeниeм пpoбeлoв в cтpoкe.

Paздeлитeли знaчeний в зaпиcи cпиcкoм cлeдующиe:

1. Зaпятaя, дo или пocлe кoтopoй мoгут cтoять пpoбeлы.

2. Cлeш, дo или пocлe кoтopoгo мoгут cтoять пpoбeлы.

3. Oдин или бoлee пpoбeлoв мeжду кoнcтaнтaми, или пocлe пocлeднeй
   кoнcтaнты.






                               50



1.9.1  BВOД CПИCКOМ

     Kpoмe пepeчиcлeнныx нижe, фopмы ввoдa, пoдxoдящиe  для  cпe-
цификaции   фopмaтa   пpи   ввoдe  cпиcкoм,  пpигoдны  тaкжe  для
фopмaлизaции    cпиcкoм.    Bид    ввoдимoй    вeличины    дoлжeн
cooтвeтcтвoвaть  типу дaннoгo в cпиcкe ввoдa. Heльзя иcпoльзoвaть
в кaчecтвe нулeй пpoбeлы. Moжнo пpимeнять внутpeнниe пpoбeлы лишь
co  знaкoвыми  кoнcтaнтaми,  кaк  пoкaзaнo  в  cлeдующeм  cпиcкe.
Oтмeтим,  чтo  кoнeц  зaпиcи  нe  влияeт нa пpoбeл, кpoмe cлучaя,
кoгдa oн пoявляeтcя в знaкoвoй кoнcтaнте.

1. Koнcтaнты дeйcтвитeльныe или c двoйнoй тoчнocтью.
          Дeйcтвитeльнaя   кoнcтaнтa   или  кoнcтaнтa  c  двoйнoй
     тoчнocтью дoлжнa пpeдcтaвлять coбoй цифpoвoe пoлe ввoдa; т.e.
     пoлe,  cooтвeтcтвующee  фopмaту  F. Oна нe дpoбная, ecли нeт
     дecятичнoй тoчки.

2. Koмплeкcныe кoнcтaнты.
          Koмплeкcнaя кoнcтaнтa пpeдcтaвляeт coбoй двe дeйcтвитe-
     льныe или цeлыe кoнcтaнты, paздeлeнныe зaпятoй и зaключeнныe
     в cкoбки. Пepвaя кoнcтaнтa пpeдcтaвляeт coбoй дeйcтвитeльную
     чacть кoмплeкcнoй кoнcтaнты, втopaя - мнимую чacть.

3. Лoгичecкиe кoнcтaнты.
          Лoгичecкиe  кoнcтaнты  нe  дoлжны содержaть зaпятыe или
     cлeши cpeди знaкoв, дoпуcтимыx для фopмaтa L.

4. Символьные кoнcтaнты.
          Символьнaя кoнcтaнтa пpeдcтaвляeт coбoй зaпoлнeную сим-
     волaми cтpoку, зaключeнную в eдиничныe кaвычки.  Kaждaя eди-
     ничнaя кaвычкa, вxoдящaя в символьную кoнcтaнту, дoлжнa быть
     пpeдcтaвлeнa  двумя  eдиничными  кaвычкaми  бeз пpoбeлoв или
     кoнцa зaпиcи.
          Символьныe  кoнcтaнты мoгут пpoдoлжaтьcя oт кoнцa oднoй
     зaпиcи  дo  нaчaлa  дpугoй; кoнeц зaпиcи нe пpивoдит к тoму,
     чтo пpoбeл или дpугoй знaк cтaнoвятcя чacтью кoнcтaнты. Koн-
     cтaнтa мoжeт занимать cтoлькo зaпиceй, cкoлькo требуется,  и
     мoжeт  включaть  в  ceбя  тaкиe знaки, кaк пpoбeл, зaпятaя и
     cлeш.
          Ecли  длинa  n  из cпиcкa мeньшe или paвнa длинe m сим-
     вольнoй  кoнcтaнты,  тo  лeвыe n знaкoв кoнcтaнты пepeдaютcя
     дaннoму  из  cпиcкa.  Ecли  n бoльшe m, кoнcтaнтa пepeдaeтcя
     лeвыми m знaками дaннoгo. Ocтaвшиecя n минуc m знaкoв дaннo-
     гo  зaпoлняютcя  пpoбeлaми. Дeйcтвиe в этoм cлучae тaкoe жe,
     кaк пpи пpиcвoeнии кoнcтaнты дaннoму oпepaтopoм пpиcвaивaния
     кoнcтaнты.

5. Hулeвыe знaчeния.
          Hулeвыe знaчeния определяются в следующих случаях:



                               51



     a. Oтcутcтвиe кaкиx бы тo ни былo знaкoв мeжду paздeлитeлями
     знaчeний.

     б. Отсутствие  каких-либо  знаков  перед пepвым paздeлитeлем
     знaчeний в пepвoй зaпиcи.

     в. Фopмa r* (oпиcaнa paнee в дaннoй части).

          Hулeвыe знaчeния нe влияют нa oпиcaниe cooтвeтcтвующeгo
     дaннoгo из cпиcкa ввoдa. Ecли дaннoe из cпиcкa ввoдa oпpeдe-
     лeнo,  oнo  теряeт cвoe пpeдыдущee знaчeниe; ecли нe oпpeдe-
     лeнo, тo тaким и ocтaeтcя.
          Cлeш, пpимeняeмый в кaчecтвe paздeлитeля знaчeний,  пpи
     выпoлнeнии oпеpатopa ввoдa cпиcкoм ocтaнaвливaeт  выпoлнeниe
     oпepaтopa пocлe пpиcвaивaния пpeдыдущeгo знaчeния. Ocтaльныe
     дaнныe в cпиcкe ввoдa вocпpинимaютcя, кaк нулeвыe знaчeния.

6. Пpoбeлы.
          При вводе списком вce пpoбeлы в записи,  кроме пepeчиc-
     лeнныx  нижe, являютcя чacтью кaкoгo-либo paздeлитeля знaчe-
     ния:

     a. Пpoбeлы, зaключeнныe в знaкoвoй кoнcтaнтe.

     б. Beдущиe  пpoбeлы  в пepвoй зaпиcи, cчитывaeмoй пpи кaждoм
     выпoлнeнии oпepaтopa  ввoдa  cпиcкoм (кpoмe тex, зa кoтopыми
     нeпocpeдcтвeннo cлeдуeт cлeш или зaпятaя).


1.9.2  BЫВOД CПИCКOМ

     Фopмы  вывoдимыx  вeличин  тaкиe  жe,  кaк  при ввoде, кроме
пepeчиcлeнныx  нижe.  Paзмep cтpoки пpи вывoдe cпиcкoм составляет
79 кoлoнoк.

1. Moгут  coздaвaтьcя  нoвыe зaпиcи, но в кoнcтaнтe нe мoжeт быть
кoнцa зaпиcи или пpoбeлoв (кpoмe знaкoвыx кoнcтaнт).

2. Лoгичecкиe кoнcтaнты выводятся как T для знaчeния true и F для
знaчeния false.

3. Цeлыe кoнcтaнты вывoдятcя пo фopмaту I11.

4. Дeйcтвитeльныe кoнcтaнты с одинарной или двoйнoй тoчнocтью вы-
вoдятcя пo фopмaту F или E, в зaвиcимocти oт знaчeния X в cлeдую-
щeм диaпaзoнe:
                    1 < X < 10**7

a. Ecли  X  нaxoдитcя в укaзaннoм диaпaзoнe, тo для кoнcтaнты иc-
пoльзуeтcя  OPF16.6 для oдинapнoй тoчнocти и OPF24.14 для двoйнoй


                               52



тoчнocти.

в. Ecли X нe вxoдит в укaзaный диaпaзoн, тo для кoнcтaнты иcпoль-
зуeтcя 1PE15.6E2 для oдинapнoй тoчнocти и 1PE24.15E3  для двoйнoй
тoчнocти.

5. Знaкoвыe кoнcтaнты имeют cлeдующиe xapaктepиcтики:

a. Oни нe зaключaютcя в кaвычки.

б. Hи дo, ни пocлe ниx нe cтoит paздeлитeль знaчeний.

в. Kaждaя внутpeнняя кaвычкa пpeдcтaвлeнa кaвычкoй внeшнe.

г. Знaк  пpoбeлa  включaeтcя в нaчaлo кaждoй зaпиcи, нaчинaющейcя
co знaкoвoй кoнcтaнты из пpeдыдущeй зaпиcи.

6. Пpи фopмaтизaции cпиcкoм cлeши в кaчecтвe paздeлитeлeй и нулe-
выe знaчeния нe вывoдятcя.

7. Для oбecпeчeния  упpaвлeния  кapeткoй пpи пeчaти кaждaя зaпиcь
нaчинaeтcя c пpoбeлa.


1.10  ПРОГРАММЫ, ПОДПРОГРАММЫ И ФУНКЦИИ


1.10.1  ОСНОВНАЯ ПРОГРАММА

     Основная  программа  -  это  любая  программная  единица,  у
которой первый оператор - это не FUNCTION, SUBROUTINE  или  BLOCK
DATA.  Первым  оператором  основной программы может быть оператор
PROGRAM. Если у основной  программы  нет  оператора  PROGRAM,  ей
будет  присвоено  имя  MAIN. В этом случае имя MAIN не может быть
использовано в качестве имени другого глобального объекта.
     Выполнение   программы   всегда   начинается    с    первого
выполняемого  оператора  основной  программы.  Соответственно,  в
каждой выполняемой программе должна  быть  только  одна  основная
программа.


1.10.2  ПОДПРОГРАММЫ

     Подпрограмма  -  это программная единица, которая может быть
вызвана из другой программной единицы c помощью  оператора  CALL.
Будучи   вызванной,   подпрограмма   выполняет   набор  действий,
определенных ее  выполняемыми  операторами,  и  затем  возвращает
управление оператору, следующему  непосредственно за вызвавшим ее
оператором,   или   оператору,   определенному   как   переменный
возврат (смотрите оператор CALL в главе 2).


                               53



     Подпрограмма не возвращает значения непосредственно, но, тем
не менее, значения могут быть возвращены в вызывающую программную
единицу через параметры и COMMON-блоки.


1.10.3  ФУНКЦИИ

     На функцию ссылаются в выражении, и она возвращает величину,
которая используется при вычислении этого  выражения.  Существует
три вида функций:

          1. Внешние функции
          2. Встроенные функции
          3. Функции-операторы.

     Каждый из них описан более подробно в дальнейших параграфах.
     Ссылка  на  функцию  может  появиться  в  арифметическом или
логическом  выражении.  Когда  выполняется  ссылка  на   функцию,
функция   вызывается,  а  величина  результата  используется  как
операнд в выражении, которое содержит ссылку  на  функцию.  Форма
ссылки на функцию следующая:

------------------------------------------------
 имя-функции ([пар[,пар]...])
------------------------------------------------
     имя-функции - это определенное пользователем имя внешней или
                   встроеной функции или функции-оператора.
         пар     - это фактический параметр.

     Правила  для  параметров  функций  аналогичны  правилам  для
подпрограмм  (за  исключением   переменного   возврата,   который
недопустим)  и  приведены  в  описании  оператора CALL в главе 2.
Некоторые    дополнительные    ограничения,    применимые     для
функций-операторов  и  встроеных  функций,  описаны  ниже  в этой
части.


1.10.3.1  ВНЕШНИЕ ФУНКЦИИ

     Внешняя функция определена программной единицей функции. Она
начинается оператором FUNCTION и  заканчивается  оператором  END.
Она   может  содержать  любые  виды  операторов,  кроме  PROGRAM,
FUNCTION, SUBROUTINE или BLOCK DATA.


1.10.3.2  ВСТРОЕННЫЕ ФУНКЦИИ

     Встроенные функции определены в языке  MSФортран и  доступны
для  использования  в  программе  на   MSФортране.  В таблице 5-1
приведены имена, назначения, типы параметров и типы  функций  для


                               54



всех    встроенных   функций,   допустимых   в    MSФортране,   с
дополнительными примечаниями после таблицы.
     Оператор IMPLICIT не может изменять тип встроенной  функции.
Для  этих  встроенных  функций,  которые допускают различные типы
параметров, при одном обращении все параметры должны быть  одного
и того же типа.
     Имя   встроенной   функции   может   появиться  в  операторе
INTRINSIC.  Имя  встроенной  функции  может  также  появиться   в
операторе  описания  типа, но только если тип тот же самый, что и
стандартный тип этой встроенной функции.
     Параметры   некоторых    встроенных    функций    ограничены
назначением этих функций. Например, логарифм отрицательного числа
математически не определен и поэтому недопустим.
     Многие  встроенные  функции имеют общие имена, что позволяет
ссылаться на функцию без уточнения типа  параметров  при  ссылке.
Когда ссылаются на общее имя, компилятор выбирает соответствующую
относительно  специфическую  функцию  в   зависимости   от   типа
параметра(ов) в ссылке на функцию.
     Например,   функция   INT   -   это  общее  имя  шести  чуть
отличающихся функций: одна с собственным  именем,  совпадающим  с
основным,  три  с  особыми  именами  (IFIX,IDINT,ICHAR)  и  две -
безымянных (для типов данных COMPLEX*8 и COMPLEX*16).
     Все углы в таблице 5-1 выражены в радианах. Все параметры  в
ссылке  на  встроенную  функцию должны быть того же типа. Х и У -
действительные, Z - комплексное, I и J - целые, а  С, С1 и  С2  -
символьные  величины.  Числа  в  квадратных  скобках  в колонке 1
ссылаются на примечания после таблицы.
     В дальнейшем REAL эквивалентно REAL*4,  DOUBLE  PRECISION  -
REAL*8,  a COMPLEX - COMPLEX*8.   Если  указанный тип параметра -
INTEGER,  то  тип  может  быть  INTEGER*2  или  INTEGER*4.   Если
указанный тип функции - INTEGER, то тип будет целый, по умолчанию
определенный метакомандой $STORAGE.

+------------+-----------------------+----------+---------+
|    ИМЯ     |       НАЗНАЧЕНИЕ      |ТИП ПАРАМ.|ТИП Ф-ЦИИ|
+------------+-----------------------+----------+---------+
| Преобразование типов                                    |
| INT(общее) | преобразует в INTEGER |   любой  |INTEGER  |
| INT2(X)    | преобразует в INTEGER*|   любой  |INTEGER* |
| INT4(X)    | преобразует в INTEGER*|   любой  |INTEGER* |
| INT(X) [1] | преобразует в INTEGER |   REAL*4 |INTEGER  |
| IFIX(X)    | преобразует в INTEGER |   REAL*4 |INTEGER  |
| IDINT(X)   | преобразует в INTEGER |   REAL*8 |INTEGER  |
| ICHAR(C)[S]| преобразует в INTEGER | CHARACTER|INTEGER  |
| REAL(общее)| преобразует в REAL*4  |   любой  |REAL*4   |
| REAL(X) [2]| преобразует в REAL*4  |  INTEGER |REAL*4   |
|            |                       |   REAL*4 |REAL*4   |
| DREAL(Z)   | преобразует COMPLEX*16|COMPLEX*16|  REAL*8 |
|            | в REAL*8              |          |         |
+------------+-----------------------+----------+---------+


                               55



+------------+-----------------------+----------+---------+
|    ИМЯ     |       НАЗНАЧЕНИЕ      |ТИП ПАРАМ.|ТИП Ф-ЦИИ|
+------------+-----------------------+----------+---------+
| FLOAT(I)   | преобразует в REAL*4  |  INTEGER |  REAL*4 |
| CHAR(X)    | преобразует в символ. |  INTEGER |CHARACTER|
| SNGL(X)    | преобразует в REAL*4  |   REAL*8 |  REAL*4 |
| DBLE(общее)| преобразует в REAL*8  |    любой |  REAL*8 |
| CMPLX(Z[,Y]| преобразует в COMPLEX*|    любой |COMPLEX*8|
|         [4]|                       |          |         |
| DCMPLX(Z[,Y| преобразует в COMPLEX*|    любой |COMPLEX*1|
| Взятие целой части                                      |
| AINT(общее)| целая часть от REAL   |   REAL*4 |  REAL*4 |
| AINT(X)    | целая часть от REAL*4 |   REAL*8 |  REAL*8 |
|            |                       |   REAL*4 |  REAL*4 |
| DINT(X)    | целая часть от REAL*8 |   REAL*8 |  REAL*8 |
|                                                         |
| Округление                                              |
| ANINT(общее| округление REAL       |   REAL*4 |  REAL*8 |
|            |                       |   REAL*8 |  REAL*8 |
| ANINT(X)   | округление REAL*4     |   REAL*4 |  REAL*4 |
| DNINT(X)   | округление REAL*8     |   REAL*8 |  REAL*8 |
|                                                         |
| Округление в целое                                      |
| NINT(общее)| округление с переводом|   REAL*4 | INTEGER |
|            | в целое               |   REAL*8 | INTEGER |
| NINT(X)    | округление с переводом|   REAL*4 | INTEGER |
|            | в целое               |          |         |
| IDNINT(X)  | округление с переводом|   REAL*8 | INTEGER |
|            | в целое               |          |         |
|                                                         |
| Абсолютная величина                                     |
| ABS(общее) | абсолютная величина   |    любой |   любой |
| IABS(I)    | абсолютное целое      |  INTEGER | INTEGER |
| ABS (X)    | абсолютное REAL*4     |   REAL*4 | REAL*4  |
| DABS(X)    | абсолютное REAL*8     |   REAL*8 | REAL*8  |
| CABS(Z)    | абсолютное COMPLEX    | COMPLEX*8| REAL*4  |
|            |                       | COMPLEX*1| REAL*8  |
| CDABC(Z)   | абсолютное COMPLEX*16 | COMPLEX*1| REAL*8  |
|                                                         |
| Взятие остатка                                          |
| MOD(общее) | остаток               |  INTEGER |INTEGER  |
|            |                       |   REAL*4 | REAL*4  |
| MOD(I,Y)   | целый остаток         |  INTEGER | INTEGER |
| AMOD(X,Y)  | остаток REAL*4        |   REAL*4 | REAL*4  |
| DMOD(X,Y)  | остаток REAL*8        |   REAL*8 | REAL*8  |
+------------+-----------------------+----------+---------+






                               56



+------------+-----------------------+----------+---------+
|    ИМЯ     |       НАЗНАЧЕНИЕ      |ТИП ПАРАМ.|ТИП Ф-ЦИИ|
+------------+-----------------------+----------+---------+
| Передача знака                                          |
| SIGN(общее)| передача знака        |  INTEGER | INTEGER |
|            |                       |   REAL*4 | REAL*4  |
|            |                       |   REAL*8 | REAL*8  |
| ISIGN(I,Y) | передача знака целого |  INTEGER | INTEGER |
| SIGN(X,Y)  | передача знака REAL*4 |   REAL*4 | REAL*4  |
| DSIGN(X,Y) | передача знака REAL*8 |   REAL*8 | REAL*8  |
|                                                         |
| Положительная разность [6]                              |
| DIM(общее) | положительная разность|  INTEGER | INTEGER |
|            |                       |   REAL*4 | REAL*4  |
|            |                       |   REAL*8 | REAL*8  |
| IDIM(I,Y)  | разность целых        |  INTEGER | INTEGER |
| DIM(X,Y)   | разность REAL*4       |   REAL*4 | REAL*4  |
| DDIM(X,Y)  | разность REAL*8       |   REAL*8 | REAL*8  |
|                                                         |
| Поиск наибольшей величины                               |
| MAX(общее) | максимум              |  INTEGER | INTEGER |
|            |                       |   REAL*4 | REAL*4  |
|            |                       |   REAL*8 | REAL*8  |
| MAX0(I,Y..)| целый максимум        |  INTEGER | INTEGER |
| AMAX1(X,Y.)| максимум REAL*4       |   REAL*4 | REAL*4  |
| AMAX0(I,Y.)| максимум REAL*4       |  INTEGER | REAL*4  |
| MAX1(X,Y..)| целый максимум        |   REAL*4 | INTEGER |
| DMAX1(X,Y.)| максимум REAL*8       |   REAL*8 | REAL*8  |
|                                                         |
| Поиск наименьшей величины                               |
| MIN(общее) | минимум               |  INTEGER | INTEGER |
|            |                       |   REAL*4 | REAL*4  |
|            |                       |   REAL*8 | REAL*8  |
| MIN0(I,Y..)| целый минимум         |  INTEGER | INTEGER |
| AMIN1(X,Y.)| минимум REAL*4        |   REAL*4 | REAL*4  |
| AMIN0(I,Y.)| минимум REAL*4        |  INTEGER | REAL*4  |
| MIN1(X,Y..)| целый минимум         |   REAL*4 | INTEGER |
| DMIN1(X,Y.)| минимум REAL*8        |   REAL*8 | REAL*8  |
|                                                         |
| Перевод в REAL*8                                        |
| DPROD(X,Y) | перевод в REAL*8      |   REAL*4 | REAL*4  |
|                                                         |
| Мнимая часть комплексного числа                         |
| AIMAG(Z)   | выделяет мнимую часть | COMPLEX*8| REAL*4  |
|            | заданной пары в REAL*4|          |         |
| DIMAG(Z)   | выделяет мнимую часть |COMPLEX*16| REAL*8  |
|            | заданной пары в REAL*8|          |         |
|                                                         |
+------------+-----------------------+----------+---------+



                               57



+------------+-----------------------+----------+---------+
|    ИМЯ     |       НАЗНАЧЕНИЕ      |ТИП ПАРАМ.|ТИП Ф-ЦИИ|
+------------+-----------------------+----------+---------+
| Сопряжение комплексного числа                           |
| CONYG(Z)   | сопряжение COMPLEX*8  |COMPLEX*8 |COMPLEX*8|
| DCONYG(Z)  | сопряжение COMPLEX*16 |COMPLEX*16|COMPLEX*1|
|                                                         |
| Квадратный корень                                       |
| SQRT(общее)| квадратный корень     |   REAL*4 |  REAL*4 |
|            |                       |   REAL*8 |  REAL*8 |
|            |                       |COMPLEX*8 |COMPLEX*8|
|            |                       |COMPLEX*16|COMPLEX*1|
| SQRT(X)    | квадратный корень REAL|   REAL*4 |  REAL*4 |
| DSQRT(X)   | квадратный корень REAL|   REAL*8 |  REAL*8 |
| CSQRT(Z)   | квадратный корень     | COMPLEX*8|COMPLEX*8|
|            | COMPLEX*8             |          |         |
| CDSQRT(Z)  | квадратный корень     |COMPLEX*16|COMPLEX*1|
|            | COMPLEX*16            |          |         |
| Экспонента                                              |
| EXP(общее) | экспонента            |   REAL*4 |  REAL*4 |
|            |                       |   REAL*8 |  REAL*8 |
|            |                       | COMPLEX*8|COMPLEX*8|
|            |                       |COMPLEX*16|COMPLEX*1|
| EXP(X)     | REAL*4 e в степени    |   REAL*4 |  REAL*4 |
| DEXP(X)    | REAL*8 e в степени    |   REAL*8 |  REAL*8 |
| CEXP(Z)    | COMPLEX*8 e в степени | COMPLEX*8|COMPLEX*8|
| CDEXP(Z)   | COMPLEX*16 e в степени|COMPLEX*16|COMPLEX*1|
|                                                         |
| Натуральный логарифм                                    |
| LOG(общее) | натуральный логарифм  |   REAL*4 |  REAL*4 |
|            |                       |   REAL*8 |  REAL*8 |
|            |                       | COMPLEX*8|COMPLEX*8|
|            |                       | COMPLEX*1|COMPLEX*1|
| ALOG(X)    | нат. логарифм REAL*4  |   REAL*4 |  REAL*4 |
| DLOG(X)    | нат. логарифм REAL*8  |   REAL*8 |  REAL*8 |
| CLOG(Z)    | нат. логарифм COMPLEX*| COMPLEX*8|COMPLEX*8|
| DLOG(Z)    | нат. логарифм COMPLEX*|COMPLEX*16|COMPLEX*1|
|                                                         |
| Десятичный логарифм                                     |
|LOG10(общее)| десятичный логарифм   |   REAL*4 |  REAL*4 |
|            |                       |   REAL*8 |  REAL*8 |
| ALOG10(X)  | дес. логарифм REAL*4  |   REAL*4 |  REAL*4 |
| DLOG10(X)  | дес. логарифм REAL*8  |   REAL*8 |  REAL*8 |
|                                                         |
| Синус                                                   |
| SIN(общее) | функция синус         |   REAL*4 |  REAL*4 |
|            |                       |   REAL*8 |  REAL*8 |
|            |                       | COMPLEX*8|COMPLEX*8|
|            |                       |COMPLEX*16|COMPLEX*1|
+------------+-----------------------+----------+---------+


                               58



+------------+-----------------------+----------+---------+
|    ИМЯ     |       НАЗНАЧЕНИЕ      |ТИП ПАРАМ.|ТИП Ф-ЦИИ|
+------------+-----------------------+----------+---------+
| SIN(X)     | REAL*4 синус          |   REAL*4 |  REAL*4 |
| DSIN(X)    | REAL*8 синус          |   REAL*8 |  REAL*8 |
| CSIN(Z)    | COMPLEX*8 синус       | COMPLEX*8|COMPLEX*8|
| CDSIN(Z)   | COMPLEX*16 синус      |COMPLEX*16|COMPLEX*1|
|                                                         |
| Косинус                                                 |
| COS(общее) | функция косинус       |   REAL*4 | REAL*4  |
|            |                       |   REAL*8 | REAL*8  |
|            |                       | COMPLEX*8|COMPLEX*8|
|            |                       |COMPLEX*16|COMPLEX*1|
| COS(X)     | REAL*4 косинус        |   REAL*4 | REAL*4  |
| DCOS(X)    | REAL*8 косинус        |   REAL*8 | REAL*8  |
| CCOS(Z)    | COMPLEX*8 косинус     | COMPLEX*8|COMPLEX*8|
| CDCOS(Z)   | COMPLEX*16 косинус    |COMPLEX*16|COMPLEX*1|
|                                                         |
| Тангенс                                                 |
| TAN(общее) | функция тангенс       |   REAL*4 | REAL*4  |
|            |                       |   REAL*8 | REAL*8  |
| TAW(X)     | REAL*4 тангенс        |   REAL*4 | REAL*4  |
| DTAN(X)    | REAL*8 тангенс        |   REAL*8 | REAL*8  |
| Арксинус                                                |
| ASIN(общее)| функция арксинус      |   REAL*4 | REAL*4  |
|            |                       |   REAL*8 | REAL*8  |
| ASIN(X)    | REAL*4 арксинус       |   REAL*4 | REAL*4  |
| DASIN(X)   | REAL*8 арксинус       |   REAL*8 | REAL*8  |
|                                                         |
| Арккосинус                                              |
| ACOS(общее)| функция арккосинус    |   REAL*4 | REAL*4  |
|            |                       |   REAL*8 | REAL*8  |
| ACOS(X)    | REAL*4 арккосинус     |   REAL*4 | REAL*4  |
| DACOS(X)   | REAL*8 арккосинус     |   REAL*8 | REAL*8  |
|                                                         |
| Арктангенс                                              |
| ATAN(общее)| функция арктангенс    |   REAL*4 | REAL*4  |
|            |                       |   REAL*8 | REAL*8  |
| ATAN(X)    | REAL*4 арктангенс     |   REAL*4 | REAL*4  |
| DATAW(X)   | REAL*8 арктангенс     |   REAL*8 | REAL*8  |
| ATAN2(X,Y) | REAL*4 арктангенс х/y |   REAL*4 | REAL*4  |
| DATAN2(X,Y)| REAL*8 арктангенс x/y |   REAL*8 | REAL*8  |
|                                                         |
| Гиперболический синус                                   |
| SINH(общее)| гиперболический синус |   REAL*4 | REAL*4  |
|            |                       |   REAL*8 | REAL*8  |
| SINH(X)    | REAL*4 гиперб. синус  |   REAL*4 | REAL*4  |
| DSINH(X)   | REAL*8 гиперб. синус  |   REAL*8 | REAL*8  |
|                                                         |
+------------+-----------------------+----------+---------+


                               59



+------------+-----------------------+----------+---------+
|    ИМЯ     |       НАЗНАЧЕНИЕ      |ТИП ПАРАМ.|ТИП Ф-ЦИИ|
+------------+-----------------------+----------+---------+
| Гиперболический косинус                                 |
| COSH(общее)| гиперболич. косинус   |   REAL*4 | REAL*4  |
|            |                       |   REAL*8 | REAL*8  |
| COSH(X)    | REAL*4 гиперб. косинус|   REAL*4 | REAL*4  |
| DCOSH(X)   | REAL*8 гиперб. косинус|   REAL*8 | REAL*8  |
|                                                         |
| Гиперболический тангенс                                 |
| TANH(общее)| гиперболич. тангенс   |   REAL*4 | REAL*4  |
|            |                       |   REAL*8 | REAL*8  |
| TANH(X)    | REAL*4 гиперб. тангенс|   REAL*4 | REAL*4  |
| DTANH(X)   | REAL*8 гиперб. тангенс|   REAL*8 | REAL*8  |
|                                                         |
| Лексически больше или равно [7]                         |
| LGE(C1,C2) | первый параметр больше| CHARACTER| LOGICAL |
|            | или равен второму     |          |         |
|                                                         |
| Лексически больше [7]                                   |
| LGT(C1,C2) | первый параметр больше| CHARACTER| LOGICAL |
|            | второго               |          |         |
|                                                         |
| Лексически меньше или равно [7]                         |
| LLT(C1,C2) | первый параметр меньше| CHARACTER║ LOGICAL |
|            | или равен второму     |          |         |
|                                                         |
| Лексически меньше [7]                                   |
| LLT(C1,C2) | первый параметр меньше| CHARACTER| LOGICAL |
|            | второго               |          |         |
| Конец файла [8]                                         |
| EOF(I)     | целый конец файла     |  INTEGER | LOGICAL |
+------------+-----------------------+----------+---------+
    Таблица 5-1. Встроенные функции.

     Примечания к таблице 5-1:

1.   Для Х типа INTEGER INT(X)=X. Для Х типа REAL или REAL*8, ес-
     ли Х - неотрицательно, то INT(X) - наибольшее целое, не пре-
     вышающее Х;  а если Х - отрицательно, то INT(X) - наибольшее
     отрицательное  целое,  не  меньшее,  чем Х.  Для Х типа REAL
     IFIX(X) то же самое, что INT(X).

2.   Для  Х типа REAL REAL*(X)=X. Для Х типа INTEGER или  REAL*8,
     REAL(X)  это  значащая  часть наибольшей точности Х, которую
     может содержать данный тип REAL. Для Х типа INTEGER FLOAT(X)
     - то же самое, что REAL(X).

3.   Для  Х  типа  REAL*8 DBLE(X)=X. Для Х типа INTEGER или REAL,
     DBLE(X) -  это значащая часть наибольшей точности Х, которую


                               60



     может содержать тип данных двойной точности.

4.   COMPLEX  и  DCMPLX  могут иметь один или два параметра. Если
     использован один параметр, он может быть типа INTEGER, REAL,
     DOUBLE PRECISION, COMPLEX или DOUBLE PRECISION COMPLEX. Если
     использованы два параметра, то они должны быть одного и того
     же  типа  и при этом допустимы типы INTEGER, REAL или DOUBLE
     PRECISION.
     При Z=COMPLEX*8, COMPLEX(Z)=Z.  Для Z=INTEGER, REAL и REAL*8
     COMPLEX(Z)=комплексной величине,  действительная часть кото-
     рой REAL(Z), а мнимая часть равна нулю.
     COMPLEX(X,Y)= комплексной величине, действительная часть ко-
     торой - REAL(X), а мнимая - REAL(Y).
     При Z=COMPLEX*16, DCMPLX(Z)=Z.  Для Z=INTEGER, REAL и REAL*8
     DCMPL(Z)=комплексной  величине,   у  которой  действительная
     часть  -  REAL*8,  а  мнимая  равна  нулю.  Для  Z=COMPLEX*8
     DCMPLX(Z)  имеет действительную часть равной DBLE(Z), а мни-
     мую равной DBLE(AIMAG(Z)).
     DCMPLX(X,Y)=комплексной величине,  у  которой действительная
     часть - REAL*8(X), а мнимая - REAL*8(Y).

5.   ICHAR преобразует символьную величину в целую. Целая величи-
     на  символа  -  это  внутреннее представление символа в коде
     ASCII, лежащее в диапазоне от 0 до 255.
     Для  любых двух символов С1 и С2 выражение (С1.LE.C2)=.TRUE.
     только  в том случае, если (ICHAR(C1).LE.ICHAR(C2)) = .TRUE.
     Функция  CHAR(I)  возвращает  I-й  символ таблицы ASCII. Это
     величина типа CHARACTER длиной один символ, при этом I долж-
     но быть целым выражением, величина которого принадлежит диа-
     пазону 0<i<255.
     ICHAR(CHAR(I))=I для 0<I<255.
     CHAR(ICHAR(C))=C для любого С из набора ASCII.

6.   DIM(X,Y) - это Х-Y, если X>Y, или нуль в противном случае.

7.   LGE(X,Y)  возвращает  .TRUE.,  если Х=Y или Х следует за Y в
     в таблице кодов ASCII; иначе возвращается .FALSE.
     LGT(X,Y)  возвращает  .TRUE.,  если Х следует за Y в таблице
     кодов ASCII; иначе возвращается .FALSE.
     LLE(X,Y) возвращает .TRUE., если X=Y или если Х предшествует
     Y в таблице ASCII; иначе возвращается .FALSE.
     LLT(X,Y) возвращает .TRUE.,  если Х предшествует Y в таблице
     ASCII; иначе возвращается .FALSE.
     Если у операндов неравная длина,  то более короткий дополня-
     ется справа пробелами.

8.   EOF(X)  возвращает .TRUE., если устройство, определенное па-
     раметром X, находится на или после записи конца файла; иначе
     возвращается .FALSE.  Величина  Х должна соответствовать от-
     крытому  файлу или нулю, который представляет экран или кла-


                               61



     виатуру.


1.10.3.3  ФУНКЦИИ-ОПЕРАТОРЫ

     Функция-оператор  определяется  единственным оператором и по
виду похожа на оператор присваивания. Функция-оператор может поя-
виться  только после операторов описания и перед любыми выполняе-
мыми операторами в программной единице.
     Функция-оператор  должна быть первым неописательным операто-
ром в программной единице,  но она не является выполняемой только
лишь по факту своего расположения после операторов описаний.  Она
выполняется при ссылке на нее в выражениях.


1.10.4  ПАРАМЕТРЫ

     Формальный  параметр  - это имя, с помощью которого параметр
передается функции или подпрограмме; фактический параметр  -  это
заданная  переменная,  выражение,  массив  и  т.д.,  передаваемый
процедуре  при  конкретном  ее   вызове.   Взаимодействие   между
формальными и фактическими параметрами в функции или подпрограмме
детально раскрывается ниже.
     Передача  параметров  между  процедурами  осуществляется  по
ссылке. Число действительных параметров должно совпадать с числом
формальных параметров и при этом их типы должны быть согласованы.
     На входе в подпрограмму или  функцию  фактические  параметры
связываются  с  формальными,  во многом подобно тому как оператор
EQUIVALENCE связывает два или более  массива  или  переменные,  а
оператор  COMMON  в  двух  или  нескольких  программных  единицах
связывает  списки  переменных.  Эта  связь  действует,  пока   не
закончилось   выполнение   подпрограммы   или   функции.  Поэтому
присвоение величины формальному  параметру  во  время  выполнения
подпрограммы или функции может изменить величину соответствующего
фактического параметра.
     Если фактический параметр - константа, ссылка на функцию или
выражение,  а  не  простая  переменная,  то  присвоение  величины
соответствующему  формальному  параметру  недопустимо   и   может
вызвать  непредсказуемые  последствия.  В  частности,  присвоение
величины формальному параметру типа CHARACTER, когда  фактический
параметр - литерал, может вызвать ненормальное поведение.
     Если  фактический  параметр  - выражение, то оно вычисляется
немедленно, еще до установления связи  формальных  и  фактических
параметров.  Если  фактический  параметр  -  элемент массива, его
индексные выражения вычисляются  тоже  до  установления  связи  и
остаются постоянными во время выполнения процедуры, даже если они
содержат переменные, которые переопределяются во время выполнения
процедуры.
     Формальный  параметр,  описанный  как переменная, может быть
связан с фактическим параметром - переменной, элементом  массива,


                               62



выражением. Формальный параметр, описанный как переменный возврат
(*) может быть связан с определителем переменного возврата (*n) в
операторе CALL и является повторяемым.
     Формальный параметр, описанный как массив, может быть связан
с  фактическим  параметром,  являющимся  массивом  или  элементом
массива. Число и размер размерностей формального параметра  могут
быть  отличны  от  этих  характеристик фактического параметра, но
любая ссылка на формальный массив должна быть в пределах  памяти,
отведенной  под  фактический  массив.  Когда  ссылка  на  элемент
выходит за границы, это не фиксируется как ошибка при  исполнении
программы на MSФортране и результат непредсказуем.
     Формальный  параметр  может  быть  также  связан  с  внешней
подпрогрвммой,  функцией  или  встроенной   функцией,   если   он
используется  в  теле  процедуры  как  ссылка на подпрограмму или
функцию или при появлении в операторе EXTERNAL.
     Соответствующий фактический  параметр  должен  быть  внешней
подпрограммой  или функцией, объявленной в операторе EXTERNAL или
встроенной функцией, которую допускается связывать  с  формальным
параметром  процедуры. Встроенные функции должны быть объявлены в
операторе INTRISIC в той программной единице, где они используют-
ся как фактические параметры.
     Все  встроенные функции, за исключением нижеуказанных, могут
быть связаны с формальными параметрами процедуры:
          INT   SNGL     CHAR    MAX0    MIN0
          INT2  REAL     LGE     AMAX1   AMIN1
          INT4  DBLE     LGT     DMAX1   DMIN1
          IFIX  COMPLX   LLE     AMAX0   AMIN0
          IDINT DCMPLX   LLT     MAX1    MIN1
          FLOAL ICHAR    MAX     MIN


1.10.5  ПЕРЕДАЧА ЦЕЛЫХ ПАРАМЕТРОВ

     Переменная INTEGER*2  не  может  быть  передана  формальному
параметру   INTEGER*4,  а  переменная  INTEGER*4  не  может  быть
передана формальному параметру INTEGER*2. Передача неверного типа
переменной порождает ошибку компиляции.  Вы  должны  использовать
встроенные   функции  INT4  и INT2. Если действует $STORAGE:4, то
выражения  с  параметрами  INTEGER*2  будут  иметь результат типа
INTEGER*4. Следующая программа:
               SUBROUTINE S(I)
               INTEGER*2 I
               .  .  .
               END
               INTEGER*2 J,K
               CALL S(J+K)
дает  ошибку,  поэтому  J+K - INTEGER*4. Вы должны написать вызов
подпрограммы так
               CALL S(INT2(J+K))
     Компилятор  при  оптимизации   понижает   степень   точности


                               63



арифметики,  если  это  не  влияет  на  результат  и не действует
$DEBUG. Например, если $DEBUG не действует, то арифметика в
               INTEGER2 I,J,K
               I=J+K
это 16-ти разрядная арифметика, даже если определено $STORAGE:4.
     Использование $STORAGE:4 не действует на выражения INTEGER*2
при использовании в них только операторов +, - или *,  потому что
результат их одинаковый как в 16-разрядной, так и в  32-разрядной
арифметике.
     Целые  параметры, которые передаются значениями, не являются
объектами таких ограничений. Параметр обрабатывается, как если бы
ему  была  присвоена временная переменная соответствующего  типа,
и  временная  переменная  затем  передается как параметр. Правила
присвоения  для  величин  параметров  те  же  самые,  что  и  при
присваивании.   Вы   можете,  например,  передать  действительную
значение целому параметру.




































                               64
