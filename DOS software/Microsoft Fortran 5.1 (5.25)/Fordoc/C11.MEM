







                               ГЛАВА 11

                   ПРОЦЕДУРЫ ГРАФИЧЕСКОЙ БИБЛИОТЕКИ

     В этой главе в  алфавитном  порядке  описаны  все  процедуры
графической   библиотеки   GRAPHICS.LIB  MSФортрана.   Библиотека
GRTEXTP.LIB содержит процедуры для работы под  управлением  OS/2.
В   некоторых   случаях   похожие   или   родственные   процедуры
группируются в одном описании с указанием разницы  там,  где  это
необходимо.

     Имя каждой процедуры указано в верхней  части  страницы.   В
разделе  "Интерфейс"  описан  полный  интерфейс,  необходимый для
использования процедуры, хотя удобнее  использовать  include-файл
FGRAPH.FD,  который содержит эти же описания, нежели воссоздавать
каждый раз этот же интерфейс.  В разделе "Описание" описано,  что
делает   процедура,   вместе   с  соответствующей  дополнительной
информацией.   В  разделе  "Возвращаемое  значение"  описаны  все
значения,  возвращаемые  процедурой.  Эти значения могут помочь в
тестировании  ошибок  перед  использованием  результатов   вызова
процедуры.    В   разделе   "См.также"  перечислены  похожие  или
родственные процедуры.  Наконец, в разделе "Пример" дается пример
использования  процедуры или указывается процедура с таким же или
похожим  примером.    (Для   некоторых   процедур   этот   раздел
отсутствует).



-----------------------------------------------------------------
arc,arc_w
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION arc (x1,y1,x2,y2,x3,y3,x4,y4)
      INTEGER*2 arc[FAR,C,ALIAS:"__arc"]
      INTEGER*2 x1,y1            ! верхний левый угол
                                 ! ограничивающего прямоугольника
      INTEGER*2 x2,y2            ! нижний правый угол
      INTEGER*2 x3,y3            ! начальный вектор
      INTEGER*2 x4,y4            ! конечный вектор
      END

      INTERFACE TO FUNCTION arc_w(wx1,wy1,wx2,wy2,wx3,wy3,wx4,wy4)
      INTEGER*2 arc_w[FAR,C,ALIAS:"__f_arc_w"]


                               313



      DOUBLE PRECISION wx1,wy1   ! верхний левый угол
                                 ! ограничивающего прямоугольника
      DOUBLE PRECISION wx2,wy2   ! нижний правый угол
      DOUBLE PRECISION wx3,wy3   ! начальный вектор
      DOUBLE PRECISION wx4,wy4   ! конечный вектор
      END

ОПИСАНИЕ

     Процедура arc рисует эллиптические дуги.

     Процедура   arc   использует   координатную   систему   окна
просмотра.    Центром   дуги   является   центр   ограничивающего
прямоугольника, определяемого точками (x1,y1)  и  (x2,y2).   Дуга
начинается  в  точке,  где  она  пересекает  вектор, определяемый
(x3,y3) и заканчивается  в  точке,  где  она  пересекает  вектор,
определяемый (x4,y4).

     Процедура  arc_w  использует   координатную   систему   окна
(window)  в  мировых  координатах.   Центром  дуги является центр
ограничивающего  прямоугольника,  определяемого   парой   мировых
координат  (wx1,wy1)  и  (wx2,wy2).  Дуга начинается в точке, где
она пересекает вектор, определяемый (wx3,wy3) и  заканчивается  в
точке, где она пересекает вектор, определяемый (wx4,wy4).

     В обоих случаях дуга рисуется текущим цветом против  часовой
стрелки.   Поскольку дуга не определяет замкнутую область, то она
не заполняется.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Процедуры arc и arc_w возвращают  ненулевое  значение,  если
они отработали успешно, и 0 в противном случае.

СМ.ТАКЖЕ

     ellipse,lineto,pie,rectangle,setcolor

ПРИМЕР

      INCLUDE 'FGRAPH.FI'
      INCLUDE 'FGRAPH.FD'
      INTEGER*2 dummy

      dummy = setvideomode( $MRES16COLOR )
      dummy = arc( 80, 50, 240, 150, 0, 50, 240, 150 )
      READ (*,*)          ! ждет нажатия ENTER
      dummy = setvideomode( $DEFAULTMODE )
      END



                               314



   Программа рисует дугу, показанную на рисунке R.1.

+---------------------------------------------------------------+
|      (x1,y1)                                                  |
|          +-----------------------------------+                |
|          |  *(x4,y4)                         |                |
|          |                                   |                |
|          |                                   |                |
|          |                                   |                |
|          |                 * Центр дуги      |                |
|          |                                   |                |
|          |                            (x3,y3)|                |
|          |                              *    |                |
|          |                                   |                |
|          +-----------------------------------+                |
|                                              (x2,y2)          |
|                                                               |
+---------------------------------------------------------------+
Рисунок R.1  Вывод программы arc

     См.также пример программы для setpixel.



-----------------------------------------------------------------
clearscreen
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO SUBROUTINE
     +          clearscreen[FAR,C,ALIAS:"__clearscreen"] (area)
      INTEGER*2 area     ! целевая область
      END

ОПИСАНИЕ

     Подпрограмма clearscreen очищает целевую  область,  заполняя
ее текущим цветом фона экрана.  Параметр area может быть одной из
следующих символических констант (определенных в FGRAPH.FD):

Константа       Действие
---------       --------
$GCLEARSCREEN   Очищает и заполняет весь экран.

$GVIEWPORT      Очищает и заполняет только текущее окно просмотра.

$GWINDOW        Очищает и заполняет только текущее текстовое окно.

     Эта подпрограмма доступна также в ОС/2.


                               315



ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращаемого значения нет.

СМ.ТАКЖЕ

     getbkcolor,setbkcolor

ПРИМЕР

     См. пример программы для gettextcolor и setvieworg.



-----------------------------------------------------------------
displaycursor
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION displaycursor (toggle)
      INTEGER*2 displaycursor[FAR,C,ALIAS:"__displaycursor"]
      INTEGER*2 toggle            ! состояние курсора
      END

ОПИСАНИЕ

     При входе в  любую  графическую  процедуру  экранный  курсор
выключается.   Функция  displaycursor определяет, будет ли курсор
включаться вновь при выходе из графических процедур в  программу.
Если  toggle  равен $GCURSORON, то курсор будет восстанавливаться
при выходе, а если toggle  равен  $GCURSOROFF,  то  курсор  будет
оставаться выключенным.

     Эта функция доступна также в OS/2.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращает предыдущее значение toggle.

СМ.ТАКЖЕ

     gettextcursor,settextcursor

ПРИМЕР

     См.пример программы для settextcursor.





                               316



-----------------------------------------------------------------
ellipse,ellipse_w
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION ellipse (control,x1,y1,x2,y2)
      INTEGER*2 ellipse[FAR,C,ALIAS:"__ellipse"]
      INTEGER*2 control        ! флаг заполнения
      INTEGER*2 x1,y1          ! верхний левый угол
                               ! ограничивающего прямоугольника
      INTEGER*2 x2,y2          ! нижний правый угол
      END

      INTERFACE TO FUNCTION ellipse_w(control,wx1,wy1,wx2,wy2)
      INTEGER*2 ellipse_w[FAR,C,ALIAS:"__f_ellipse_w"]
      INTEGER*2 control        ! флаг заполнения
      DOUBLE PRECISION wx1,wy1 ! верхний левый угол
                               ! ограничивающего прямоугольника
      DOUBLE PRECISION wx2,wy2 ! нижний правый угол
      END

ОПИСАНИЕ

     Функции ellipse рисуют  эллипс.   Граница  рисуется  текущим
цветом.   Для  функции  ellipse  центром  эллипса  является центр
ограничивающего прямоугольника, определяемого точками  (x1,y1)  и
(x2,y2) в координатах окна просмотра.

     Для  функции  ellipse_w  центром  эллипса   является   центр
ограничивающего прямоугольника, определяемого точками (wx1,wy1) и
(wx2,wy2) в окне мировых координат.

     Если ограничивающий прямоугольник вырождается  в  точку  или
вертикальную или горизонтальную линию, то ничего не рисуется.

     Аргумент control может быть одной из следующих символических
констант:

Константа         Действие
---------         --------
$GFILLINTERIOR    Заполняет эллипс текущей маской заполнения.

$GBORDER          Не заполняет эллипс.

     Вызов этих функций с аргументом $GFILLINTERIOR  эквивалентен
последующему вызову функции floodfill с заданием центра эллипса в
качестве начальной точки и текущим цветом (установленным функцией
setcolor) в качестве цвета границы.



                               317



ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Функции ellipse и ellipse_w возвращают  ненулевое  значение,
если эллипс нарисован успешно, и 0 в противном случае.

СМ.ТАКЖЕ

     arc,floodfill,lineto,pie,rectangle,setcolor,setfillmask

ПРИМЕР

      INCLUDE 'FGRAPH.FI'
      INCLUDE 'FGRAPH.FD'
      INTEGER*2 dummy

      dummy = setvideomode( $MRES16COLOR )
      dummy = ellipse( $GFILLINTERIOR, 80, 50, 240, 150 )
      READ (*,*)          ! ждет нажатия ENTER
      dummy = setvideomode( $DEFAULTMODE )
      END

   Эта программа рисует форму, показанную на рисунке R.2.

+---------------------------------------------------------------+
|                                                               |
|      (x1,y1)                                                  |
|          +-----------------------------------+                |
|          |                                   |                |
|          |                                   |                |
|          |                                   |                |
|          |                                   |                |
|          |                                   |                |
|          |                                   |                |
|          |                                   |                |
|          |                                   |                |
|          |                                   |                |
|          +-----------------------------------+                |
|                                              (x2,y2)          |
|                                                               |
|                                                               |
+---------------------------------------------------------------+
Рисунок R.2  Вывод программы ellipse

     См.также пример программы для setpixel и setvieworg.








                               318



-----------------------------------------------------------------
floodfill,floodfill_w
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION floodfill (x,y,boundary)
      INTEGER*2 floodfill[FAR,C,ALIAS:"__floodfill"]
      INTEGER*2 x,y            ! начальная точка
      INTEGER*2 boundary       ! цвет границы заполнения
      END

      INTERFACE TO FUNCTION floodfill_w(wx1,wy1,boundary)
      INTEGER*2 floodfill_w[FAR,C,ALIAS:"__f_floodfill_w"]
      DOUBLE PRECISION wx1,wy1 ! начальная точка
      INTEGER*2 boundary       ! цвет границы заполнения
      END

ОПИСАНИЕ

     Эти функции заполняют  область,  используя  текущий  цвет  и
маску заполнения.

     Функция  floodfill  начинает  заполнение  с  точки  (x,y)  в
координатах окна просмотра.

     Функция floodfill_w начинает заполнение с точки (wx,wy) окна
мировых координат.

     Если точка лежит внутри фигуры, то заполняется  внутренность
фигуры, а если точка лежит вне фигуры, то заполняется фон экрана.
Точка должна лежать внутри или вне заполняемой фигуры, но  не  на
границе самой фигуры.  Заполнение происходит во всех направлениях
и заканчивается при соприкосновении с цветом границы.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Функции  floodfill  и   floodfill_w   возвращают   ненулевое
значение, если заполнение выполнено успешно.  Нуль возвращается в
случаях, если заполнение не может быть завершено, если  начальная
точка лежит на цвете границы или вне области отсечения.

СМ.ТАКЖЕ

     ellipse,getcolor,getfillmask,pie,setcliprgn,setcolor,
     setfillmask

ПРИМЕР

     См.пример программы для setlinestyle.


                               319




-----------------------------------------------------------------
getactivepage
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION getactivepage ()
      INTEGER*2 getactivepage[FAR,C,ALIAS:"__getactivepage"]
      END

ОПИСАНИЕ

     Функция  getactivepage  возвращает  номер  текущей  активной
страницы.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращает   номер   текущей   активной   страницы.    Любая
аппаратная  конфигурация  поддерживает,  по  крайней  мере,  одну
страницу (номер страницы 0).

     Эта функция поддерживается также в OS/2.

СМ.ТАКЖЕ

     getactivepage,gettextcolor,gettextposition,getvisualpage,
     outtext,settextcolor,settextposition,settextwindow,
     setvideomode,setvisualpage,wrapon

ПРИМЕР

CC  PAGE.FOR - иллюстрирует эффект оживления с помощью смены
CC             видеостраниц. Продемонстрированы следующие
CC             функции для работы с видеостраницами:
CC             getactivepage, getvisualpage, setactivepage,
CC             setvisualpage

      INCLUDE  'FGRAPH.FI'
      INCLUDE  'FGRAPH.FD'

      INTEGER*2        dummy, oldapage, oldvpage
      INTEGER*2        page, row, col, line, count
      CHARACTER*3      jumper(4,3)
      RECORD /rccoord/ curpos
      RECORD / videoconfig / vc

      DATA jumper / '\o/', '_o_', ' o ', ' o ',
     +              ' O ', ' O ', '/O\', ' O ',
     +              '/ \', '( )', '/ \', '( )' /


                               320



      CALL getvideoconfig( vc )
      IF( vc.numvideopages .LE. 4 )
     +    STOP 'Error:  not enough pages'
      oldapage  = getactivepage()
      oldvpage  = getvisualpage()
      IF( setvideomode( $TEXTBW40 ) .EQ. 0 )
     +    STOP 'Error:  cannot set 40-column mode'
      dummy     = displaycursor( $GCURSOROFF )

C
C     Рисует 24 образа на каждой странице.
C
      DO page = 1, 4
         dummy = setactivepage( page - 1 )
         DO row = 1, 22, 7
            DO col = 1, 36, 7
               DO line = 0, 2
                  CALL settextposition( row + line, col, curpos )
                  CALL outtext( jumper(page, line + 1) )
               END DO
            END DO
         END DO
      END DO

C
C     10-кратный цикл по страницам 0-3.
C
      DO count = 1, 10
         DO page = 0, 3
            dummy = setvisualpage( page )
            CALL delay( INT2( 10 ) )
         END DO
      END DO

C
C     Восстанавливаем исходную страницу.
C
      dummy = setvideomode( $DEFAULTMODE )
      dummy = setactivepage( oldapage )
      dummy = setvisualpage( oldvpage )
      END


CC  DELAY - Пауза на заданное число 1/100 секунды.
CC
CC  Params:  wait - время паузы в 0.01 секунды.

      SUBROUTINE delay( wait )
      INTEGER*2 wait, tick0, tick1, tick, kount, dummy



                               321



      kount = 0
      CALL GETTIM( dummy, dummy, dummy, tick0 )
      DO WHILE( kount .LT. wait )
         CALL GETTIM( dummy, dummy, dummy, tick1 )
         tick = tick1 - tick0
         IF( tick .LT. 0 ) tick = tick + 100
         tick0 = tick1
         kount = kount + tick
      END DO
      RETURN
      END

     Программа рисует на экране "живые" фигуры.



-----------------------------------------------------------------
getbkcolor
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION getbkcolor ()
      INTEGER*4 getbkcolor[FAR,C,ALIAS:"__getbkcolor"]
      END

ОПИСАНИЕ

     Функция getbkcolor возвращает значение текущего цвета  фона.
Умолчанием является 0.

     В цветном текстовом режиме (таком как  $TEXTC80)  setbkcolor
принимает  (а  getbkcolor  возвращает)  индекс  цвета.  Например,
setbkcolor(2) устанавливает цвет фона равным пиксельному значению
2.   Действительный  цвет  зависит  от  отображения  палитры  для
индекса цвета 2.  В цветном текстовом режиме умолчанием  является
зеленый цвет.

     В  цветном  графическом  режиме  (таком   как   $ERESCOLOR),
setbkcolor  принимает  (а  getbkcolor  возвращает) значение цвета
(какое используется в remappalette).   Значение  для  цвета  фона
задается     символическими    константами,    определенными    в
include-файле   FGRAPH.FD.    Например,   setbkcolor($GREEN)    в
графическом   режиме   устанавливает   зеленый  звет  фона.   Эти
символические константы поставляются для удобства в определении и
манипулировании      наиболее      употребительными      цветами.
Действительный диапазон цветов, в целом, значительно больше.

     Функция setcolor принимает  в  качестве  аргумента  значение
INTEGER*2, которое является индексом цвета.


                               322



     Если  аргумент  имеет  тип  INTEGER*4,  то  он  относится  к
значению  цвета,  а  если  он  имеет  тип INTEGER*2, то к индексу
цвета.   Двумя  исключениями  являются   функции   setbkcolor   и
getbkcolor,  описанные выше.  Более полное обсуждение цветов дано
на справочной странице для функции remappalette.

     Эта функция поддерживается также в OS/2.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращает текущее значение цвета фона.

СМ.ТАКЖЕ

     remappalette,setbkcolor

ПРИМЕР

     См.пример программы для gettextcolor.



-----------------------------------------------------------------
getcolor
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION getcolor ()
      INTEGER*2 getcolor[FAR,C,ALIAS:"__getcolor"]
      END

ОПИСАНИЕ

     Функция   getcolor   возвращает   текущий   индекс    цвета.
Умолчанием является наивысшее доступное значение текущей палитры.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращает текущий индекс цвета.

СМ.ТАКЖЕ

     setcolor

ПРИМЕР

      PROGRAM colors

      INCLUDE 'FGRAPH.FI'


                               323



      INCLUDE 'FGRAPH.FD'

      INTEGER*2 loop, loop1, dummy2
      REAL rnd1, rnd2

      dummy2 = setvideomode( $MRES16COLOR )
      DO loop1 = 1, 20
         dummy2 = setcolor
     +            ( MOD( getcolor()+1, 16 ) ) !
         DO loop = 1, 3200
C
C           Устанавливаем случайный пиксел, нормализованный
C           так, чтобы он попал на экран
C
            CALL RANDOM( rnd1 )
            CALL RANDOM( rnd2 )
            dummy2 = setpixel( INT2( rnd1*320 ),
     +                         INT2( rnd2*200 ) )
         END DO
      END DO

      dummy2 = setvideomode( $DEFAULTMODE )
      END

     Эта  программ  присваивает   различные   цвета   произвольно
выбранным пикселам.



-----------------------------------------------------------------
getcurrentposition,getcurrentposition_w
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO SUBROUTINE
     +getcurrentposition[FAR,C,ALIAS:"__f_getcurrentposition"](s)
      STRUCTURE/xycoord/
        INTEGER*2 xcoord               ! координата x
        INTEGER*2 ycoord               ! координата y
      END STRUCTURE
      RECORD/xycoord/s[FAR,REFERENCE]  ! возвращает с текущей
      END                              ! позицией

      INTERFACE TO SUBROUTINE
     +getcurrentposition_w[FAR,C,ALIAS:"__f_getcurpos_w"](s)
      STRUCTURE/wxycoord/
        DOUBLE PRECISION wx            ! координата x окна
        DOUBLE PRECISION wy            ! координата y окна
      END STRUCTURE


                               324



      RECORD/wxycoord/s[FAR,REFERENCE] ! возвращает с текущей
      END                              ! позицией

ОПИСАНИЕ

     Функции getcurrentposition возвращают в s координаты текущей
позиции    графического   вывода.    Функция   getcurrentposition
возвращает  позицию  как  структуру   xycoord,   определенную   в
FGRAPH.FD.   Функция  getcurrentposition_w возвращает позицию как
структуру wxycoord, определенную в FGRAPH.FD.

     Текущая позиция может быть изменена функциями arc, lineto  и
moveto.

     В  текущей  позиции  начинается  только  графический  вывод:
текстовый вывод начинается с текущей позиции текста, что является
независимым понятием (см. settextposition).

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращаемого значения нет.

СМ.ТАКЖЕ

     moveto

ПРИМЕР

      PROGRAM Movept

      INCLUDE 'FGRAPH.FI'
      INCLUDE 'FGRAPH.FD'

      RECORD/xycoord/ position

      CHARACTER*255 buffer
      INTEGER*2 dummy2
      REAL rnd1, rnd2

      dummy2 = setvideomode( $MRES16COLOR )
      CALL RANDOM( rnd1 )
      CALL RANDOM( rnd2 )
      CALL moveto( INT2( rnd1*160*80 ),
     + INT2( rnd2*100+50 ), position )
      CALL getcurrentposition( position )
      WRITE( buffer,"( ' x=',I3,', y<',I3,\ )" ) position.xcoord,
     +                                           position.ycoord
      CALL settextposition( position.xcoord/8, position.ycoord/8,
     +                      position )
      CALL outtext( buffer( 1:LEN_TRIM(buffer ) ) )


                               325



      READ(*, *)      ! ждет нажатия ENTER
      dummy2 = setvideomode( $DEFAULTMODE )
      END

     Эта программа перемещает текущую позицию графического вывода
в  произвольную  точку, затем для получения ее координат вызывает
getcurrentposition, после чего записывает координаты в буфер.  По
этим координатам программа устанавливает текущую позицию текста и
выводит координаты на экран с этой позиции.



-----------------------------------------------------------------
getfillmask
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO SUBROUTINE
     +getfillmask[FAR,C,ALIAS:"__getfillmask"] (mask)
      INTEGER*1 mask[FAR,REFERENCE](8)
      END

ОПИСАНИЕ

     Некоторые графические функции  (floodfill,  pie,  ellipse  и
rectangle)  могут  заполнять  часть экрана или весь экран текущим
цветом  или  цветом  фона.   Заполнение  может   контролироваться
текущей маской заполнения.

     Подпрограмма   getfillmask    возвращает    текущую    маску
заполнения.   Маска  это  массив  8x8  бит,  в котором каждый бит
представляет  один  пиксел.   Бит,   содержащий   1,   окрашивает
соответствующий пиксел текущим цветом, а бит с 0 оставляет пиксел
без изменения.  Маска повторяется  по  всей  области  заполнения.
Если  маска заполнения не определена, или содержит все нули, то в
операциях заполнения  используется  только  текущий  цвет.   Если
маска не присутствует, то подпрограмма обнуляет весь массив mask.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращаемого значения нет.

СМ.ТАКЖЕ

     floodfill,ellipse,pie,rectangle,setfillmask

ПРИМЕР

      PROGRAM Fill


                               326



      INCLUDE 'FGRAPH.FI'
      INCLUDE 'FGRAPH.FD'

      INTEGER*1 style( 8,6 )/ #78,#30,#30,#78,#30,#30,#78,#30,
     +                        #78,#32,#30,#78,#30,#38,#78,#32,
     +                        #78,#39,#38,#78,#63,#36,#78,#33,
     +                        #78,#65,#36,#78,#33,#38,#78,#62,
     +                        #78,#66,#63,#78,#65,#65,#78,#37,
     +                        #78,#66,#65,#78,#66,#65,#78,#66 /

      INTEGER*2 oldstyle( 8 ) ! буфер для старого стиля
      INTEGER loop

      dummy2 = setvideomode( $MRES4COLOR )
      CALL getfillmask( oldstyle )
C
C     Рисует эллипс под несколькими прямоугольниками
C     в различном цвете.
C
      dummy2 = setcolor( 2 )
      dummy2 = ellipse( $GFILLINTERIOR, 120, 75, 200, 125 )
      dummy2 = setcolor( 3 )
      DO loop = 1,6
C
C     Создает шесть прямоугольников
C
      CALL setfillmask( style( 1,loop ) )
      dummy2 = rectangle( $GFILLINTERIOR, loop*40+5, 90,
     +                  ( loop+1 )*40, 110 )
      END DO

      CALL setfillmask( oldstyle ) ! восстанавливает старый стиль
      READ (*,*)                   ! ждет нажатия ENTER
      dummy2 = setvideomode( $DEFAULTMODE )
      END

     Эта    программа    рисует    эллипс,    покрытый     шестью
прямоугольниками, каждый с различной маской заполнения.



-----------------------------------------------------------------
getfontinfo
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION getfontinfo(font)
      INTEGER*2 getfontinfo[FAR,C,ALIAS:"__f_getfontinfo"]
      STRUCTURE/fontinfo/


                               327



        INTEGER*2 type        ! b0 set = vector,clear = bit map
        INTEGER*2 ascent      ! pix dist from top to baseline
        INTEGER*2 pixwidth    ! character width in pixels, 0=prop
        INTEGER*2 pixheight   ! character height in pixels
        INTEGER*2 avgwidth    ! average character width in pixels
        CHARACTER*81 filename ! file name including path
        CHARACTER*32 facename ! font name
      END STRUCTURE
      RECORD/fontinfo/font[FAR,REFERENCE]
      END

ОПИСАНИЕ

     Функция getinfo устанавливает характеристики текущего шрифта
в структуре fontinfo, определенной в файле FGRAPH.FD.

     Структура fontinfo содержит следующие элементы:

Элемент      Содержание
-------      ----------
type         Определяет шрифт с векторным (1) или битовым (0)
             отображением.

ascent       Определяет расстояние в пикселах от верха до
             базовой линии (baseline).

pixwidth     Определяет ширину символа в пикселах;
             0 обозначает пропорциональный шрифт.

pixheight    Определяет высоту символа в пикселах.

avgwidth     Определяет среднюю ширину символа в пикселах.

filename     Определяет имя файла, содержащего путь.

facename     Определяет имя шрифта.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращает нуль, если font возвращен успешно.

СМ.ТАКЖЕ

     getgtextextent,outgtext,registerfonts,setfont,
     unregisterfonts







                               328



-----------------------------------------------------------------
getgtextextent
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION getgtextextent(text)
      INTEGER*2 getgtextextent[FAR,C,ALIAS:"__f_getgtextextent"]
      CHARACTER*(*) text[FAR,REFERENCE]
      END

ОПИСАНИЕ

     Функция getgtextextent возвращает ширину в пикселах, которая
может понадобиться для печати строки text, с хвостовыми пробелами
включительно, с помощью outgtext и текущим шрифтом.

     Эта функция особенно полезна для определения размера текста,
который использует шрифты с пропорциональными интервалами.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращает ширину строки текста в пикселах.

СМ.ТАКЖЕ

     getfontinfo,outgtext,registerfonts,setfont,unregisterfonts

ПРИМЕР

     См.пример программы для registerfonts.



-----------------------------------------------------------------
getimage,getimage_w
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO SUBROUTINE
     +getimage[FAR,C,ALIAS:"__getimage"](x1,y1,x2,y2,image)
      INTEGER*2 x1,y1,x2,y2
      INTEGER*1 image[FAR,REFERENCE](*)
      END

      INTERFACE TO SUBROUTINE
     +getimage_w[FAR,C,ALIAS:"__f_getimage_w"]
     +(wx1,wy1,wx2,wy2,image)
      DOUBLE PRECISION wx1,wy1,wx2,wy2


                               329



      INTEGER*1 image[FAR,REFERENCE](*)
      END

ОПИСАНИЕ

     Процедуры  getimage  запоминают   изображение   на   экране,
ограниченное  заданным  прямоугольником,  в  буфере,  на  который
указывает image.

     Подпрограмма     getimage     определяет      ограничивающий
прямоугольник  точками  (x1,y1)  и  (x2,y2)  в  координатах  окна
просмотра.

     Подпрограмма    getimage_w     определяет     ограничивающий
прямоугольник   точками   (wx1,wy1)   и  (wx2,wy2)  окна  мировых
координат.

     Буфер должен быть достаточно большим, чтобы вместить  образ.
Его    размер    определяется   во   время   выполнения   вызовом
соответствующей функции imagesize или с  использованием  формулы,
описанной на справочной странице для imagesize.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращаемого значения нет.

СМ.ТАКЖЕ

     imagesize,putimage

ПРИМЕР

     См.пример программы для imagesize.



-----------------------------------------------------------------
getlinestyle
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION getlinestyle ()
      INTEGER*2 getlinestyle[FAR,C,ALIAS:"__getlinestyle"]
      END

ОПИСАНИЕ

     Некоторые   графические   процедуры   (lineto,pie,rectangle)
выводят  на экран прямые линии.  Тип линии можно контролировать с


                               330



помощью текущей маски стиля линии.

     Функция getlinestyle возвращает текущую маску  стиля  линий.
Маска  это  16-битовый  массив, в котором каждый бит представляет
пиксел в рисуемой линии.  Если бит равен  1,  то  соответствующий
пиксел в линии окрашивается текущим цветом линии.  Если бит равен
0,  то  соответствующий  пиксел   остается   нетронутым.    Маска
повторяется  по  всей  длине линии.  По умолчанию действует маска
#FFFF (сплошная линия).

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Если маска была задана, то  возвращается  16-битовое  число,
представляющее  текущую  маску  стиля  линий.  Если маска не была
задана, то getlinestyle возвращает умалчиваемую маску.

СМ.ТАКЖЕ

     lineto,pie,rectangle,setlinestyle

ПРИМЕР

     См.пример программы для setlinestyle.



-----------------------------------------------------------------
getphyscoord
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO SUBROUTINE
     +getphyscoord[FAR,C,ALIAS:"__f_getphyscoord"](x,y,s)
      INTEGER*2 x,y
      STRUCTURE/xycoord/
        INTEGER*2 xcoord
        INTEGER*2 ycoord
      END STRUCTURE
      RECORD/xycoord/s[FAR,REFERENCE]
      END

ОПИСАНИЕ

     Подпрограмма  getphyscoord   транслирует   точку   (x,y)   в
координатах  окна просмотра в физические координаты, возвращая их
в xycoord-структуру s, определенную в FGRAPH.FD.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ



                               331



     Возвращаемого значения нет.

СМ.ТАКЖЕ

     getviewcoord

ПРИМЕР

     См.пример программы для setviewport.



-----------------------------------------------------------------
getpixel,getpixel_w
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION getpixel (x,y)
      INTEGER*2 getpixel[FAR,C,ALIAS:"__getpixel"]
      INTEGER*2 x,y
      END

      INTERFACE TO FUNCTION getpixel_w(wx,wy)
      INTEGER*2 getpixel_w[FAR,C,ALIAS:"__f_getpixel_w"]
      DOUBLE PRECISION wx,wy
      END

ОПИСАНИЕ

     Функции getpixel  возвращают  значение  пиксела  в  заданной
позиции.   Функция  getpixel  использует  координаты (x,y) в окне
просмотра.  Функция getpixel_w использует точку (wx1,wy1) в  окне
мировых   координат.    Диапазон  возможных  значений  пиксела  и
трансляция в цвет определяются текущим видеорежимом  и  палитрой,
сооветственно.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     В случае успеха функции  getpixel  и  getpixel_w  возвращают
значение  пиксела.   Если  функция отработала неудачно (например,
точка лежит вне  области  отсечения  или  программа  находится  в
текстовом режиме), то функция возвращает -1.

СМ.ТАКЖЕ

     remapallpalette,remappalette,selectpalette,setpixel,
     setvideomode

ПРИМЕР


                               332



      PROGRAM colors

      INCLUDE 'FGRAPH.FI'
      INCLUDE 'FGRAPH.FD'

      INTEGER*2 loop, dummy2
      REAL rnd1, rnd2

      dummy2 = setvideomode( $MRES16COLOR )
      dummy2 = rectangle( $GFILLINTERIOR, 80, 50, 240, 150 )
      DO loop = 1, 8000
         dummy2 = setcolor( MOD( getcolor()+1, 16 ) )
C
C        Set a random pixel, but only if it is already on.
C
         CALL RANDOM( rnd1 )
         CALL RANDOM( rnd2 )
         IF ( getpixel( INT2( rnd1*320 ), INT2( rnd2*200 ) )
     +   .NE. 0) THEN
            dummy2 = setcolor(( MOD( loop, 16 ) )
            dummy2 = setpixel( INT2( rnd*320 ), INT2( rnd2*200 ) )
         END IF
      END DO

      dummy2 = setvideomode( $DEFAULTMODE )
      END

     Эта  программа  присваивает  различные   цвета   произвольно
выбранным пикселам.



-----------------------------------------------------------------
gettextcolor
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION gettextcolor ()
      INTEGER*2 gettextcolor[FAR,C,ALIAS:"__gettextcolor"]
      END

ОПИСАНИЕ

     Функция  gettextcolor  возвращает  индекс   текущего   цвета
текста.  Цвет текста устанавливается только функцией settextcolor
и влияет только на текст, выводимый  функцией  outtext.   Функция
setcolor  устанавливает  цвет для вывода текста с помощью функции
outgtext.



                               333



     Умолчанием  является  наивысший  доступный  индекс  цвета  в
текущей палитре.

     Эта функция доступна также в OS/2.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращает индекс текущего цвета текста.

СМ.ТАКЖЕ

     selectpalette,setcolor,settextcolor

ПРИМЕР

CC  TEXT.FOR - иллюстрирует функции вывода текста, включая:
CC             gettextcolor     getbkcolor     gettextposition
CC             outtext          settextcolor   setbkcolor
CC             settextposition  clearscreen
CC

      INCLUDE  'FGRAPH.FI'
      INCLUDE  'FGRAPH.FD'

      INTEGER*2          dummy2, blink, fgd, oldfgd
      INTEGER*4          dummy4, bgd, oldbgd
      CHARACTER*4        str
      RECORD / rccoord / curpos

C
C     Сохраняем первоначальные цвета и позицию текста.
C
      oldfgd = gettextcolor()
      oldbgd = getbkcolor()
      CALL clearscreen( $GCLEARSCREEN )
C
C     Первый раз без мигания, второй раз с миганием.
C
      DO blink = 0, 16, 16
C
C        Цикл по 8 цветам фона.
C
         DO bgd = 0, 7
            dummy4 = setbkcolor( bgd )
            CALL settextposition( INT2( bgd ) +
     +           ( (blink / 16) * 9 ) + 3, 1, curpos )
            dummy2 = settextcolor( 15 )
            WRITE (str, '(I4)') bgd
            CALL outtext( 'Back:' // str(3:4) // '  Fore:' )
C


                               334



C           Цикл по 16 цветам.
C
            DO fgd = 0, 15
               dummy2 = settextcolor( fgd + blink )
               WRITE (str, '(I4)') fgd + blink
               CALL outtext( str )
            END DO
         END DO
      END DO

      WRITE (*, '(///// A \)') ' Press ENTER to exit . . . '
      READ (*,*)

C
C     Восстанавливаем первоначальные цвета.
C
      dummy2 = settextcolor( oldfgd )
      dummy4 = setbkcolor( oldbgd )
      CALL clearscreen( $GCLEARSCREEN )
      END

     Эта программа печатает текст различного цвета  на  различном
цветном фоне.



-----------------------------------------------------------------
gettextcursor
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION gettextcursor ()
      INTEGER*2 gettextcursor[FAR,C,ALIAS:"__gettextcursor"]
      END

ОПИСАНИЕ

     Функция gettextcursor возвращает  текущие  атрибуты  курсора
(форму).   Обратите  внимание,  что эта функция работает только в
текстовых видеорежимах.

     Эта функция доступна также в OS/2.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращает текущие атрибуты курсора или -1, если имеет место
ошибка (например, вызов функции в нетекстовом видеорежиме).

СМ.ТАКЖЕ


                               335



     displaycursor,settextcursor

ПРИМЕР

     См.пример программы для settextcursor.



-----------------------------------------------------------------
gettextposition
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO SUBROUTINE
     +gettextposition[FAR,C,ALIAS:"__f_gettextposition"](s)
      STRUCTURE/rccoord/
        INTEGER*2 row
        INTEGER*2 col
      END STRUCTURE
      RECORD/rccoord/s[FAR,REFERENCE]
      END

ОПИСАНИЕ

     Функция  gettextposition  возвращает  в  s  текущую  позицию
текста, где s это структура rccoord, определенная в FGRAPH.FD.

     Позиция текста, заданная  координатами  (1,1),  определяется
как верхний левый угол текстового окна.

     Вывод текста с помощью функции outtext начинается в  текущей
позиции  текста.   Текущая  позиция текста не влияет на шрифтовый
текст.   Графический   вывод   начинается   в   текущей   позиции
графического  вывода,  которая  в  общем  случае  не  совпадает с
текущей позицией текста.

     Эта функция доступна также в OS/2.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращаемого значения нет.

СМ.ТАКЖЕ

     settextposition

ПРИМЕР

     См.пример программы для gettextcolor.


                               336




-----------------------------------------------------------------
getvideoconfig
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO SUBROUTINE
     +getvideoconfig[FAR,C,ALIAS:"__getvideoconfig"] (s)
      STRUCTURE/videoconfig/
        INTEGER*2 numxpixels    ! число пикселов по оси x
        INTEGER*2 numypixels    ! число пикселов по оси y
        INTEGER*2 numtextcols   ! число доступных столбцов текста
        INTEGER*2 numtextrows   ! число доступных строк текста
        INTEGER*2 numcolors     ! число действительных цветов
        INTEGER*2 bitsperpixel  ! число бит на пиксел
        INTEGER*2 numvideopages ! число доступных видеостраниц
        INTEGER*2 mode          ! текущий видеорежим
        INTEGER*2 adapter       ! активный адаптер
        INTEGER*2 monitor       ! активный монитор
        INTEGER*2 memory        ! память видеоадаптера в Кбайтах
      END STRUCTURE
      RECORD/videoconfig/s[FAR,REFERENCE]
      END

ОПИСАНИЕ

     Функция getvideoconfig возвращает в s  текущую  конфигурацию
графической  среды, где s это структура videoconfig, определенная
выше и в файле FGRAPH.FD.

     Возвращенные значения отображают текущий активный монитор, а
также действующий видеорежим.

     Структура videoconfig содержит следующие элементы:

Элемент           Содержание
-------           ----------
numxpixels        Число пикселов по оси x.

numypixels        Число пикселов по оси y.

numtextcols       Число доступных столбцов текста.

numtextrows       Число доступных строк текста.

numcolors         Число доступных цветов.

bitsperpixel      Число бит на пиксел.



                               337



numvideopages     Число доступных видеостраниц.

mode              Текущий видеорежим.

adapter           Активный адаптер.

monitor           Активный монитор.

memory            Память видеоадаптера (в Кбайтах).

     Значения для элемента adapter структуры videoconfig задаются
символическими  константами,  показанными  ниже  в  таблице.  Для
любого   используемого   адаптера   ($CGA,   $EGA    или    $VGA)
соответствующий   адаптер   Olivetti  ($OCGA,  $OEGA  или  $OVGA)
представляет дополнительное множество графических возможностей.

Константа        Смысл
---------        -----
$MDPA            Monochrome Display Adapter

$CGA             Color Graphics Adapter

$OCGA            Olivetti (AT&T) Color Graphics Adapter

$EGA             Enhanced Graphics Adapter

$OEGA            Olivetti (AT&T) Enhanced Graphics Adapter

$VGA             Video Graphics Array

$OVGA            Olivetti (AT&T) Video Graphics Array

$MCGA            Multicolor Graphics Array

$HGC             Hercules Graphics Card

     Значения для элемента monitor структуры videoconfig задаются
символическими константами, перечисленными ниже.

Константа               Смысл
---------               -------
$MONO                   Монохромный монитор

$COLOR                  Цветной

$ENHCOLOR               Улучшенный цвет

$ANALOG                 Аналог

     В   каждом   текстовом    режиме,    включая    монохромный,


                               338



getvideoconfig возвращает значение 32 для числа доступных цветов.
Значение 32 обозначает диапазон значений  (0-31),  воспринимаемых
функцией  settextrcolor.   Сюда входит 16 обычных цветов (0-15) и
16 мигающих цветов (16-31).  Мигание выбирается добавлением 16  к
значению  обычного  цвета.   Монохромный текстовый режим обладает
меньшим  количеством  атрибутов  дисплея,  и  некоторые  значения
цветов  являются  излишними.   Тем  не  менее,  поскольку мигание
выбирается точно так же, то  монохромный  текстовый  режим  имеет
такой же диапазон (0-31), как и другие текстовые режимы.

     Эта подпрограмма доступна также в OS/2.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращает текущую конфигурацию графической среды.

ПРИМЕР

     См.пример программы для setvideomoderows.



-----------------------------------------------------------------
getviewcoord,getviewcoord_w
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO SUBROUTINE
     + getviewcoord[FAR,C,ALIAS:"__f_getviewcoord"](x,y,s)
      INTEGER*2 x,y
      STRUCTURE/xycoord/
        INTEGER*2 xcoord              ! координата x
        INTEGER*2 ycoord              ! координата y
      END STRUCTURE
      RECORD/xycoord/s[FAR,REFERENCE]
      END

      INTERFACE TO SUBROUTINE
     + getviewcoord_w[FAR,C,ALIAS:"__f_getviewcoord_w"](wx,wy,s)
      DOUBLE PRECISION wx,wy
      STRUCTURE/xycoord/
        INTEGER*2 xcoord              ! координата x
        INTEGER*2 ycoord              ! координата y
      END STRUCTURE
      RECORD/xycoord/s[FAR,REFERENCE]
      END

ОПИСАНИЕ



                               339



     Подпрограммы getviewcoord  транслируют  заданные  координаты
(x,y) из одной координатной системы в координаты окна просмотра и
возвращают их в xycoord-структуру s, определенную в FGRAPH.FD.

     Подпрограммы getviewcoord транслируют  координаты  следующим
образом:

Подпрограмма      Трансляция
------------      -----------
getviewcoord      Физические координаты (x,y) в координаты
                  окна просмотра.

getviewcoord_w    Мировые координаты (wx,wy) в координаты
                  окна просмотра.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращаемого значения нет.

СМ.ТАКЖЕ

     getphyscoord,getwindowcoord

ПРИМЕР

     См.пример программы для setviewport.



-----------------------------------------------------------------
getvisualpage
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION getvisualpage()
      INTEGER*2 getvisualpage[FAR,C,ALIAS:"__getvisualpage"]
      END

ОПИСАНИЕ

     Функция  getvisualpage  возвращает  номер  текущей   видимой
страницы.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращает номер текущей видимой страницы.   Все  аппаратные
комбинации  поддерживают,  по  крайней  мере,  одну  страницу  (с
номером 0).



                               340



     Эта функция доступна также в OS/2.

СМ.ТАКЖЕ

     getactivepage,gettextcolor,gettextposition,outtext,
     settextcolor,settextposition,settextwindow,setvideomode,
     setvisualpage,wrapon

ПРИМЕР

     См.пример программы для getactivepage.



-----------------------------------------------------------------
getwindowcoord
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO SUBROUTINE
     +getwindowcoord[FAR,C,ALIAS:"__f_getwindowcoord"](x,y,s)
      INTEGER*2 x,y
      STRUCTURE/wxycoord/
        DOUBLE PRECISION wx
        DOUBLE PRECISION wy
      END STRUCTURE
      RECORD/wxycoord/s[FAR,REFERENCE]
      END

ОПИСАНИЕ

     Подпрограмма  getwindowcoord  транслирует  координаты  (x,y)
окна просмотра в координаты в окне мировых координат и возвращает
их в s, где s это структура wxycoord, определенная в FGRAPH.FD.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращаемого значения нет.

СМ.ТАКЖЕ

     getphyscoord,getviewcoord,getviewcoordw,getviewcoordwxy,
     moveto

ПРИМЕР

     См.пример программы для setviewport.




                               341



-----------------------------------------------------------------
imagesize,imagesize_w
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION imagesize (x1,y1,x2,y2)
      INTEGER*4 imagesize[FAR,C,ALIAS:"__imagesize"]
      INTEGER*2 x1,y1    ! верхний левый угол образа
      INTEGER*2 x2,y2    ! нижний правый угол образа
      END

      INTERFACE TO FUNCTION imagesize_w(wx1,wy1,wx2,wy2)
      INTEGER*4 imagesize_w[FAR,C,ALIAS:"__f_imagesize_w"]
      DOUBLE PRECISION wx1,wy1  ! верхний левый угол образа
      DOUBLE PRECISION wx2,wy2  ! нижний правый угол образа
      END

ОПИСАНИЕ

     Функции imagesize возвращают  количество  байт,  необходимое
для     хранения     образа,     определяемого     ограничивающим
прямоугольником,  который  задается   координатами   при   вызове
функции.     Функция    imagesize    определяет    ограничивающий
прямоугольник точками (x1,y1) и (x2,y2) в окне просмотра.  Размер
определяется по следующей формуле:

xwid = abs( x1-x2 )+1
ywid = abs( y1-y2 )+1
size = 4 + INT( ( xwid*bits_per_pixel+7 )/8 )*INT( ywid ) )

     Значение    bits_per_pixel    возвращается    при     вызове
getvideoconfig или bitsperpixel.

     Функция imagesize_w определяет ограничивающий  прямоугольник
точками (wx1,wy1) и (wx2,wy2) в окне мировых координат.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Функции imagesize и imagesize_w возвращают размер памяти для
образа в байтах.

СМ.ТАКЖЕ

     getvideoconfig

ПРИМЕР

CC  ANIMATE.FOR - иллюстрирует функции оживления, включая:
CC                imagesize     getimage     putimage


                               342



      INCLUDE  'FGRAPH.FI'
      INCLUDE  'FGRAPH.FD'

      INTEGER*1        buffer[FAR, ALLOCATABLE] (:)
      INTEGER*2        dummy, x, y, error, action(5)
      INTEGER*4        imsize
      CHARACTER*6      descrip(5)
      RECORD /rccoord/ curpos

      DATA action  / $GPSET, $GPRESET, $GXOR, $GOR, $GAND /
      DATA descrip /'PSET  ','PRESET','XOR   ','OR    ','AND   '/

C
C     Определяем графический режим.
C
      IF( setvideomode( $MAXRESMODE ) .EQ. 0 )
     +   STOP 'Error:  cannot set graphics mode'

      dummy = setcolor( 3 )
      y     = 30
      DO i = 1, 5
         x = 50
         y = y + 40
C
C        Выводим тип действия.
C
         CALL settextposition( 1, 1, curpos )
         CALL outtext( descrip(i) )
C
C        Рисуем и измеряем эллипс, резервируем память для образа.
C
         dummy  = ellipse( $GFILLINTERIOR, x - 15, y - 15, x + 15,
     +                     y + 15 )
         imsize = imagesize( x - 16, y - 16, x + 16, y + 16 )
         ALLOCATE( buffer( imsize ), STAT = error )
         IF( error .NE. 0 ) THEN
            dummy = setvideomode( $DEFAULTMODE )
            STOP 'Error:  insufficient memory'
         END IF
C
C        Получаем кооию эллипса.
C
         CALL getimage( x - 16, y - 16, x + 16, y + 16, buffer )
C
C        Копируем строки эллипса с заданным действием.
C
         DO x = 55, 255, 5
            CALL putimage( x - 16, y - 16, buffer, action(i) )
         END DO



                               343



C
C        Освобождаем память, ждем нажатия ENTER на клавиатуре.
C
         DEALLOCATE( buffer )
         READ (*,*)
      END DO

      dummy = setvideomode( $DEFAULTMODE )
      END

     Эта  программа   показывает   различные   методы   оживления
изображения на экране.



-----------------------------------------------------------------
lineto,lineto_w
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION lineto (x,y)
      INTEGER*2 lineto[FAR,C,ALIAS:"__lineto"]
      INTEGER*2 x,y            ! конечная точка
      END

      INTERFACE TO FUNCTION lineto_w(wx,wy)
      INTEGER*2 lineto_w[FAR,C,ALIAS:"__f_lineto_w"]
      DOUBLE PRECISION wx,wy   ! конечная точка
      END

ОПИСАНИЕ

     Функции lineto рисуют линию из текущей позиции  до  заданной
конечной  точки включительно.  Конечная точка для lineto задается
как точка (x,y) в координатах окна просмотра.  Конечная точка для
функции   lineto_w   задается   точкой  (wx,wy)  в  окне  мировых
координат.

     Линия рисуется  с  использованием  текущего  цвета  и  стиля
линии.   Если нет ошибок, то lineto устанавливает текущую позицию
в точку (x,y) окна просмотра, а  lineto_w  устанавливает  текущую
позицию в точку (wx,wy) окна мировых координат.

     ЗАМЕЧАНИЕ:  Если вы  используете  floodfill  для  заполнения
замкнутой  фигуры,  рисуемой  с  помощью lineto, то фигура должна
рисоваться сплошными линиями.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ



                               344



     Процедуры lineto и lineto_w возвращают  ненулевое  значение,
если  линия нарисована успешно; в противном случае они возвращают
0.

СМ.ТАКЖЕ

     getcurrentposition,setlinestyle

ПРИМЕР

      INCLUDE 'FGRAPH.FI'
      INCLUDE 'FGRAPH.FD'
      INTEGER*2 dummy
      RECORD /xycoord/ xy

      dummy = setvideomode( $MRES16COLOR )
      CALL    moveto( 80, 50, xy )
      dummy = lineto( 240, 150 )
      dummy = lineto( 240,  50 )
      READ (*,*)         ! ждет нажатия ENTER
      dummy = setvideomode( $DEFAULTMODE )
      END

     Эта программа рисует фигуру, показанную на рисунке R.3.

+---------------------------------------------------------------+
|                                                               |
|                                                               |
|                                                               |
|         moveto(80,50)                   lineto(240,50)        |
|        .                               .                      |
|                                                               |
|                                                               |
|                                                               |
|                                                               |
|                                                               |
|                                                               |
|                                                               |
|                                        .(240,150)             |
|                                                               |
|                                                               |
+---------------------------------------------------------------+
Рисунок R.3   Вывод программы lineto

     См.также пример программы для setpixel и setviewport.







                               345



-----------------------------------------------------------------
moveto,moveto_w
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO SUBROUTINE
     +             moveto[FAR,C,ALIAS:"__f_moveto"](x,y,s)
      INTEGER*2 x,y
      STRUCTURE/xycoord/
        INTEGER*2 xcoord
        INTEGER*2 ycoord
      END STRUCTURE
      RECORD/xycoord/s[FAR,REFERENCE]  ! возвращает предыдущую
      END                              ! позицию

      INTERFACE TO SUBROUTINE
     +             moveto_w[FAR,C,ALIAS:"__f_moveto_w"](wx,wy,s)
      DOUBLE PRECISION wx,wy
      STRUCTURE/wxycoord/
        DOUBLE PRECISION wx
        DOUBLE PRECISION wy
      END STRUCTURE
      RECORD/wxycoord/s[FAR,REFERENCE] ! возвращает предыдущую
      END                              ! позицию

ОПИСАНИЕ

     Функции moveto перемещают текущую позицию в заданную  точку.
Функция  moveto использует в качестве текущей позиции точку (x,y)
в координатах окна  просмотра.   Функция  moveto_w  использует  в
качестве  текущей позиции точку (wx,wy) в окне мировых координат.
Никакого рисования не выполняется.

     Функция  присваивает  аргументу  s   координаты   предыдущей
позиции,  причем  для  moveto  аргумент  s это структура xycoord,
определенная в FGRAPH.FD, а для функции moveto_w аргумент  s  это
структура wxycoord, определенная в этом же файле FGRAPH.FD.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращаемого значения нет.

СМ.ТАКЖЕ

     lineto

ПРИМЕР

     См.пример программы для setpixel и setviewport.


                               346




-----------------------------------------------------------------
outgtext
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO SUBROUTINE
     +             outgtext[FAR,C,ALIAS:"__f_outgtext"](text)
      CHARACTER*(*) text[FAR,REFERENCE]
      END

ОПИСАНИЕ

     Функция outgtext выводит на экран строку text, включая любые
хвостовые  пробелы.   Текст выводится с помощью текущего шрифта в
текущей графической позиции и с текущим цветом.

     Никакое форматирование не выполняется.

     После вывода текста outgtext  изменяет  текущую  графическую
позицию.

     ЗАМЕЧАНИЕ:    Функция   работает   только   в    графических
видеорежимах.   Поскольку это графическая функция, то цвет текста
устанавливается функцией setcolor, а не settextcolor.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращаемого значения нет.

СМ.ТАКЖЕ

     moveto,setcolor,setfont

ПРИМЕР

     См.пример программы для registerfonts.



-----------------------------------------------------------------
outtext
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO SUBROUTINE
     +             outtext[FAR,C,ALIAS:"__f_outtext"](text)
      CHARACTER*(*) text[FAR,REFERENCE]


                               347



      END

ОПИСАНИЕ

     Функция outtext выводит на экран строку text, включая  любые
хвостовые  пробелы.  Никакого форматирования не выполняется.  Эта
функция  работает  в  любом  экранном   режиме.    Вывод   текста
начинается в текущей позиции текста.

     ЗАМЕЧАНИЕ:  Для вывода текста с  использованием  специальных
шрифтов необходимо использовать функцию outgtext.

     Эта функция доступна также в OS/2.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращаемого значения нет.

СМ.ТАКЖЕ

     setactivepage,settextposition

ПРИМЕР

     См.пример программы для gettextcolor и setvideomoderows.



-----------------------------------------------------------------
pie,pie_w
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION pie (i,x1,y1,x2,y2,x3,y3,x4,y4)
      INTEGER*2 pie[FAR,C,ALIAS:"__pie"]
      INTEGER*2 i              ! флаг заполнения
      INTEGER*2 x1,y1          ! верх.левый угол огран.прям-ка
      INTEGER*2 x2,y2          ! ниж.правый угол огран.прям-ка
      INTEGER*2 x3,y3          ! начальный вектор
      INTEGER*2 x4,y4          ! конечный вектор
      END

      INTERFACE TO FUNCTION pie_w
     +             (i,wx1,wy1,wx2,wy2,wx3,wy3,wx4,wy4)
      INTEGER*2 pie_w[FAR,C,ALIAS:"__f_pie_w"]
      INTEGER*2 i              ! флаг заполнения
      DOUBLE PRECISION wx1,wy1 ! верх.левый угол огран.прям-ка
      DOUBLE PRECISION wx2,wy2 ! ниж.правый угол огран.прям-ка
      DOUBLE PRECISION wx3,wy3 ! начальный вектор


                               348



      DOUBLE PRECISION wx4,wy4 ! конечный вектор
      END

ОПИСАНИЕ

     Функции  pie   рисуют   клинообразные   фигуры   с   помощью
эллиптической   дуги,   центр   которой   и  две  конечные  точки
соединяются линиями.

     Функция pie использует координатную систему окна  просмотра.
Центр  дуги  это  центр  ограничивающего  прямоугольника, который
определяется  точками  (x1,y1)  и  (x2,y2)  в  координатах   окна
просмотра.   Дуга  начинается в точке, где она пересекает вектор,
определяемый (x3,y3), и оканчивается в точке, где она  пересекает
вектор (x4,y4).

     Функция pie_w использует точки  в  окне  мировых  координат.
Центр  дуги  это  центр  ограничивающего  прямоугольника, который
определяется  точками  (wx1,wy1)  и  (wx2,wy2)  в  окне   мировых
координат.   Дуга  начинается в точке, где она пересекает вектор,
определяемый  (wx3,wy3),  и  оканчивается  в   точке,   где   она
пересекает вектор (wx4,wy4).

     Фигура рисуется в текущем цвете в направлении против часовой
стрелки.   Параметр i может быть одной из следующих символических
констант:

Константа          Действие
---------          --------
$GFILLINTERIOR     Заполняет фигуру, используя текущие цвет и
                   маску заполнения.

$GBORDER           Не заполняет фигуру.

     Управляющая опция, задаваемая  $GFILLINTERIOR,  эквивалентна
последующему   вызову  функции  floodfill  с  центром  эллипса  в
качестве  начальной  точки  и   текущим   цветом   (установленным
setcolor) в качестве цвета границы.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Функции pie и  pie_w  возвращают  ненулевое  значение,  если
фигура нарисована успешно, в противном случае возвращают 0.

СМ.ТАКЖЕ

     arc,ellipse,floodfill,getcolor,lineto,rectangle,setcolor,
     setfillmask

ПРИМЕР


                               349



      INCLUDE 'FGRAPH.FI'
      INCLUDE 'FGRAPH.FD'
      INTEGER*2 dummy

      dummy = setvideomode( $MRES16COLOR )
      dummy = pie( $GBORDER, 80, 50, 240, 150, 240, 12, 0, 150 )
      READ (*,*)          ! ждет нажатия ENTER
      dummy = setvideomode( $DEFAULTMODE )
      END

   Программа рисует фигуру, показанную на рисунке R.4.

+---------------------------------------------------------------+
|                                                               |
|                                                               |
|    (x1,y1)                                         (x3,y3)    |
|        +--------------------------------------------+         |
|        |                                            |         |
|        |                                            |         |
|        |                                            |         |
|        |                                            |         |
|        |                                            |         |
|        |                                            |         |
|        |                                            |         |
|        |                                            |         |
|        |                                            |         |
|        +--------------------------------------------+         |
|    (x4,y4)                                         (x2,y2)    |
|                    Центр фигуры - центр огранич-го прям-ка    |
|                                                               |
+---------------------------------------------------------------+
Рисунок R.4   Вывод программы pie

     См.также пример программы для setpixel.



-----------------------------------------------------------------
putimage,putimage_w
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO SUBROUTINE
     + putimage[FAR,C,ALIAS:"__putimage"](x,y,image,action)
      INTEGER*2 x,y
      INTEGER*2 action
      INTEGER*1 image[FAR,REFERENCE](*)
      END



                               350



      INTERFACE TO SUBROUTINE
     + putimage_w[FAR,C,ALIAS:"__f_putimage_w"]
     +(wx,wy,image,action)
      DOUBLE PRECISION wx,wy
      INTEGER*2 action
      INTEGER*1 image[FAR,REFERENCE](*)
      END

ОПИСАНИЕ

     Функции putimage выводят на экран  изображение,  хранимое  в
буфере  image.  В функции putimage верхний левый угол изображения
помещается в точке (x,y) окна просмотра.

     В  функции  putimage_w  верхний   левый   угол   изображения
помещается в точке (wx,wy) окна мировых координат.

     Аргумент action  определяет  взаимодействие  между  хранимым
изображением  и  изображением,  которое  уже находится на экране.
Этот аргумент может принимать  одно  из  следующих  символических
значений (определенных в FGRAPH.FD):

Константа   Смысл
---------   -----
$GEND       Передает изображение поверх образа, существующего
            на экране. Результирующее изображение является
            логическим AND двух образов: точки, которые имеют
            одинаковый цвет в обеих картинках, останутся с
            этим же цветом, а точки, которые имеют разный цвет,
            соединятся логическим AND.

$GOR        Накладывает образ поверх существующего изображения.
            Новый образ не стирает предыдущее содержимое экрана.

$GPRESET    Передает данные на экран точка за точкой. Каждая
            точка получает атрибут цвета, обратный тому, который
            она имела при "съеме" с экрана функцией getimage.
            Таким образом, создается негативное изображение.

$GPSET      Передает данные на экран точка за точкой. Каждая
            точка имеет в точности тот атрибут цвета, который
            она имела при "съеме" с экрана функцией getimage.

$GXOR       Делает точки на экране обратными в тех местах, где
            точки существуют в буфере image. Это точно такое
            же поведение, как поведение курсора: если образ
            помещается по сложному фону дважды, то фон остается
            прежним. Это позволяет перемещать объект без
            стирания фона. Константа $GXOR это специальный
            режим, часто используемый для оживления изображения.


                               351



ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращаемого значения нет.

СМ.ТАКЖЕ

     getimage,imagesize

ПРИМЕР

     См.пример программы для imagesize.



-----------------------------------------------------------------
rectangle,rectangle_w
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION rectangle (control,x1,y1,x2,y2)
      INTEGER*2 rectangle[FAR,C,ALIAS:"__rectangle"]
      INTEGER*2 control          ! флаг заполнения
      INTEGER*2 x1,y1            ! верхний левый угол
      INTEGER*2 x2,y2            ! нижний правый угол
      END

      INTERFACE TO FUNCTION rectangle_w(control,wx1,wy1,wx2,wy2)
      INTEGER*2 rectangle_w[FAR,C,ALIAS:"__f_rectangle_w"]
      INTEGER*2 control          ! флаг заполнения
      DOUBLE PRECISION wx1,wy1   ! верхний левый угол
      DOUBLE PRECISION wx2,wy2   ! нижний правый угол
      END

ОПИСАНИЕ

     Функции rectangle рисуют  прямоугольник,  используя  текущий
тип (стиль) линий.

     Функция  rectangle  использует  координатную  систему   окна
просмотра,  где  точки  (x1,y1)  и (x2,y2) определяют диагонально
противоположные углы прямоугольника.

     Функция  rectangle_w  в   качестве   противоположных   углов
прямоугольника  принимает  точки  (wx1,wy1)  и  (wx2,wy2)  в окне
мировых координат.

     Параметр control  может  принимать  следующие  символические
значения, определенные в файле FGRAPH.FD:



                               352



Константа        Действие
---------        --------
$GFILLINTERIOR   Заполняет фигуру текущим цветом, используя
                 текущую маску заполнения.

$GBORDER         Не заполняет прямоугольник.

     ЗАМЕЧАНИЕ:  Если вы хотите заполнить  прямоугольник  текущим
цветом  с  помощью  функции  floodfill, то границы прямоугольника
должны быть нарисованы сплошными линиями.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Функции  rectangle  и   rectangle_w   возвращают   ненулевое
значение,  если  прямоугольник нарисован успешно, и 0 в противном
случае.

СМ.ТАКЖЕ

     floodfill,getcolor,getlinestyle,setcolor,setlinestyle

ПРИМЕР

      INCLUDE 'FGRAPH.FI'
      INCLUDE 'FGRAPH.FD'
      INTEGER*2 dummy

      dummy = setvideomode( $MRES16COLOR )
      dummy = rectangle( $GBORDER, 80, 50, 240, 150 )
      READ (*,*)       ! ждет нажатия ENTER
      dummy = setvideomode( $DEFAULTMODE )
      END

   Эта программа рисует прямоугольник, показанный на рисунке R.5.

+---------------------------------------------------------------+
|    (x1,y1)                                                    |
|        +--------------------------------------------+         |
|        |                                            |         |
|        |                                            |         |
|        |                                            |         |
|        |                                            |         |
|        |                                            |         |
|        |                                            |         |
|        |                                            |         |
|        |                                            |         |
|        +--------------------------------------------+         |
|                                                    (x2,y2)    |
+---------------------------------------------------------------+
Рисунок R.5   Вывод программы rectangle


                               353



     См.также  пример  программы  для  setpixel,   setvieworg   и
setviewport.



-----------------------------------------------------------------
registerfonts
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION registerfonts(filename)
      INTEGER*2 registerfonts[FAR,C,ALIAS:"__f_registerfonts"]
      CHARACTER*(*) filename[FAR,REFERENCE]
      END

ОПИСАНИЕ

     Функция  registerfonts  инициирует   шрифтовую   графическую
систему.  Перед использованием графических функций, работающих со
шрифтами (getgtextextent,  setfont,  outgtext,  unregisterfonts),
файлы  со шрифтами должны быть зарегистрированы с помощью функции
registerfonts.

     Функция registerfonts считывает заданные файлы и загружает в
память  головную  информацию  о  шрифтах.  Каждый такой заголовок
шрифта занимает приблизительно 140 байт памяти.

     Аргумент  filename  является  спецификацией  пути  и   имени
действительных  файлов  с  расширением .FON.  Этот аргумент может
содержать стандартные метасимволы DOS.

     ЗАМЕЧАНИЕ:   Шрифтовые  функции  влияют  только  на   вывод,
выполняемый  с  помощью  функции  outgtext;  ни  на  какие другие
функции вывода Фортрана они влияния не оказывают.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращает  положительное  значение,  которое  равно   числу
успешно   зарегистрированных   шрифтов.   Отрицательное  значение
означает ошибку.  Могут быть возвращены  следующие  отрицательные
значения:

Значение    Смысл
--------    -----
-1          Нет такого файла или каталога.

-2          Один или несколько файлов .FON не являются
            действительными двоичными файлами .FON.



                               354



-3          Один или несколько файлов .FON разрушены.

СМ.ТАКЖЕ

     getfontinfo,getgtextextent,outgtext,setfont,unregisterfonts

ПРИМЕР

CC  FONTS.FOR - иллюстрирует использование следующих шрифтовых
CC              функций:
CC              registerfonts      setfont        outgtext
CC              unregisterfonts    getfontinfo    getgtextextent

      INCLUDE  'FGRAPH.FI'
      INCLUDE  'FGRAPH.FD'

      PARAMETER            ( NFONTS = 6 )

      INTEGER*2            dummy, x, y, iend
      INTEGER*4            ifont
      CHARACTER*11         face(NFONTS)
      CHARACTER*10         options(NFONTS)
      CHARACTER*20         list
      CHARACTER*64         fontpath
      RECORD /videoconfig/ vc
      RECORD /xycoord/     xy
      RECORD /fontinfo/    fi

      DATA face    / "Courier"   , "Helvetica", "Times Roman",
     +               "Modern"    , "Script"   , "Roman"      /
      DATA options / "t'courier'", "t'helv'"  , "t'tms rmn'" ,
     +               "t'modern'" , "t'script'", "t'roman'"   /

C
C     Ищет файлы .FON, затем регистрирует шрифты, считывая
C     головную информацию из всех файлов.
C
      IF( registerfonts( '*.FON' ). LT. 0 ) THEN
         WRITE (*, '(A/)') ' Enter directory for .FON files:'
         READ  (*, '(A )') fontpath
         iend = INDEX( fontpath, ' ' )
         fontpath(iend:iend + 5) = '\*.FON'
         IF( registerfonts( fontpath ). LT. 0 )
     +       STOP 'Error:  cannot find font files'
      ENDIF

C
C     Установка графического режима.
C
      IF( setvideomode( $MAXRESMODE ) .EQ. 0 )


                               355



     +   STOP 'Error:  cannot set graphics mode'
      CALL getvideoconfig( vc )

C
C     Выводит имя каждого шрифта в центре экрана.
C
      DO ifont = 1, NFONTS
C
C        Построение строки опций.
C
         list = options(ifont) // 'h30w24b'

         CALL clearscreen( $GCLEARSCREEN )
         IF( setfont( list ) .EQ. 0 ) THEN
C
C           Использует длину текста и высоту шрифта для
C           центрирования текста.
C
            x = (vc.numxpixels - getgtextextent(face(ifont))) / 2
            IF( getfontinfo( fi ) .NE. 0 ) THEN
               CALL outtext( 'Error:  cannot get font info' )
               READ (*,*)
               EXIT
            END IF
            y = (vc.numypixels - fi.ascent) / 2
            CALL moveto( x, y, xy )
            IF( vc.numcolors .GT. 2 ) dummy = setcolor( ifont )
            CALL outgtext( face(ifont) )
         ELSE
            CALL outtext( 'Error:  cannot set font' )
         END IF
         READ (*,*)
      END DO

      CALL unregisterfonts()
      dummy = setvideomode( $DEFAULTMODE )
      END

     Программа FONTS.FOR выводит на экран текст с  использованием
шрифтов, поставляемых в графической библиотеке MSФортрана.


-----------------------------------------------------------------
remapallpalette,remappalette
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION remapallpalette(colors)
      INTEGER*2 remapallpalette[FAR,C,ALIAS:"__remapallpalette"]


                               356



      INTEGER*4 colors[FAR,REFERENCE](*)
      END

      INTERFACE TO FUNCTION remappalette (index,color)
      INTEGER*4 remappalette[FAR,C,ALIAS:"__remappalette"]
      INTEGER*4 color
      INTEGER*2 index
      END

ОПИСАНИЕ

     Функция remapallpalette переопределяет (переотображает)  все
доступные индексы цветов одновременно.  Аргумент colors указывает
на массив значений цветов.  Ниже показан действующий по умолчанию
массив цветовых индексов.

-----------------------------------------------------------------
Индекс Цвет                 Индекс Цвет
-----------------------------------------------------------------
  0    черный (black)          8   темно-серый (dark gray)
  1    синий (blue)            9   светло-синий (light blue)
  2    зеленый (green)        10   светло-зеленый (light green)
  3    голубой (cyan)         11   светло-голубой (light cyan)
  4    красный (red)          12   светло-красный (light red)
  5    фиолетовый (magenta)   13   светло-фиолет. (light magenta)
  6    коричневый (brown)     14   желтый (yellow)
  7    белый (white)          15   ярко-белый (bright white)
-----------------------------------------------------------------

     Число  отображаемых  цветов   зависит   от   числа   цветов,
поддерживаемых  текущим  видеорежимом.   16-цветный  режим  будет
отображать все показанные цвета от 0 до 15.  Восьмицветный  режим
будет  отображать  цвета  только от 0 до 7.  Четырехцветный режим
будет использовать одну стандартную палитру,  поддерживаемую  EGA
(см.  selectpalette).  Двухцветный режим будет поддерживать цвета
0 и 7 (черный и белый).

     Если colors является массивом из восьми  элементов,  которые
равны 1,3,5,7,2,4,6 и 8, то эти индексы цветов отображались бы на
действительные  цвета  в  восьмицветном   видеорежиме   следующим
образом:
-----------------------------------------------------------------
Индекс   Цвет                Индекс   Цвет
-----------------------------------------------------------------
1        синий (blue)        5        оранжевый (magenta)
2        зеленый (green)     6        коричневый (brown)
3        голубой (cyan)      7        белый (white)
4        красный (red)       8        темно-серый (dark gray)
-----------------------------------------------------------------



                               357



     Вы просто отображаете набор значений  цветов  на  порядковые
числа, распознаваемые аппаратурой; colors может быть больше числа
цветов, поддерживаемых  текущим  видеорежимом.   Доступны  только
первые  n  цветов, где n это число цветов, поддерживаемых текущим
видеорежимом.  Функция remappalette  переотображает  один  индекс
цвета  на  color,  где  color  это значение цвета, поддерживаемое
текущим видеорежимом.  Обе функции влияют на текущее  изображение
немедленно.

     Цветные графические режимы VGA поддерживают палитру в 262144
цветов   (256K).   Три  байта  даных  представляют  интенсивности
красного, синего и зеленого цветов.  Два старших  бита  в  каждом
байте  должны  быть  0.   Оставшиеся  шесть  бит  в  каждом байте
представляют  интенсивность  синего,  зеленого  и  красного  (при
чтении  от  старшего  байта  к младшему).  Например, для создания
белого цвета слабой интенсивности  используются  равные  значения
красного,  зеленого  и  синего,  и  поэтому трехбайтовое значение
цвета равно:

синий байт      зеленый байт     красный байт
00011111        00011111         00011111
старший байт ------------------> младший байт

     Из-за расщепления цветов между байтами  значения  цветов  не
являются  непрерывными.  Для обеспечения совместимости с палитрой
EGA определены символические константы для умалчиваемых  значений
цветов.  Имена этих констант перечислены ниже.

-----------------------------------------------------------------
Индекс   Константа             Индекс   Константа
-----------------------------------------------------------------
0        $BLACK                 8       $GRAY
1        $BLUE                  9       $LIGHTBLUE
2        $GREEN                10       $LIGHTGREEN
3        $CYAN                 11       $LIGHTCYAN
4        $RED                  12       $LIGHTRED
5        $MAGENTA              13       $LIGHTMAGENTA
6        $BROWN                14       $LIGHTBROWN
7        $WHITE                15       $BRIGHTWHITE
-----------------------------------------------------------------

     Функции remappalette  и  remapallpalette  работают  во  всех
видеорежимах, но только с EGA и VGA.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     В  случае  успеха   remapallpalette   возвращает   ненулевое
значение.   Если функция является недействующей (при выполнении в
конфигурации, отличной от EGA или VGA), то она возвращает 0.



                               358



     В случае успеха remappalette возвращает предыдущее  значение
цвета   для  данного  индекса  цвета.   В  противном  случае  она
возвращает -1.

СМ.ТАКЖЕ

     selectpalette,setbkcolor,setvideomode

ПРИМЕР

CC  PALETTE.FOR - иллюстрирует использование следующих функций
CC                для присваивания значений цветов цветовым
CC                индексам:
CC                remappalette       remapallpalette

      INCLUDE  'FGRAPH.FI'
      INCLUDE  'FGRAPH.FD'

      INTEGER*2            dummy2, mode, cells, x, y, xinc, yinc, i
      INTEGER*4            dummy4, pal(256), iblue, ired, igreen
      INTEGER*4            RGB, tmp, inc
      CHARACTER*3          str1, str2
      RECORD /videoconfig/ vc

C
C     Удостовериться, что все номера палитр действительны.
C
      DO i = 1, 256
         pal(i) = $BLACK
      END DO
C
C     Цикл по всем графическим режимам, которые поддерживают
C     палитры.
C

      DO mode = $MRES4COLOR, $MRES256COLOR
         IF( mode .EQ. $ERESNOCOLOR ) CYCLE
         IF( setvideomode( mode ) .EQ. 0 ) CYCLE
C
C        Получить видеоконфигурацию для текущего режима.
C
         CALL getvideoconfig( vc )
         SELECT CASE( vc.numcolors )

            CASE( 256 )
C
C              Активные биты в таком порядке:
C              ???????? ??bbbbbb ??gggggg ??rrrrrr
C
               cells = 13


                               359



               inc   = 12

            CASE( 16 )
C
C              Если $ERES или $VRES16, активные биты
C              в таком порядке:
C              ???????? ??????bb ??????gg ??????rr
C
C              В противном случае в таком порядке:
C              ???????? ??????Bb ??????Gg ??????Rr
C
               cells = 4
               inc   = 32
               IF( (vc.mode .EQ. $ERESCOLOR)  .OR.
     +             (vc.mode .EQ. $VRES16COLOR) ) inc = 16

            CASE( 4 )
C
C              Активные биты в таком порядке:
C              ???????? ??????Bb ??????Gg ??????Rr
C
               cells = 2
               inc   = 32

            CASE DEFAULT
               CYCLE

         END SELECT

         xinc = vc.numxpixels / cells
         yinc = vc.numypixels / cells

C
C        Заполняем палитровые массивы в порядке BGR.
C
         i = 1
         DO iblue = 0, 63, inc
            DO igreen = 0, 63, inc
               DO ired = 0, 63, inc
                  pal(i) = RGB( ired, igreen, iblue )
C
C                 Специальный случай использования шести битов
C                 для представления 16 цветов. Если для цвета
C                 установлены оба бита, включается интенсивность.
C                 Если для цвета установлен один бит, включается
C                 цвет.
C
                  IF( inc .EQ. 32 )
     +                pal(i + 8) = pal(i) .OR. (pal(i) / 2)
                  i = i + 1


                               360



               END DO
            END DO
         END DO
C
C        Если палитры доступны, переотображаем сразу все палитры.
C        В противном случае выходим.
C
         IF( remapallpalette( pal ) .EQ. 0 ) THEN
            dummy2 = setvideomode( $DEFAULTMODE )
            STOP 'Palettes not available with this adapter'
         END IF
C
C        Рисуем цветные квадраты.
C
         i = 0
         DO x = 0, ( xinc * cells ) - 1, xinc
            DO y = 0, ( yinc * cells ) - 1, yinc
               dummy2 = setcolor( INT4( i ) )
               dummy2 = rectangle( $GFILLINTERIOR, x, y, x+xinc,
     +                             y + yinc )
               i      = i + 1
            END DO
         END DO

         dummy2 = setcolor( INT4( vc.numcolors / 2 ) )
         WRITE (str1, '(I3)') vc.mode
         WRITE (str2, '(I3)') vc.numcolors
         CALL outtext( 'Mode'//str1//' has'//str2//' colors' )
         READ (*,*)
C
C        Изменяем каждый элемент палитры отдельно в порядке GRB.
C
         i = 0
         DO igreen = 0, 63, inc
            DO ired = 0, 63, inc
               DO iblue = 0, 63, inc
                  tmp    = RGB( ired, igreen, iblue )
                  dummy4 = remappalette( i, tmp )
                  IF( inc .EQ. 32 )
     +               dummy4 = remappalette(i+8, tmp.OR.(tmp/2))
                  i = i + 1
               END DO
            END DO
         END DO

         READ (*,*)
      END DO

      dummy2 = setvideomode( $DEFAULTMODE )
      END


                               361



CC  RGB - функция для смешивания элементов красного, зеленого и
CC        синего цветов.
CC
CC  Параметры:   r, g, b - значения для красного, зеленого и
CC               синего, соответственно.
CC
CC  Возвращает:  значение смешанного цвета.

      INTEGER*4 FUNCTION RGB( r, g, b )
      INTEGER*4 r, g, b

      RGB = ISHL( ISHL( b, 8 ) .OR. g, 8 ) .OR. r
      RETURN
      END

     Программа PALETTE.FOR  показывает  эффекты  использования  и
переотображения палитр.



-----------------------------------------------------------------
selectpalette
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION selectpalette (number)
      INTEGER*2 selectpalette[FAR,C,ALIAS:"__selectpalette"]
      INTEGER*2 number       ! номер палитры
      END

ОПИСАНИЕ

     Функция  selectpalette  работает   только   в   видеорежимах
$MRES4COLOR и $MRESNOCOLOR.  Палитра состоит из выбираемого цвета
фона (Color 0)  и  трех  других  цветов.   В  режиме  $MRES4COLOR
аргумент    number    определяет    выбор    одной   из   четырех
предопределенных палитр, показанных в таблице R.2.

Таблица R.2  Цвета палитр режима $MRES4COLOR
-----------------------------------------------------------------
                               Индексы цветов
Номер        ----------------------------------------------------
палитры      Цвет 1            Цвет 2             Цвет 3
-----------------------------------------------------------------
0            зеленый           красный            коричневый
1            голубой           оранжевый          светло-серый
2            светло-зеленый    светло-красный     желтый
3            светло-голубой    светло-оранжевый   белый
-----------------------------------------------------------------


                               362



     Видеорежим   $MRESNOCOLOR   используется   с    черно-белыми
дисплеями,  создавая  палитры  из  различных оттенков серого.  Он
создает также  цвет,  если  используется  с  цветными  дисплеями.
Число  доступных  палитр зависит от того, какой из адаптеров (EGA
или VGA) используется.  В конфигурации CGA  доступны  только  две
палитры, показанные в таблице R.3.

Таблица R.3  Цвета палитр режима $MRESNOCOLOR в CGA
-----------------------------------------------------------------
                               Индексы цветов
Номер        ----------------------------------------------------
палитры      Цвет 1            Цвет 2             Цвет 3
-----------------------------------------------------------------
0            синий             красный            светло-серый
1            светло-синий      светло-красный     белый
-----------------------------------------------------------------

     В конфигурации EGA в видеорежиме $MRESNOCOLOR  доступны  три
палитры, показанные в таблице R.4.

Таблица R.4  Цвета палитр режима $MRESNOCOLOR в EGA
-----------------------------------------------------------------
                               Индексы цветов
Номер        ----------------------------------------------------
палитры      Цвет 1            Цвет 2             Цвет 3
-----------------------------------------------------------------
0            зеленый           красный            коричневый
1            светло-зеленый    светло-красный     желтый
3            светло-голубой    светло-красный     желтый
-----------------------------------------------------------------

     ЗАМЕЧАНИЕ:  В  видеорежиме  $MRESNOCOLOR  в  EGA  палитра  3
идентична палитре 1.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращает значение предыдущей палитры.

СМ.ТАКЖЕ

     getvideoconfig,setvideomode

ПРИМЕР

CC  CGAPAL.FOR - иллюстрирует использование палитр CGA с помощью
CC               selectpalette

      INCLUDE  'FGRAPH.FI'
      INCLUDE  'FGRAPH.FD'



                               363



      INTEGER*2        dummy2
      INTEGER*4        dummy4, bkcolor(8)
      CHARACTER*7      bkname(8)
      CHARACTER*40     str
      RECORD /rccoord/ curpos

      DATA bkcolor / $BLACK , $BLUE    , $GREEN , $CYAN   ,
     +               $RED   , $MAGENTA , $BROWN , $WHITE  /
      DATA bkname  / 'BLACK', 'BLUE'   , 'GREEN', 'CYAN'  ,
     +               'RED'  , 'MAGENTA', 'BROWN', 'WHITE' /


C
C     Устанавливаем видеорежим.
C
      IF( setvideomode( $MRES4COLOR ) .EQ. 0 )
     +   STOP 'Error:  cannot set CGA color mode'
C
C     Цикл по палитрам.
C
      DO i = 0, 3
         dummy2 = selectpalette( i )
C
C        Цикл по цвету фона.
C
         DO k = 1, 8
            CALL clearscreen( $GCLEARSCREEN )
            dummy4 = setbkcolor( bkcolor(k) )
            CALL settextposition( 1, 1, curpos )
            WRITE (str, 9000) bkname(k), i
            CALL outtext( str )
C
C           Цикл по цветам.
C
            DO j = 1, 3
               dummy2 = setcolor( INT4( j ) )
               dummy2 = ellipse( $GFILLINTERIOR, 100, j*30, 220,
     +                           80 + (j * 30) )
            END DO
            READ (*,*)
         END DO
      END DO

      dummy2 = setvideomode( $DEFAULTMODE )

 9000 FORMAT ('Background: ', A, 10x, 'Palette: ', I2)

      END

     Программа CGAPAL.FOR рисует  серии  линейных  сегментов  при


                               364



непрерывно меняющейся текущей палитре.



-----------------------------------------------------------------
setactivepage
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION setactivepage (page)
      INTEGER*2 setactivepage[FAR,C,ALIAS:"__setactivepage"]
      INTEGER*2 page         ! номер страницы памяти
      END

ОПИСАНИЕ

     Для аппаратной конфигурации с достаточным объемом памяти для
поддержки многоэкранных страниц функция setactivepage определяет,
в какую часть памяти  выполняется  графический  вывод.   Аргумент
page  служит  для выбора текущей активной страницы.  По умолчанию
действует номер страницы 0.

     Объекты на экране можно оживлять, поочередно  меняя  видимую
графическую  страницу.   Функция  setvisualpage  используется для
вывода на экран полностью завершенной графической страницы, в  то
время как рисование можно выполнять на другой активной странице.

     Эти функции можно также использовать для управления  выводом
текста,  если вы вместо стандартных функций ввода-вывода Фортрана
используете  такие  функции,  как  gettextcolor,   gettextcursor,
gettextposition,     outtext,     settextcolor,    settextcursor,
settextposition, settextwindow и wrapon.

     Эта функция доступна также в OS/2.

     ЗАМЕЧАНИЕ:  Аппаратная конфигурация  CGA  имеет  только  16K
памяти для поддержки нескольких видеостраниц и только в текстовом
режиме.  Конфигурации EGA и VGA могут снабжаться до  256K  памяти
для содержания нескольких видеостраниц в графическом режиме.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     В случае успеха возвращает номер  предыдущей  видеостраницы.
При неудаче возвращает -1.

СМ.ТАКЖЕ

     getactivepage,getvisualpage,gettextcolor,gettextposition,
     outtext,settextcolor,settextposition,settextwindow,


                               365



     setvideomode,setvisualpage,wrapon

ПРИМЕР

     См.пример программы для getactivepage.



-----------------------------------------------------------------
setbkcolor
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION setbkcolor (color)
      INTEGER*4 setbkcolor[FAR,C,ALIAS:"__setbkcolor"]
      INTEGER*4 color
      END

ОПИСАНИЕ

     Функция setbkcolor устанавливает текущий  цвет  фона  равным
значению цвета color.

     В цветном текстовом режиме (например, в $TEXTC80) setbkcolor
принимает   индекс   цвета.   Значения  для  умалчиваемых  цветов
перечислены   в   описании   функции   settextcolor.    Например,
setbkcolor(2)  устанавливает  цвет  фона  равным индексу цвета 2.
Фактический цвет на экране зависит  от  отображения  палитры  для
пиксельного  значения  2.   Умолчанием  является  зеленый  цвет в
цветном текстовом режиме.

     В  цветном  графическом  режиме  (например,  в   $ERESCOLOR)
setbkcolor  принимает  значение  цвета.   Значение для цвета фона
задается    символическими    константами,    определенными     в
include-файле     FGRAPH.FD.      Например,    setbkcolor($GREEN)
устанавливает  зеленый  цвет  фона  в  графическом  режиме.   Эти
символические   константы  даны  для  удобства  в  определении  и
манипулировании      наиболее      употребительными      цветами.
Действительный диапазон цветов много больше.

     Функция setbkcolor принимает в качестве  аргумента  значение
INTEGER*4, которое является индексом цвета.

     Всякий раз, когда аргумент имеет тип INTEGER*4, он относится
к  значению  цвета, а если он имеет тип INTEGER*2, то относится к
индексу цвета.  Двумя  исключениями  из  этого  правила  являются
функции setbkcolor и getbkcolor.

     Поскольку  цвет  фона  имеет  индекс  цвета  0,  то  функция


                               366



remappalette  будет  делать  то  же самое, что делает setbkcolor.
Но, в отличие от  remappalette,  функция  setbkcolor  не  требует
среды EGA или VGA.

     В текстовом режиме функция setbkcolor не влияет ни  на  что,
уже  имеющееся на экране, она влияет только на последующий вывод.
В графическом режиме она немедленно изменяет все пикселы фона.

     Эта функция доступна также в OS/2.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращает старое значение цвета фона.

СМ.ТАКЖЕ

     getbkcolor,remappalette,selectpalette

ПРИМЕР

     См.пример программы для gettextcolor.



-----------------------------------------------------------------
setcliprgn
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO SUBROUTINE
     +setcliprgn[FAR,C,ALIAS:"__setcliprgn"] (x1,y1,x2,y2)
      INTEGER*2 x1,y1
      INTEGER*2 x2,y2
      END

ОПИСАНИЕ

     Функция  setcliprgn  ограничивает  последующий   графический
вывод   и   вывод  шрифтовых  текстов  заданной  областью  экрана
(областью отсечения).   Точки  (x1,y1)  и  (x2,y2)  в  физических
координатах  представляют  верхний  левый  и  нижний  правый углы
прямоугольника, который определяет  область  отсечения.   Функция
setcliprgn  не  изменяет  систему  координат  окна просмотра, она
только маскирует экран.

     ЗАМЕЧАНИЕ:  Функция setcliprgn влияет только на  графический
и   текстовый   (шрифтовый)  вывод.   Для  маскирования  обычного
текстового вывода используйте функцию settextwindow.



                               367



ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращаемого значения нет.

СМ.ТАКЖЕ

     settextwindow,setvieworg,setviewport,setwindow

ПРИМЕР

      INCLUDE 'FGRAPH.FI'
      INCLUDE 'FGRAPH.FD'
      INTEGER*2 dummy

      dummy = setvideomode( $MRES16COLOR )
      CALL    setcliprgn( 0, 0, 200, 125 )
      dummy = ellipse( $GBORDER, 80, 50, 240, 200 )
      READ (*,*)     ! нажмите ENTER для выхода
      dummy = setvideomode( $DEFAULTMODE )
      END

     Эта программа рисует эллипс, частично лежащий внутри области
отсечения, как показано на рисунке R.6.

+---------------------------------------------------------------+
|                                                               |
|         ______ ограничивающий прямоугольник _____             |
|        /                                         \            |
|       /                                           \           |
|      +-------------------------------+ - - - - - - +          |
|      |                                                        |
|      |                               |             |          |
|      |                                                        |
|      |                               |             |          |
|      |                                                        |
|      |                               |             |          |
|      |                                                        |
|      +-------------------------------+ - - - - - - +          |
|       \                             / \           /           |
|        \         область           /   отсеченная             |
|          ------ отсечения --------        часть               |
|                                          эллипса              |
+---------------------------------------------------------------+
Рисунок R.6  Вывод программы setcliprgn

     См.также пример программы для setvieworg.






                               368



-----------------------------------------------------------------
setcolor
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION setcolor (color)
      INTEGER*2 setcolor[FAR,C,ALIAS:"__setcolor"]
      INTEGER*2 color
      END

ОПИСАНИЕ

     Функция setcolor устанавливает текущий индекс  цвета  равным
значению  параметра color.  Параметр color маскируется, но всегда
внутри диапазона.  Текущий цвет используют следующие  графические
функции:    arc,   ellipse,  floodfill,  lineto,  outgtext,  pie,
rectangle и setpixel.

     Функция setcolor принимает  в  качестве  аргумента  значение
INTEGER*2, которое является индексом цвета.

     Умалчиваемый индекс цвета равен индексу  цвета  с  наивысшим
номером в текущей палитре.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращает предыдущий цвет.  В случае неудачи (использование
в текстовом режиме), setcolor возвращает -1.

СМ.ТАКЖЕ

     arc,ellipse,floodfill,getcolor,lineto,outgtext,pie,
     rectangle,selectpalette,setpixel

ПРИМЕР

     См.пример программы для setlinestyle.



-----------------------------------------------------------------
setfillmask
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO SUBROUTINE
     +setfillmask[FAR,C,ALIAS:"__setfillmask"] (mask)
      INTEGER*1 mask[FAR,REFERENCE](8)


                               369



      END

ОПИСАНИЕ

     Функция setfillmask устанавливает текущую маску  заполнения.
Маска  это массив 8x8, где каждый бит представляет пиксел.  Бит 1
устанавливает соответствующий пиксел в  текущий  цвет,  а  бит  0
оставляет  пиксел  нетронутым.  Маска повторяется по всей области
экрана.

     Если маска заполнения не задана (умолчанием является  маска,
в  которой  все  нули),  то  в  операциях заполнения используется
только текущий цвет.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращаемого значения нет.

СМ.ТАКЖЕ

     ellipse,floodfill,getfillmask,pie,rectangle

ПРИМЕР

      PROGRAM Fill

      INCLUDE 'FGRAPH.FI'
      INCLUDE 'FGRAPH.FD'

      INTEGER*1 style( 8,6 )/ #18,#18,#18,#18,#18,#18,#18,#18,
     +                        #08,#08,#08,#08,#08,#08,#08,#08,
     +                        #18,#00,#18,#18,#18,#00,#18,#18,
     +                        #00,#08,#00,#08,#08,#08,#08,#08,
     +                        #18,#18,#00,#18,#18,#00,#18,#18,
     +                        #08,#00,#08,#00,#08,#00,#08,#00 /

      INTEGER*2 oldstyle( 8 ) ! буфер для старого стиля
      INTEGER loop

      dummy2 = setvideomode( $MRES4COLOR )
      CALL getfillmask( oldstyle )
C
C     Рисует эллипс под несколькими прямоугольниками
C     в различном цвете.
C
      dummy2 = setcolor( 2 )
      dummy2 = ellipse( $GFILLINTERIOR, 120, 75, 200, 125 )
      dummy2 = setcolor( 3 )
      DO loop = 1, 6
C


                               370



C     Создает шесть прямоугольников
C
      CALL setfillmask( style( 1,loop ) )
      dummy2 = rectangle( $GFILLINTERIOR, loop*40+5, 90,
     +                  ( loop+1 )*40, 110 )
      END DO

      CALL setfillmask( oldstyle ) ! восстанавливает старый стиль
      READ (*,*)                   ! ждет нажатия ENTER
      dummy2 = setvideomode( $DEFAULTMODE )
      END

     Эта    программа    рисует    эллипс,    покрытый     шестью
прямоугольниками, каждый с различной маской заполнения.

     См.также пример программы для setlinestyle.


-----------------------------------------------------------------
setfont
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION setfont(options)
      INTEGER*2 setfont[FAR,C,ALIAS:"__f_setfont"]
      CHARACTER*(*) options[FAR,REFERENCE]
      END

ОПИСАНИЕ

     Функция setfont из набора зарегистрированных шрифтов находит
отдельный   шрифт,   который  имеет  характеристики,  заданные  в
параметре options.

     Если  шрифт  найден,  то  он  становится  текущим   шрифтом.
Текущий  шрифт  используется  во всех последующих вызовах функции
outgtext.  Может быть только один активный шрифт.

     Функция setfont ищет  в  списке  зарегистрированных  шрифтов
один, соответствующий заданным характеристикам.

     Аргумент  функции  состоит  из  буквенных   кодов,   которые
описывают  нужный  шрифт.   Коды  опций в параметре options можно
писать  заглавными  или  прописными  буквами  и  в   произвольном
порядке.






                               371



Опция         Описание
-----         --------
t'fontname'   Имя нужного шрифта.

hy            Выбирает высоту символов, где y это число пикселов.

wx            Выбирает ширины символов, где x это число пикселов.

f             Выбирает только шрифт с фиксированным интервалом
              (нельзя использовать с характеристикой p).

p             Выбирает только пропорциональный шрифт (нельзя
              использовать с характеристикой f).

v             Выбирает только шрифт с векторным отображением
              (нельзя использовать с характеристикой r).

r             Выбирает только шрифт с битовым отображением
              (нельзя использовать с характеристикой v).

b             Выбирает шрифт, который имеет наилучшее
              соответствие другим заданным параметрам.

nx            Выбирает шрифт с номером x, где x меньше или равен
              значению, возвращенному функцией registerfonts.

     Можно  задавать  столько  опций,  сколько   необходимо,   за
исключением  nx,  которая  должна  использоваться  в одиночестве.
Если заданы взаимоисключающие опции (например, пара f/p или r/v),
то  функция  setfont  игнорирует их.  Проверка на несовместимость
параметров, используемых с nx, не выполняется.

     В опции t'fontname' за именем опции "t" следует имя шрифта в
апострофах.   В  качестве  fontname  можно использовать следующие
шрифты:

Имя шрифта   Описание
----------   --------
Courier      Шрифт фиксированной ширины с битовым отображением
             с засечками.

Helv         Пропорциональный шрифт с битовым отображением без
             засечек.

Tms Rmn      Пропорциональный шрифт с битовым отображением с
             засечками.

Script       Пропорциональный шрифт с векторным отображением и
             наклонными символами, образованными хорошо
             сглаженными векторами.


                               372



Имя шрифта   Описание
----------   --------
Modern       Пропорциональный шрифт с векторным отображением без
             засечек.

Roman        Пропорциональный шрифт с векторным отображением с
             засечками.

     Опция "b" в поле options предписывает setfont  автоматически
выбрать  шрифт, который лучше всего соответствует другим заданным
характеристикам.

     Если задана опция b и зарегистрирован по крайней  мере  один
шрифт,  то  setfont всегда будет в состоянии выбрать один шрифт и
вернет 0 для обозначения успеха.

     При выборе  шрифта  setfont  использует  следующий  порядок,
переходя от высшего приоритета к низшему:

     1.  Высота в пикселах.

     2.  Начертание шрифта.

     3.  Ширина в пикселах.

     4.  Фиксированный или пропорциональный шрифт.

     Вы можете также задать ширину и высоту  шрифта  в  пикселах.
Если выбрано несуществующее значение и задана опция b, то setfont
будет выбирать ближайшее соответствие.

     Меньший размер шрифта имеет приоритет над большим  размером.
Если  в  setfont  заказано  Helv 12 с опцией b, а доступны только
Helv 10 и Helv 14, то setfont выберет Helv 10.

     Если вы задали параметр nx, то setfont  проигнорирует  любые
другие заданные опции и установит только шрифт с номером x.

     Если для высоты и ширины выбрано несуществующее значение, то
функция  setfont  для  шрифта с векторным отображением использует
коэффициент умножения, чтобы получить подходящий  размер  шрифта.
Это  автоматическое умножение не применяется, если задана опция r
(шрифт  с  растровым  отображением),  или   заказано   конкретное
начертание шрифта без опции b.

     ЗАМЕЧАНИЕ:   Шрифтовые  функции  влияют  только  на   вывод,
выполняемый  с  помощью  функции  outgtext;  ни  на  какие другие
функции  вывода  графической  библиотеки  Фортрана  использование
шрифтов не влияет.



                               373



ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращает 0 в случае успеха и -1 при ошибке.

     Ошибка имеет место, если запрос конкретного шрифта  неудачен
и   опция   b   не   была   задана,   или  если  шрифты  не  были
зарегистрированы.

СМ.ТАКЖЕ

     getfontinfo,getgtextextent,outgtext,registerfonts,
     unregisterfonts

ПРИМЕР

     См.пример программы для registerfonts.



-----------------------------------------------------------------
setlinestyle
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO SUBROUTINE
     +setlinestyle[FAR,C,ALIAS:"__setlinestyle"] (mask)
      INTEGER*2 mask
      END

ОПИСАНИЕ

     Функция  setlinestyle  устанавливает  маску  (стиль  линий),
используемую  для рисования линий.  Маска это 16-битовое число, в
котором каждый бит представляет пиксел в  рисуемой  линии.   Если
бит  равен 1, то соответствующий пиксел окрашивается цветом линии
(текущим цветом).  Если бит равен 0,  то  соответствующий  пиксел
остается  нетронутым.   Шаблон  повторяется  по всей длине линии.
Умалчиваемая  маска  равна  #FFFF  (сплошная   линия).    Функция
setlinestyle   не   изменяет   стили   для   дуг,   эллипсов  или
клинообразных фигур.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращаемого значения нет.

СМ.ТАКЖЕ

     getlinestyle,lineto,rectangle



                               374



ПРИМЕР

CC  FILL.FOR - иллюстрирует использование следующих функций:
CC             setlinestyle      setfillmask       setcolor
CC             getlinestyle      floodfill
CC
CC  Функция getfillmask не показана, но ее использование
CC  аналогично getlinestyle.

      INCLUDE  'FGRAPH.FI'
      INCLUDE  'FGRAPH.FD'

      INTEGER*1            fill(8)
      INTEGER*2            dummy, xinc, yinc, i,
     +                     irand, xwid, ywid, rseed
      INTEGER*4            ncolor
      REAL*4               rand
      RECORD /xycoord/     xy
      RECORD /videoconfig/ vc

C
C     Устанавливаем графический режим.
C
      IF( setvideomode( $MAXRESMODE ) .EQ. 0 )
     +   STOP 'Error:  cannot set graphics mode'
      CALL getvideoconfig( vc )

C
C     Масштабируем переменные для режима.
C
      xinc = vc.numxpixels / 8.0
      yinc = vc.numypixels / 8.0
      xwid = (xinc / 2.0) - 4.0
      ywid = (yinc / 2.0) - 4.0

C
C     Вытаскиваем генератор случайных чисел.
C
      CALL GETTIM( dummy, dummy, dummy, rseed)
      CALL SEED( rseed )

C
C     Рисуем эллипсы и линии различных рисунков.
C
      DO x = xinc, (vc.numxpixels - xinc), xinc
         DO y = yinc, (vc.numypixels - yinc), yinc
C
C           Выбираем случайным образом заполнение и цвет.
C           Массив FILL содержит случайные числа от 0 до 255.
C


                               375



            DO i = 1, 8
               CALL RANDOM( rand )
               fill(i) = INT1( rand * 256.0 )
            END DO

            CALL setfillmask( fill )
            irand  = rand * 256.0
            ncolor = MOD( irand, vc.numcolors ) + 1
            dummy  = setcolor( ncolor )
C
C           Рисуем эллипс и заполняем случайным цветом.
C
            dummy  = ellipse( $GBORDER, x-xwid, y-ywid, x+xwid,
     +                        y + ywid )
            CALL RANDOM( rand )
            irand  = rand * 256.0
            i      = ncolor
            ncolor = MOD( irand, vc.numcolors ) + 1
            dummy  = setcolor( ncolor )
            dummy  = floodfill( x, y, i )
C
C           Рисуем вертикальные и горизонтальные линии. Стиль
C           вертикальных линий отличается от стиля горизонтальных
C           линий. Поскольку линии различных стилей накладываются
C           друг на друга, то это создает эффект соединения
C           цветов и стилей.
C
            CALL RANDOM( rand )
            irand = rand * 256.0
            CALL setlinestyle( irand )
            CALL moveto( 0, y + ywid + 4, xy )
            dummy = lineto( vc.numxpixels - 1, y + ywid + 4 )
C
C           Получаем стиль линий, инвертируем биты и устанавливаем
C           другой стиль.
C
            CALL setlinestyle( 255 - getlinestyle() )
            CALL moveto( x + xwid + 4, 0, xy )
            dummy = lineto( x + xwid + 4, vc.numypixels - 1 )
         END DO
      END DO

      READ (*,*)
      dummy = setvideomode( $DEFAULTMODE )
      END

     Эта программа рисует на экране заполненные  овалы  и  линии.
Она  использует  разнообразные  рисунки  заполнения и стили линий
различных цветов.



                               376



-----------------------------------------------------------------
setpixel,setpixel_w
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION setpixel (x,y)
      INTEGER*2 setpixel[FAR,C,ALIAS:"__setpixel"]
      INTEGER*2 x,y
      END

      INTERFACE TO FUNCTION setpixel_w(wx,wy)
      INTEGER*2 setpixel_w[FAR,C,ALIAS:"__f_setpixel_w"]
      DOUBLE PRECISION wx,wy
      END

ОПИСАНИЕ

     Функции  setpixel  и  setpixel_w  устанавливают  в  заданной
позиции пиксел с текущим цветом.

     Функция setpixel устанавливает пиксел  с  текущим  цветом  в
точке (x,y) в координатах окна просмотра.

     Функция setpixel_w устанавливает пиксел с текущим  цветом  в
точке (wx,wy) в мировых координатах.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Функции setpixel и setpixel_w возвращают предыдущее значение
заданного  пиксела.   Если функция отработала неудачно (например,
точка лежит вне области отсечения), то она возвращает -1.

СМ.ТАКЖЕ

     getpixel,setcolor

ПРИМЕР

CC  FIGURE.FOR - иллюстрирует следующие графические функции
CC               рисования:
CC               setpixel   lineto     moveto     rectangle
CC               ellipse    arc        pie
CC
CC  Версии графических функций для окна (window) в мировых
CC  координатах (например, rectangle_w, ellipse_w и lineto_w)
CC  иллюстрируются в примерах WINDOW.FOR и MAGNIFY.FOR.

      INCLUDE  'FGRAPH.FI'
      INCLUDE  'FGRAPH.FD'


                               377



      INTEGER*2        dummy, x, y
      INTEGER*4        ncolor
      RECORD /xycoord/ xy

C
C     Находим графический режим.
C
C
      IF( setvideomode( $MAXRESMODE ) .EQ. 0 )
     +   STOP 'Error:  cannot set graphics mode'

      WRITE (*,*) ' Press ENTER to continue'

C
C     Рисуем пикселы.
C
      ncolor = 2
      dummy  = setcolor( ncolor )
      x      = 10
      DO y = 50, 89, 3
         dummy = setpixel( x, y )
         x     = x + 2
      END DO
      READ (*,*)
C
C     Рисуем линии.
C
      ncolor = ncolor + 1
      dummy  = setcolor( ncolor )
      x      = 60
      DO y = 50, 89, 3
         CALL moveto( x, y, xy )
         dummy = lineto( x + 20, y )
      END DO
      READ (*,*)
C
C     Рисуем прямоугольники.
C
      ncolor = ncolor + 1
      dummy  = setcolor( ncolor )
      x      = 110
      y      = 70
      dummy  = rectangle( $GBORDER,       x - 20, y - 20, x, y )
      dummy  = rectangle( $GFILLINTERIOR, x + 20, y + 20, x, y )
      READ (*,*)
C
C     Рисуем эллипсы.
C
      ncolor = ncolor + 1
      dummy  = setcolor( ncolor )


                               378



      x      = 160
      dummy  = ellipse( $GBORDER,       x - 20, y - 20, x, y )
      dummy  = ellipse( $GFILLINTERIOR, x + 20, y + 20, x, y )
      READ (*,*)
C
C     Рисуем дуги.
C
      ncolor = ncolor + 1
      dummy  = setcolor( ncolor )
      x      = 210
      dummy  = arc( x - 20, y - 20, x, y, x     , y - 10, x - 10, y )
      dummy  = arc( x + 20, y + 20, x, y, x + 10, y + 20, x + 20,
     +              y + 10 )
      READ (*,*)
C
C     Рисуем клинообразные фигуры.
C
      ncolor = ncolor + 1
      dummy  = setcolor( ncolor )
      x      = 260
      dummy  = pie( $GBORDER,       x - 20, y - 20, x, y, x     ,
     +              y - 10, x - 10, y      )
      dummy  = pie( $GFILLINTERIOR, x + 20, y + 20, x, y, x + 10,
     +              y + 20, x + 20, y + 10 )
      READ (*,*)
      dummy = setvideomode( $DEFAULTMODE )
      END

     Программа FIGURE.FOR рисует серии небольших фигур различными
цветами.



-----------------------------------------------------------------
settextcolor
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION settextcolor (index)
      INTEGER*2 settextcolor[FAR,C,ALIAS:"__settextcolor"]
      INTEGER*2 index
      END

ОПИСАНИЕ

     Функция  settextcolor  устанавливает  текущий  цвет  текста.
Значение  index  определяет  новый  индекс  цвета;  по  умолчанию
действует   значение,   равное   максимальному   индексу   цвета.
Процедура  settextcolor  устанавливает  цвет для функции outtext.


                               379



Она не влияет на цвет текста,  выводимого  оператором  WRITE  или
процедурой  outgtext,  - в этом случае для изменения цвета текста
используется функция setcolor.

     В цветном текстовом режиме вы можете задавать индекс цвета в
диапазоне  0-31.   Цвета  в  диапазоне  0-15 интерпретируются как
нормальные, а цвета в диапазоне 16-31 такие же,  но  текст  будет
мигающим.  Диапазон нормальных цветов показан ниже.

-----------------------------------------------------------------
Индекс Цвет                 Индекс Цвет
-----------------------------------------------------------------
  0    черный (black)          8   темно-серый (dark gray)
  1    синий (blue)            9   светло-синий (light blue)
  2    зеленый (green)        10   светло-зеленый (light green)
  3    голубой (cyan)         11   светло-голубой (light cyan)
  4    красный (red)          12   светло-красный (light red)
  5    фиолетовый (magenta)   13   светло-фиолет. (light magenta)
  6    коричневый (brown)     14   желтый (yellow)
  7    белый (white)          15   ярко-белый (bright white)
-----------------------------------------------------------------

     В каждом  текстовом  режиме,  включая  монохромный,  функция
getvideoconfig возвращает значение 32 для числа доступных цветов.
Значение 32  обозначает  диапазон  значений  (0-31),  принимаемых
функцией settextcolor.  Сюда входят 16 нормальных цветов (0-15) и
16 мигающих цветов (16-31).  Для  того,  чтобы  выбрать  мигающий
текст, добавьте 16 к нормальному значению текста.  На монохромных
мониторах некоторые значения цветов отображаются одинаково.   Но,
поскольку мигание выбирается точно так же, то текстовый режим для
монохромных мониторов использует тот же диапазон (0-31), как и  в
цветном текстовом режиме.

     Эта функция доступна и в OS/2.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращает предыдущее значение индекса цвета текста.

СМ.ТАКЖЕ

     gettextcolor,outtext

ПРИМЕР

     См.пример программы для gettextcolor.






                               380



-----------------------------------------------------------------
settextcursor
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION settextcursor (attr)
      INTEGER*2 settextcursor[FAR,C,ALIAS:"__settextcursor"]
      INTEGER*2 attr
      END

ОПИСАНИЕ

     Функция  settextcursor   устанавливает   форму   курсора   в
зависимости   от  значения  атрибута  attr.   Старший  байт  attr
определяет начальную линию курсора.  Младший байт attr определяет
конечную  линию  курсора.  Функцию settextcursor использует такой
же формат, как и процедуры  BIOS  при  установке  курсора.   Ниже
показаны значения для атрибута курсора.

Атрибут        Форма курсора
-------        -------------
#0707          Символ подчеркивания
#0007          Полноблочный курсор
#0607          Двойной символ подчеркивания
#2000          Нет курсора

     Эта функция доступна в OS/2.   Обратите  внимание,  что  эта
функция работает только в текстовых видеорежимах.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращает предыдущее значение атрибута  курсора  или  -1  в
случае   ошибки,  например,  при  вызове  функции  в  графическом
экранном режиме.

СМ.ТАКЖЕ

     displaycursor,gettextcursor

ПРИМЕР

CC  CURSOR.FOR - иллюстрирует следующие функции для работы
CC               с курсором:
CC               settextcursor  gettextcursor  displaycursor

      INCLUDE  'FGRAPH.FI'
      INCLUDE  'FGRAPH.FD'

      INTEGER*2            dummy, oldcursor, newcursor,


                               381



     +                     curs_start, curs_end, block
      CHARACTER*40         str
      RECORD /rccoord/     curpos
      RECORD /videoconfig/ vc

C
C     Спасаем старую форму курсора и делаем его видимым.
C
      CALL clearscreen( $GCLEARSCREEN )
      oldcursor = gettextcursor()
      dummy     = displaycursor( $GCURSORON )
      CALL settextposition( 1, 1, curpos )
      CALL outtext( 'Press ENTER to continue . . .' )
C
C     Изменяем форму курсора. Цветной курсор использует
C     растровые линии 0-7, монохромный - линии 0-13.
C
      CALL getvideoconfig( vc )
      block = 7
      IF( vc.mode .EQ. $TEXTMONO ) block = 13
      curs_start = 0
      DO curs_end = block, 0, -1
         CALL settextposition( 10, 1, curpos )
         WRITE (str, 9000) curs_start, curs_end
         CALL outtext( str )
         newcursor = (curs_start * 256) + curs_end
         dummy     = settextcursor( newcursor )
         READ (*,*)
         curs_start = curs_start + 1
      END DO

      WRITE (str, '(A13)') 'Cursor off:  '
      CALL settextposition( 12, 1, curpos )
      CALL outtext( str )
      dummy = displaycursor( $GCURSOROFF )
      READ (*,*)
      WRITE (str, '(A13)') 'Cursor on :  '
      CALL settextposition( 13, 1, curpos )
      CALL outtext( str )
      dummy = settextcursor( block )
      dummy = displaycursor( $GCURSORON )
      READ (*,*)
C
C     Восстанавливаем первоначальную форму курсора.
C
      dummy = settextcursor( oldcursor )
      CALL clearscreen( $GCLEARSCREEN )

 9000 FORMAT ( 'Start line:', I4, 8x, 'Endline:', I4, 3x )



                               382



      END

     Программа CURSOR.FOR показывает действие изменения начальной
и  конечной линий для курсора, а также включение и выключение его
видимости.



-----------------------------------------------------------------
settextposition
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO SUBROUTINE
     +settextposition[FAR,C,ALIAS:"__f_settextposition"]
     +(row,col,s)
      INTEGER*2 row,col
      STRUCTURE/rccoord/
        INTEGER*2 row
        INTEGER*2 col
      END STRUCTURE
      RECORD/rccoord/s[FAR,REFERENCE]
      END

ОПИСАНИЕ

     Эта функция перемещает текущую  позицию  текста  в  заданную
точку  экрана  (row,col).   Последующий текст, выводимый функцией
outtext (а также стандартными операторами ввода-вывода,  например
PRINT), будет начинаться с этой точки.

     Предыдущая  позиция  текста  возвращается  в  переменную  s,
которая является структурой rccoord, определенной в FGRAPH.FD.

     Эта функцию доступна также в OS/2.

     ПРЕДУПРЕЖДЕНИЕ:  Оператор WRITE  выводит  на  экран  символы
возврата  каретки  (CR)  и  перевода строки (LF) в начале первого
оператора ввода-вывода,  следующего  за  оператором  WRITE.   Это
может   вызвать  непредсказуемое  позиционирование  текста,  если
графические процедуры settextposition  и  outtext  смешиваются  с
оператором   WRITE.    От   этого   можно   избавиться,   если  в
соответствующем операторе FORMAT использовать дескриптор  формата
\ (обратный слэш), подавляющий CR-LF.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращаемого значения нет.



                               383



СМ.ТАКЖЕ

     gettextposition,outtext,settextwindow

ПРИМЕР

     См.пример программы для setviewport.



-----------------------------------------------------------------
settextrows
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION settextrows (rows)
      INTEGER*2 settextrows[FAR,C,ALIAS:"__settextrows"]
      INTEGER*2 rows
      END

ОПИСАНИЕ

     Функция  settextrows  определяет  число   строк   текста   в
текстовых  режимах, при наличии аппаратных средств (например, VGA
или  EGA),  которые  поддерживают  43-  или  50-строчные  режимы.
Константа  $MAXTEXTROWS,  заданная  в качестве аргумента rows при
вызове этой функции, определяет выбор доступного числа строк:   в
текстовом  режиме  50  строк  для  VGA и 43 в EGA.  В графических
режимах, поддерживающих 30 или  60  строк,  выбирается  60.   Эта
функция доступна также в OS/2.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращает число  установленных  строк  или  0  при  наличии
ошибки.

СМ.ТАКЖЕ

     getvideoconfig,setvideomode,setvideomoderows

ПРИМЕР

CC  SETROWS.FOR - иллюстрирует использование settextrows.

      INCLUDE  'FGRAPH.FI'
      INCLUDE  'FGRAPH.FD'

      INTEGER*2    rows
      CHARACTER*2  arg


                               384



C
C     Получает аргумент командной строки: 25, 43, or 50.
C
      CALL GETARG( 1, arg, 2 )
      rows = 0
      IF( arg .EQ. '25' ) rows = 25
      IF( arg .EQ. '43' ) rows = 43
      IF( arg .EQ. '50' ) rows = 50
C
C     Удостоверимся, что новое число строк действительно.
C
      IF( (rows .EQ. 0) .OR. (settextrows( rows ) .NE. rows) ) THEN
         WRITE (*,*) 'Syntax: SETROWS [ 25 | 43 | 50 ]'
         STOP 01
      END IF
C
C     Возвращаем 0 при успехе.
C
      STOP 00
      END

     Эта  программа  принимает  аргумент   командной   строки   и
проверяет,  что  заданнов  число строк действительно для текущего
дисплея.



-----------------------------------------------------------------
settextwindow
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO SUBROUTINE
     +settextwindow[FAR,C,ALIAS:"__settextwindow"] (r1,c1,r2,c2)
      INTEGER*2 r1,c1
      INTEGER*2 r2,c2
      END

ОПИСАНИЕ

     Функция settextwindow определяет окно в координатах строк  и
столбцов,  в  котором  будет отображаться весь текстовый вывод на
экран.   Аргументы  (r1,c1)   определяют   верхний   левый   угол
текстового  окна,  а  аргументы  (r2,c2) определяют нижний правый
угол этого окна.

     Текст выводится в окно сверху  вниз.   Если  текстовое  окно
заполняется, то строки начинают сдвигаться в окне снизу вверх.



                               385



     ЗАМЕЧАНИЕ:  Эта функция не влияет на вывод текста с  помощью
процедуры outgtext - в этом случае для управления областью вывода
используется функция setviewport.

     Эта подпрограмма доступна также в OS/2.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращаемого значения нет.

СМ.ТАКЖЕ

     gettextposition,outtext,settextposition

ПРИМЕР

     См.пример программы для setvideomoderows.



-----------------------------------------------------------------
setvideomode
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION setvideomode (mode)
      INTEGER*2 setvideomode[FAR,C,ALIAS:"__setvideomode"]
      INTEGER*2 mode
      END

ОПИСАНИЕ

     Функция    setvideomode     выбирает     экранный     режим,
соответствуюший   конкретной   конфигурации   аппаратура/дисплей.
Аргумент mode может быть равен одной из  символических  констант,
показанных ниже в таблице R.5 и определенных в FGRAPH.FD.

     $MAXCOLORMODE  и  $MAXRESMODE  в  аргументе  mode   выбирают
графический  режим  с  максимальным  числом  цветов или наивысшим
разрешением, соответственно.  Для  адаптеров,  которые  не  имеют
графических  режимов,  эти  константы  не  срабатывают.   Ниже  в
таблице R.6 показаны режимы, выбираемые константами $MAXCOLORMODE
и $MAXRESMODE для различных комбинаций адаптер/монитор.

     В  режиме  $HERCMONO   поддерживается   только   монохромные
(двухцветные)  текст  и графика.  Разрешение экрана равно 720x348
пикселов.  Размерность для текста 80 столбцов  на  25  строк  при
размере  ячейки  для  символа 9x14.  Две нижних растровых линии в
строке 25 не видны.


                               386



     Перед   выполнением   программы   вы    должны    установить
Hercules-драйвер  MSHERC.COM.   Для  загрузки  драйвера  наберите
MSHERC.  Эта можно сделать из файла AUTOEXEC.BAT.

     Если вы используете и монохромную плату Hercules  и  цветную
видеоплату, то установите MSHERC.COM с опцией H(/HALF).  Опция /H
заставляет драйвер использовать одну графическую страницу  вместо
двух.   Это  предотвращает  попытку  использования одной и той же
памяти двумя видеоплатами.   Если  вы  используете  только  плату
Hercules, то не должны задавать опцию /H.  Более подробно вопросы
совместимости изложены  в  руководстве  по  аппаратным  средствам
Hercules.

     Эта функция доступна также в OS/2.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     При успешном срабатывании эта функция возвращает число строк
текста.    При   наличии   ошибки   (если   выбранный   режим  не
поддерживается  текущей  аппаратной  конфигурацией)  эта  функция
возвращает 0.

СМ.ТАКЖЕ

     getvideoconfig

ПРИМЕР

     См.пример программы для setvideomoderows.

Таблица R.5  Символические константы для экранного режима
-----------------------------------------------------------------
                   1               2           3              4
Режим           Тип          Размер       Цвета        Адаптер
-----------------------------------------------------------------
$DEFAULTMODE    Аппаратное   Аппаратное   Аппаратное   Аппаратное
                умолчание    умолчание    умолчание    умолчание
$TEXTBW40       M/T           40x25       16           CGA
$TEXTC40        C/T           40x25       16           CGA
$TEXTBW80       M/T           80x25       16           CGA
$TEXTC80        C/T           80x25        6           CGA
$MRES4COLOR     C/G          320x200       4           CGA
$MRESNOCOLOR    M/G          320x200       4           CGA
$HRESBW         M/G          640x200       2           CGA
$TEXTMONO       M/T           80x25        1           MDPA
$HERCMONO       Hercules     --           --           HGC
                graphics
$MRES16COLOR    C/G          320x200      16           EGA
$HRES16COLOR    C/G          640x200      16           EGA
-----------------------------------------------------------------


                               387



Таблица R.5  Символические константы для экранного режима
-----------------------------------------------------------------
                   1               2           3              4
Режим           Тип          Размер       Цвета        Адаптер
-----------------------------------------------------------------
$ERESNOCOLOR    M/T          640x350       1           EGA
$ERESCOLOR      C/G          640x350      64           EGA
$VRES2COLOR     C/G          640x480       2           VGA
$VRES16COLOR    C/G          640x480      16           VGA
$MRES256COLOR   C/G          320x200      256          VGA
$ORESCOLOR      C/G          640x400      1 из 16      Olivetti
                                                       color
                                                       graphics
$MAXCOLORMODE   C/G          См.табл.R.6  Максимум     CGA
$MAXRESMODE     C/G          Максимум     См.табл.R.6  CGA
-----------------------------------------------------------------
1. M означает монохромный, C - цветной вывод, Т - текст,
   G - генерация графики.
2. Для текстовых режимов размер дан в символах (строки x столбцы).
   Для графических режимов размер дан в пикселах (гориз. x верт.).
3. Для монохромных дисплеев число цветов есть число оттенков
   серого.
4. Адаптеры: IBM (и совместимые) Monochrome Adapter (MDPA), Color
   Graphics Adapter (CGA), Enhanced Graphics Adapter (EGA), Video
   Graphics Array (VGA), Hercules-compatible adapter и Olivetti-
   compatible adapter.


Таблица R.6  Режимы, выбираемые при задании $MAXCOLORMODE и
             $MAXRESMODE
-----------------------------------------------------------------
Адаптер/Монитор       $MAXCOLORMODE          $MAXRESMODE
-----------------------------------------------------------------
MDPA                  Ошибка                 Ошибка
HGC                   $HERCMONO              $HERCMONO
CGA Цветной           $MRES4COLOR            $HRESBW
CGA Нецветной *       $MRESNOCOLOR           $HRESBW
OCGA                  $MRES4COLOR            $ORESCOLOR
OEGA Цветной          $ERESCOLOR             $ORESCOLOR
EGA Цветной 256K      $HRES16COLOR           $HRES16COLOR
EGA Цветной 64K       $HRES16COLOR           $HRES16COLOR
EGA > 256K            $ERESCOLOR             $ERESCOLOR
EGA > 64K             $HRES16COLOR           $ERESCOLOR
EGA Моно              $ERESNOCOLOR           $ERESNOCOLOR
MCGA                  $MRES256COLOR          $VRES2COLOR
VGA/OVGA              $MRES256COLOR          $VRES16COLOR
-----------------------------------------------------------------
* Цветной монитор предполагается, если начальным режимом были
  текстовые режимы $TEXTC80, $TEXTC40 или графический режим.
  Составной или другой монохромный CGA-монитор предполагается,


                               388



  если начальным текстовым режимом были $TEXTBW80 или $TEXTBW40.

     ЗАМЕЧАНИЕ:   Здесь  описаны  только  стандартные  аппаратные
средства,  но мониторы, совместимые с IBM, Hercules или Olivetti,
также работают указанным образом.



-----------------------------------------------------------------
setvideomoderows
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION setvideomoderows (mode,rows)
      INTEGER*2 setvideomoderows[FAR,C,ALIAS:"__setvideomoderows"]
      INTEGER*2 mode
      INTEGER*2 rows
      END

ОПИСАНИЕ

     Функция  setvideomoderows  выбирает   экранный   режим   для
определенной    комбинации    аппаратура/дисплей.     Опции   для
символической константы mode (экранный режим) даны на  справочной
странице для setvideomode.

     Аргумент rows определяет число строк текста, которое  должно
использоваться  в  текстовом  режиме.   При задании для аргумента
rows константы  $MAXTEXTROWS  выбирается  максимальное  доступное
число  строк.   В текстовом режиме это число равно 50 строкам для
VGA, 43 для EGA и 25 для всех  других.   В  графических  режимах,
которые поддерживают 30 или 60 строк, это число равно 60 строкам.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращает установленное число строк.  Функция возвращает 0,
если имеет место ошибка (например, если режим не поддерживается).

СМ.ТАКЖЕ

     getvideoconfig,settextrows,setvideomode

ПРИМЕР

CC  MODES.FOR - иллюстрирует использование следующих функций:
CC              setvideomoderows   setvideomode   getvideoconfig
CC              settextwindow      outtext
CC
CC  См. TEXT.FOR для другого использования outtext.


                               389



      INCLUDE  'FGRAPH.FI'
      INCLUDE  'FGRAPH.FD'

      PARAMETER            ( NUM_ROWS =  5 )
      PARAMETER            ( NUM_MODE = 17 )

      INTEGER*2              dummy, irow, x, y
      INTEGER*2              modes(NUM_MODE), rows(NUM_ROWS)
      CHARACTER*12           names(NUM_MODE), str
      RECORD / videoconfig / vc

      DATA modes / $TEXTBW40     ,  $TEXTC40     ,  $TEXTBW80    ,
     +             $TEXTC80      ,  $MRES4COLOR  ,  $MRESNOCOLOR ,
     +             $HRESBW       ,  $TEXTMONO    ,  $HERCMONO    ,
     +             $MRES16COLOR  ,  $HRES16COLOR ,  $ERESNOCOLOR ,
     +             $ERESCOLOR    ,  $VRES2COLOR  ,  $VRES16COLOR ,
     +             $MRES256COLOR ,  $ORESCOLOR   /

      DATA names / '    TEXTBW40', '     TEXTC40', '    TEXTBW80',
     +             '     TEXTC80', '  MRES4COLOR', ' MRESNOCOLOR',
     +             '      HRESBW', '    TEXTMONO', '    HERCMONO',
     +             ' MRES16COLOR', ' HRES16COLOR', ' ERESNOCOLOR',
     +             '   ERESCOLOR', '  VRES2COLOR', ' VRES16COLOR',
     +             'MRES256COLOR', '   ORESCOLOR' /

      DATA rows  / 60, 50, 43, 30, 25 /

      dummy = displaycursor( $GCURSOROFF )
C
C     Проверка каждого режима.
C
      DO i = 1, NUM_MODE
         DO j = 1, NUM_ROWS
C
C           Проверка каждого возможного числа строк.
C
            irow = setvideomoderows( modes(i), rows(j) )
            IF( ( irow .EQ. 0 )  .OR.  (rows(j) .NE. irow) ) THEN
               GOTO 100
            ELSE
               CALL getvideoconfig( vc )
               y = (vc.numtextrows - 12) / 2
               x = (vc.numtextcols - 25) / 2
            END IF
C
C           Использование текстового окна для вывода в
C           середину экрана.
C
            CALL settextwindow( y, x, vc.numtextrows - y,
     +                          vc.numtextcols - x - 2 )


                               390



C
C           Выводим всю информацию на экран.
C
            CALL outtext( 'Video mode:  ' // names(i) )
            WRITE (str, '(I12)') vc.numxpixels
            CALL outtext( 'X pixels:    ' // str )
            WRITE (str, '(I12)') vc.numypixels
            CALL outtext( 'Y pixels:    ' // str )
            WRITE (str, '(I12)') vc.numtextcols
            CALL outtext( 'Text columns:' // str )
            WRITE (str, '(I12)') vc.numtextrows
            CALL outtext( 'Text rows:   ' // str )
            WRITE (str, '(I12)') vc.numcolors
            CALL outtext( 'Colors:      ' // str )
            WRITE (str, '(I12)') vc.bitsperpixel
            CALL outtext( 'Bits/pixel:  ' // str )
            WRITE (str, '(I12)') vc.numvideopages
            CALL outtext( 'Video pages: ' // str )
            WRITE (str, '(I12)') vc.mode
            CALL outtext( 'Mode:        ' // str )
            WRITE (str, '(I12)') vc.adapter
            CALL outtext( 'Adapter:     ' // str )
            WRITE (str, '(I12)') vc.monitor
            CALL outtext( 'Monitor:     ' // str )
            WRITE (str, '(I12)') vc.memory
            CALL outtext( 'Memory:      ' // str )

            READ (*,*)
  100    END DO
      END DO

      dummy = displaycursor( $GCURSORON )
      dummy = setvideomode( $DEFAULTMODE )
      END

     Программа   MODES.FOR   демонстрирует    каждую    возможную
комбинацию режимов и строк.



-----------------------------------------------------------------
setvieworg
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO SUBROUTINE
     +setvieworg[FAR,C,ALIAS:"__f_setvieworg"](x,y,s)
      INTEGER*2 x,y
      STRUCTURE/xycoord/


                               391



        INTEGER*2 xcoord
        INTEGER*2 ycoord
      END STRUCTURE
      RECORD/xycoord/s[FAR,REFERENCE]
      END

ОПИСАНИЕ

     Функция setvieworg перемещает начало системы координат  окна
просмотра  (0,0)  в  физическую  точку  (x,y).   Все другие точки
системы  координат  окна  просмотра   перемещаются   в   том   же
направлении и на то же расстояние.

     В переменную s (структура xycoord, определенная в FGRAPH.FD)
возвращаются   физические   координаты  предыдущего  начала  окна
просмотра.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращаемого значения нет.

СМ.ТАКЖЕ

     getphyscoord,getviewcoord,getwindowcoord,setcliprgn,
     setviewport

ПРИМЕР

CC  WINDOW.FOR - иллюстрирует использование окон и координатных
CC               систем с помощью следующих функций:
CC               setviewport   setvieworg    setcliprgn
CC               setwindow     rectangle     rectangle_w
CC               ellipse       ellipse_w     clearscreen
CC
CC  Использование функций, оканчивающихся на _w, здесь не
CC  показано, но аналогично использованию rectangle_w и ellipse_w.

      INCLUDE  'FGRAPH.FI'
      INCLUDE  'FGRAPH.FD'

      INTEGER*2              dummy, xhalf, yhalf, xquar, yquar
      DOUBLE PRECISION       x_upleft,y_upleft,x_botrght,y_botrght
      RECORD / xycoord /     xy
      RECORD / videoconfig / vc

C
C     Находим графический режим.
C
      IF( setvideomode( $MAXRESMODE ) .EQ. 0 )
     +   STOP 'Error:  cannot set graphics mode'


                               392



      CALL getvideoconfig( vc )

      xhalf = vc.numxpixels / 2
      yhalf = vc.numypixels / 2
      xquar = xhalf / 2
      yquar = yhalf / 2

C
C     Первое окно - целые физические координаты
C
      CALL setviewport( 0, 0, xhalf - 1, yhalf - 1 )
      dummy = setcolor( 2 )
      dummy = rectangle( $GBORDER, 0, 0, xhalf - 1, yhalf - 1 )
      dummy = setcolor( 1 )
      dummy = ellipse( $GFILLINTERIOR, xquar / 4, yquar / 4,
     +                 xhalf - (xquar / 4), yhalf - (yquar / 4) )
      READ (*,*)
      CALL clearscreen( $GVIEWPORT )
      dummy = rectangle( $GBORDER, 0, 0, xhalf - 1, yhalf - 1 )

C
C     Второе окно - целые мировые координаты с областью отсечения
C
      CALL setcliprgn( xhalf, 0, vc.numxpixels, yhalf )
      CALL setvieworg( xhalf + xquar - 1, yquar - 1, xy )
      dummy = setcolor( 3 )
      dummy = rectangle( $GBORDER, -xquar + 1, -yquar + 1, xquar,
     +                   yquar )
      dummy = setcolor( 2 )
      dummy = ellipse( $GFILLINTERIOR, (-xquar * 3) / 4,
     +                 (-yquar * 3) / 4, (xquar * 3) / 4,
     +                 (yquar * 3) / 4 )
      READ (*,*)
      CALL clearscreen( $GVIEWPORT )
      dummy = rectangle( $GBORDER, -xquar + 1, -yquar + 1, xquar,
     +                   yquar )

C
C     Третье окно
C
      CALL setviewport( xhalf, yhalf, vc.numxpixels - 1,
     +                  vc.numypixels - 1 )
      dummy = setwindow( .FALSE., -4.0, -5.0, 4.0, 5.0 )
      dummy = setcolor( 4 )
      dummy = rectangle_w( $GBORDER, -4.0, -5.0, 4.0, 5.0 )
      dummy = setcolor( 3 )
      dummy = ellipse_w( $GFILLINTERIOR, -3.0, -3.5, 3.0, 3.5 )
      READ (*,*)
      CALL clearscreen( $GVIEWPORT )
      dummy = rectangle_w( $GBORDER, -4.0, -5.0, 4.0, 5.0 )


                               393



C
C     Четвертое окно
C
      CALL setviewport( 0, yhalf, xhalf - 1, vc.numypixels - 1 )
      dummy = setwindow( .FALSE., -4.0, -5.0, 4.0, 5.0 )
      x_upleft  = -4.0
      y_upleft  = -5.0
      x_botrght =  4.0
      y_botrght =  5.0
      dummy = setcolor( 5 )
      dummy = rectangle_w( $GBORDER, x_upleft, y_upleft,
     +                     x_botrght, y_botrght )
      x_upleft  = -3.0
      y_upleft  = -3.5
      x_botrght =  3.0
      y_botrght =  3.5
      dummy = setcolor( 4 )
      dummy = ellipse_w( $GFILLINTERIOR, x_upleft, y_upleft,
     +                   x_botrght, y_botrght )

      READ (*,*)
      dummy = setvideomode( $DEFAULTMODE )
      END

     Программа  WINDOW.FOR  рисует  несколько   окон,   используя
различные методы и опции для каждого окна.



-----------------------------------------------------------------
setviewport
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO SUBROUTINE
     +setviewport[FAR,C,ALIAS:"__setviewport"] (x1,y1,x2,y2)
      INTEGER*2 x1,y1
      INTEGER*2 x2,y2
      END

ОПИСАНИЕ

     Функция   setviewport   переопределяет   графическое    окно
просмотра.   Функция  setviewport  определяет  область  отсечения
точно так же, как setcliprgn,  после  чего  устанавливает  начало
координат   окна   просмотра   в   верхний  левый  угол  области.
Физические точки (x1,y1) и (x2,y2) это  верхний  левый  и  нижний
правый    углы    прямоугольной    области    отсечения.    Любое
преобразование окна, выполняемое  с  помощью  функции  setwindow,


                               394



применимо только к окну просмотра, а не ко всему экрану.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращаемого значения нет.

СМ.ТАКЖЕ

     setcliprgn,setvieworg,setwindow

ПРИМЕР

CC  MAGNIFY.FOR - иллюстрирует преобразование между координатными
CC                системами окна просмотра и окна мировых
CC                координат с помощью следующих функций:
CC                setviewport    getviewcoord_w   getviewcoord
CC                getphyscoord   getwindowcoord   setwindow
CC                rectangle      rectangle_w      settextposition
CC                moveto         lineto
CC
CC  Функции, оканчивающиеся на _w, хотя и не показаны, действуют
CC  аналогично функции rectangle_w.                              

      INCLUDE  'FGRAPH.FI'
      INCLUDE  'FGRAPH.FD'

      INTEGER*2              dummy, rseed, j, k, m, n
      INTEGER*2              coord(3,2,2), fill(2)
      INTEGER*4              i
      REAL*4                 rand
      DOUBLE PRECISION       x(2), y(2)
      CHARACTER*18           text
      RECORD / xycoord  /    xy, xy1
      RECORD / wxycoord /    wxy
      RECORD / rccoord  /    curpos
      RECORD / videoconfig / vc

      DATA text / 'magnification:  1x' /
      DATA fill / $GFILLINTERIOR, $GBORDER /

C
C     Находим графический режим.
C
      IF( setvideomode( $MAXRESMODE ) .EQ. 0 )
     +   STOP 'Error:  cannot set graphics mode'
      CALL getvideoconfig( vc )

C
C     Определяем физические (пиксельные) координаты для
C     окон 1, 2 и 3.


                               395



C
      coord(1,1,1) = vc.numxpixels * 3 / 16
      coord(1,1,2) = vc.numypixels * 7 / 32
      coord(1,2,1) = coord(1,1,1) + vc.numxpixels / 8
      coord(1,2,2) = coord(1,1,2) + vc.numypixels / 16
      coord(2,1,1) = vc.numxpixels * 9 / 16
      coord(2,1,2) = vc.numypixels * 5 / 32
      coord(2,2,1) = coord(2,1,1) + vc.numxpixels * 3 / 8
      coord(2,2,2) = coord(2,1,2) + vc.numypixels * 3 / 16
      coord(3,1,1) = 0
      coord(3,1,2) = vc.numypixels / 2
      coord(3,2,1) = vc.numxpixels - 1
      coord(3,2,2) = vc.numypixels - 1

C
C     Соединаем окна линиями.
C
      dummy = setcolor( 4 )
      DO i = 1, 2
         DO j = 1, 2
            DO k = 1, 2
               CALL moveto( coord(i,j,1), coord(i,k,2), xy )
               dummy = lineto( coord(i + 1,j,1), coord(i+1,k,2) )
            END DO
         END DO
      END DO

C
C     Помечаем окна и обрамляем прямоугольниками.
C
      DO i = 1, 3
         dummy  = setcolor( i )
         row    = ( coord(i,1,2) * 25 ) / vc.numypixels
         column = ( coord(i,1,1) * 80 ) / vc.numxpixels
         CALL settextposition( row, column, curpos )
         CALL outtext( text )
         text(17:17) = '3'
         IF( i .EQ. 2 ) text(17:17) = '8'
         CALL setviewport(  coord(i,1,1), coord(i,1,2) ,
     +                      coord(i,2,1), coord(i,2,2) )
         CALL getviewcoord( coord(i,1,1), coord(i,1,2), xy  )
         CALL getviewcoord( coord(i,2,1), coord(i,2,2), xy1 )
         dummy = rectangle( $GBORDER, xy.xcoord, xy.ycoord,
     +                      xy1.xcoord, xy1.ycoord )
      END DO

C
C     Вытаскиваем генератор случайных чисел.
C
      CALL GETTIM( dummy, dummy, dummy, rseed )


                               396



      CALL SEED( rseed )
C
C     Получаем случайные мировые координаты (x,y) для
C     прямоугольников, где x и y находятся между 0 и 1000.
C
      DO i = 8, 15
         dummy = setcolor( i )
         CALL RANDOM( rand )
         x(1)  = rand * 980.0
         x(2)  = rand * ( 999.0 - x(1) ) + x(1)
         CALL RANDOM( rand )
         y(1)  = rand * 980.0
         y(2)  = rand * ( 999.0 - y(1) ) + y(1)
         k     = rand + 1.5

C
C        Отображаем прямоугольники в нормальном и увеличенном
C        виде.
C
         DO j = 1, 3
            CALL setviewport( coord(j,1,1), coord(j,1,2) ,
     +                        coord(j,2,1), coord(j,2,2) )
            dummy = setwindow( .TRUE., 0.0, 0.0, 1000.0, 1000.0 )
            dummy = rectangle_w( fill(k), x(1), y(1), x(2), y(2) )
C
C           В последнем окне делаем стороны прямоугольников
C           шириной 2 пиксела, охватывая каждый незаполненный
C           прямоугольник другим прямоугольником. Преобразуем
C           мировые координаты (x,y) в физические координаты,
C           настраиваем и транслируем обратно в мировые координаты.
C
            IF( (j .EQ. 3)  .AND.  (k .EQ. 2) ) THEN
               m = -1
               DO n = 1, 2
                  CALL getviewcoord_w( x(n), y(n), xy )
                  CALL getphyscoord( xy.xcoord, xy.ycoord, xy )
                  CALL getviewcoord( xy.xcoord+m,xy.ycoord+m,xy )
                  CALL getwindowcoord( xy.xcoord, xy.ycoord, wxy)
                  x(n) = wxy.wx
                  y(n) = wxy.wy
                  m    = 1
               END DO
            dummy = rectangle_w( fill(k), x(1), y(1), x(2), y(2))
            END IF
         END DO
      END DO

      READ (*,*)
      dummy = setvideomode( $DEFAULTMODE )
      END


                               397



     Транслируя рисунок между мировыми кординатами и координатами
окна просмотра, программа MAGNIFY.FOR увеличивает содержимое окна
мировых координат.

     См.также пример программы для setvieworg.



-----------------------------------------------------------------
setvisualpage
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION setvisualpage (page)
      INTEGER*2 setvisualpage[FAR,C,ALIAS:"__setvisualpage"]
      INTEGER*2 page
      END

ОПИСАНИЕ

     Функция setvisualpage выбирает текущую видимую  страницу  на
аппаратных  средствах,  имеющих  адаптер EGA или VGA и достаточно
памяти  для  поддержки  многоэкранных  страниц.   Аргумент   page
определяет  текущую  видимую  страницу.   По  умолчанию действует
номер страницы 0.

     Эта функция доступна также в OS/2.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращает предыдущий номер видимой  страницы.   При  ошибке
возвращает отрицательное значение.

СМ.ТАКЖЕ

     getactivepage,getvisualpage,setactivepage,setvideomode

ПРИМЕР

     См.пример программы для getactivepage.



-----------------------------------------------------------------
setwindow
-----------------------------------------------------------------

ИНТЕРФЕЙС



                               398



      INTERFACE TO FUNCTION setwindow (finvert,wx1,wy1,wx2,wy2)
      INTEGER*2 setwindow[FAR,C,ALIAS:"__setwindow"]
      LOGICAL*2 finvert
      DOUBLE PRECISION wx1,wy1
      DOUBLE PRECISION wx2,wy2
      END

ОПИСАНИЕ

     Функция setwindow определяет  окно  в  мировых  координатах,
ограниченное   заданным   прямоугольником.   Аргументы  (wx1,wy1)
определяют верхний левый  угол  окна,  а  аргументы  (wx2,wy2)  -
нижний правый угол окна.

     Аргумент finvert  определяет  направление  координат.   Если
finvert  равно  .TRUE.,  то  ось  y направлена снизу вверх экрана
(картезианские координаты), а если finvert равна .FALSE., то  ось
y направлена сверху вниз экрана (экранные координаты).

     Любое преобразование окна,  выполненное  с  помощью  функции
setwindow, действует только на окно просмотра (viewport), а не на
весь экран.

     Если wx1 равно wx2 или wy1  равно  wy2,  то  функция  вернет
ошибку.

     ЗАМЕЧАНИЕ:  Эта функция  не  влияет  на  вывод,  выполняемый
шрифтовой функцией outgtext.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     При  успехе  возвращает  ненулевое  значение,   при   ошибке
(например, не в графическом режиме) возвращает 0.

СМ.ТАКЖЕ

     setviewport

ПРИМЕР

     См.пример программы для setvieworg и setviewport.



-----------------------------------------------------------------
unregisterfonts
-----------------------------------------------------------------

ИНТЕРФЕЙС



                               399



      INTERFACE TO SUBROUTINE
     +unregisterfonts[FAR,C,ALIAS:"__unregisterfonts"]()
      END

ОПИСАНИЕ

     Подпрограмма  unregisterfonts  освобождает   память,   ранее
захваченную  и  используемую функцией registerfonts.  Подпрогрмма
unregisterfonts удаляет из памяти головную  информацию  для  всех
шрифтов и все данные о текущем шрифте.

     Любая попытка  использовать  функции  setfont  или  outgtext
после вызова unregisterfonts, приведет к ошибке.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращаемого значения нет.

СМ.ТАКЖЕ

     getfontinfo,getgtextextent,setfont,outgtext,registerfonts

ПРИМЕР

     См.пример программы для registerfonts.



-----------------------------------------------------------------
wrapon
-----------------------------------------------------------------

ИНТЕРФЕЙС

      INTERFACE TO FUNCTION wrapon (option)
      INTEGER*2 wrapon[FAR,C,ALIAS:"__wrapon"]
      INTEGER*2 option
      END

ОПИСАНИЕ

     Функция  wrapon  контролирует,  будет  ли  текст,  выводимый
функцией  outtext,  переноситься  на  новую  строку,  или  просто
отсекаться,  когда  текстовый  вывод  достигнет  края   заданного
текстового   окна.   Аргумент  option  может  принимать  одно  из
следующих символических значений:






                               400



Константа       Смысл
---------       -----
$GWRAPOFF       Отсекает строки на границе окна.

$GWRAPON        Переносит строки на границе окна.

     ЗАМЕЧАНИЕ:   Эта  функция  не  влияет  на  вывод   шрифтовых
функций.

     Эта функция доступна также в OS/2.

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Возвращает предыдущее значение options.  Никакой  ошибки  не
возвращает.

СМ.ТАКЖЕ

     settextwindow

ПРИМЕР

CC  WRAP.FOR - иллюстрирует использование wrapon.

      INCLUDE  'FGRAPH.FI'
      INCLUDE  'FGRAPH.FD'

      INTEGER*2              dummy2, old_color, old_mode, row, col
      INTEGER*4              dummy4, old_bk
      CHARACTER*22           text
      CHARACTER*80           border
      RECORD / rccoord /     curpos
      RECORD / videoconfig / vc

      DATA text / 'Here text DOES wrap.  ' /

      CALL getvideoconfig( vc )
      old_mode  = vc.mode
      old_color = gettextcolor()
      old_bk    = getbkcolor()
      IF( vc.numtextcols .NE. 80 ) THEN
         IF( setvideomode( $TEXTC80 ) .EQ. 0 )
     +       dummy2 = setvideomode( $TEXTMONO )
      END IF
      dummy2    = settextcolor( 14 )
      dummy4    = setbkcolor( 1 )
      CALL clearscreen( $GCLEARSCREEN )
C
C     Рисуем границы окна.
C


                               401



      DO i = 1, 80
         border(i:i) = CHAR( 219 )
      END DO
      CALL settextposition( 13, 1, curpos )
      CALL outtext( border )
      col = 60
      DO row = 1, 25
         IF( row .EQ. 13 ) col = 20
         CALL settextposition( row, col, curpos )
         CALL outtext( border(1:1) )
      END DO
C
C     Выводим в окна переносимый и отсекаемый текст.
C
      dummy4 = setbkcolor( 0 )
      CALL settextwindow( 1, 1, 13, 59 )
      CALL settextposition( 1, 1, curpos )
      dummy2 = wrapon( $GWRAPON )
      dummy2 = settextcolor( 10 )
      DO i = 1, 32
         CALL outtext( text )
      END DO
      CALL outtext( text )

      CALL settextwindow( 14, 21, 25, 80 )
      CALL settextposition( 1, 1, curpos )
      dummy2 = wrapon( $GWRAPOFF )
      dummy2 = settextcolor( 12 )
      DO row = 1, 12
         CALL settextposition( row, 1, curpos )
         DO i = 1, 3
            CALL outtext( text(1:15) // 'NOT ' // text(16:22) )
         END DO
      END DO

      READ (*,*)
      dummy2 = setvideomode( old_mode )
      dummy2 = settextcolor( old_color )
      dummy4 = setbkcolor( old_bk )
      END

     Программа WRAP.FOR  демонстрирует  действие  автоматического
перехода на новую строку (wrapping) в текстовом окне.









                               402
