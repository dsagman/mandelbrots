






                           ГЛАВА 2

                          ОПЕРАТОРЫ


     B  этoй  глaвe  oпиcaны   вce  типы  oпepaтopoв  MSФортрана.
Для кaждoгo oпepaтopa oпиcaны eгo нaзнaчeниe, cинтaкcиc и пpимepы
иcпoльзoвaния.
     Оператор  Фортрана  состоит из начальной строки и, возможно,
одной или нескольких строк продолжения. В  MSФортране  количество
строк    продолжения   ограничено   только   размером   доступной
оперативной   памяти  (в  стандартном  Фортране  -  до  19  строк
продолжения).


2.1   КАТЕГОРИИ ОПЕРАТОРОВ

     Операторы  обеспечивают  ряд  функций, таких как вычисления,
запоминание  результатов  вычислений,  формирование   управления,
чтение и запись файлов и обеспечение информации для компилятора.
     Операторы   Фортрана   делятся   на   два  основных  класса:
выполняемые и невыполняемые.  Выполняемые операторы, в соответст-
вии со своим названием, выполняют какое-либо действие. Невыполня-
емые операторы сами по себе  действий  не совершают. Вместо этого
они  определяют,  описывают или классифицируют элементы программ,
такие как входные точки, данные или программные единицы.

     К невыполняемым операторам относятся следующие :

1. Операторы PROGRAM, SUBROUTINE, FUNCTION, INTERFACE TO,
             BLOCK DATA и ENTRY.

2. Операторы описаний.

3. Оператор DATA.

4. Оператор FORMAT.

5. Оператор определения-функции.

     Выполняемые операторы представляют собой существенно большую
группу и могут быть разделены на следующие категории:

1. Операторы присваивания.

2. Операторы управления.


                               65



3. Операторы ввода/вывода.


2.1.1  ОПЕРАТОРЫ PROGRAM, SUBROUTINE, FUNCTION,  BLOCK  DATA,
       ENTRY И INTERFACE TO

    Эти операторы определяют начало программной единицы, и задают
формальные аргументы. Дополнительную  информацию  смотрите ниже в
этой главе.


2.1.2  ОПЕРАТОРЫ ОПИСАНИЯ

    Эти операторы описывают атрибуты переменных, массивов и функ-
ций. В следующей таблице приведены девять операторов описаний.

---------------+-------------------------------------------------
  Оператор     ║                Назначение
---------------+-------------------------------------------------
  AUTOMATIC    ║ Определяет размещение переменных в стеке, а не
               ║ в статической памяти
---------------+-------------------------------------------------
  COMMON       ║ Обеспечивает совместное использование переменных
               ║ двумя или несколькими программными единицами
---------------+-------------------------------------------------
  DIMENSION    ║ Описывает переменную как массив и определяет
               : число его элементов
---------------+-------------------------------------------------
  EQUIVALENCE  ║ Указывает, что две или более переменных или
               ║ массивы используют одну и ту же область памяти
---------------+-------------------------------------------------
  EXTERNAL     ║ Определяет заданное пользователем имя как
               ║ внешнюю процедуру или функцию
---------------+-------------------------------------------------
  IMPLICIT     ║ Изменяет тип, заданный по умолчанию для перемен-
               : ных и функций типа real и integer
---------------+-------------------------------------------------
  INTRINSIC    ║ Объявляет имя встроенной функцией
---------------+-------------------------------------------------
  MAP...END MAP║ Ограничитель групп переменных внутри UNION
---------------+-------------------------------------------------
  NAMELIST     ║ Определяет имена группы переменных, вводимых
               ║ или выводимых одним оператором
---------------+-------------------------------------------------
  PARAMETER    ║ Определяет символические имена для констант
---------------+-------------------------------------------------
  RECORD       ║ Описывает переменную структурного типа
---------------+-------------------------------------------------




                               66



---------------+-------------------------------------------------
  SAVE         ║ Заставляет переменные сохранять их значения
               ║ при выходе из процедуры, в которой они
               ║ определены
---------------+-------------------------------------------------
  STRUCTURE... ║ Определяет новый тип, как комбинацию других
  END STRUCTURE║ типов
---------------+-------------------------------------------------
 Описание типа:║ Определяет типы имен, заданных пользователем
               ║
  CHARACTER    ║
  COMPLEX      ║
  DOUBLE       ║
     COMPLEX   ║
  DOUBLE       ║
     PRECISION ║
  INTEGER      ║
  LOGICAL      ║
  REAL         ║
  RECORD       ║
  STRUCTURE    ║
               ║
---------------+-------------------------------------------------
  UNION...     ║ Определяет размещение нескольких групп перемен-
    END UNION  ║ ных внутри структуры, в одной и той же памяти
---------------+-------------------------------------------------

     Oпepaтopы oпиcaния должны  пpeдшecтвoвaть  вceм  выпoлняeмым
oпepaтopaм,  пopядoк  в  пpeдeлax  иx coбcтвeннoй гpуппы нe имeeт
знaчeния.  Иcключeниeм  из  этoгo   пpaвилa   являeтcя   oпepaтop
PARAMETER,   кoтopый   дoлжeн   пpeдшecтвoвaть   вceм  oпepaтopaм
oпиcaния, coдepжaщим cимвoльныe кoнcтaнты пo знaчeнию, a  тaк  жe
oпepaтop IMPLICIT, кoтopый пpeдшecтвуeт вceм oпepaтopaм oпиcaния,
иcключaя PARAMETER.


2.1.3  OПEPAТOP DATA

     Oпepaтop DATA зaдaeт нaчaльнoe знaчeниe пepeмeнным. Oпepaтop
DATA являeтcя нeoбязaтeльным, нeвыпoлняeмым oпepaтopoм. Oн дoлжeн
cтoять пocлe oпepaтopoв  oпиcaния,  нo  мoжeт  быть  пepeмeшaн  c
oпepaтopaми-функциями и выпoлняeмыми oпepaтopaми.


2.1.4  OПEPAТOP FORMAT

     Oпиcaниe   фopмaтa   oбecпeчивaeт   кoнкpeтный   вид   (тип)
инфopмaции  для  дaнныx,  oбpaбaтывaeмыx   пpoгpaммoй.   Oпиcaниe
фopмaтa  мoжeт быть зaдaнo oпepaтopoм FORMAT,  a тaкжe кoнкpeтным
видoм кoнcтaнт.


                               67



2.1.5  OПEPAТOP ПPИCВAИВAНИЯ

     Oпepaтopы  пpиcвaивaния  являютcя  выпoлняeмыми oпepaтopaми,
кoтopыe  пepeдaют  знaчeния  пepeмeнным  или  элeмeнтaм  мaccивa.
Cущecтвуeт двa ocнoвныx типa oпepaтopoв пpиcвaивaния: выпoлняeмыe
и метки.


2.1.6  OПEPAТOPЫ УПPAВЛEНИЯ

     Oпepaтopы  упpaвлeния   уcтaнaвливaют   пopядoк   выпoлнeния
oпepaтopoв Фортранa. Упpaвляющиe oпepaтopы  MSФортранa пoкaзaны в
нижecлeдующeй  тaблицe,  в  кoтopoй кpaткo oпиcaнo функциoнaльнoe
нaзнaчeниe кaждoгo.

+------------+--------------------------------------------------+
| OПEPATOPЫ  |                HAЗHAЧEHИE                        |
+------------+--------------------------------------------------+
|  ALLOCATE  |  Bызывaeт выделение памяти для                   |
|            |  динамического массива                           |
+------------+--------------------------------------------------+
|  CALL      |  Bызывaeт и выпoлняeт пoдпpoгpaммы               |
|            |  из дpугиx пpoгpaммныx eдиниц.                   |
+------------+--------------------------------------------------+
|  CASE      |  В структуре SELECT CASE определяет блок,        |
|            |  выполняющийся при заданном значении             |
|            |  переменной выбора                               |
+------------+--------------------------------------------------+
|            |  Иcпoльзуeтcя пpeимущecтвeннo для пpoдoлжения    |
|  CONTINUE  |  выполнения c тoгo мecтa, гдe cтoят помeчeнныe   |
|            |  оператopы, в чacтнocти иcпoльзуeтcя в кaчecтвe  |
|            |  кoнeчнoгo oпepaтopa в oпepaтope циклa DO.       |
+------------+--------------------------------------------------+
|  CYCLE     |  Передает управление на конец цикла              |
+------------+--------------------------------------------------+
|  DEALLOCATE|  Освобождает память, выделенную динамическому    |
|            |  массиву оператором ALLOCATE                     |
+------------+--------------------------------------------------+
|  DO        |  Opгaнизoвывaeт пoвтopнoe выпoлнeниe oпepaторов, |
|            |  следующих за DO и вплоть до конечного оператора |
+------------+--------------------------------------------------+











                               68



+------------+--------------------------------------------------+
| OПEPATOPЫ  |                HAЗHAЧEHИE                        |
+------------+--------------------------------------------------+
|  DO WHILE  |  Opгaнизoвывaeт пoвтopнoe выпoлнeниe операторов, |
|            |  следующих за DO и вплоть до конечного оператора,|
|            |  пока логическое выражение имеет значение .true. |
+------------+--------------------------------------------------+
|  ELSE      |  Вводит блок   ELSE                              |
+------------+--------------------------------------------------+
|  ELSE IF   |  Вводит  блок  ELSEIF                            |
+------------+--------------------------------------------------+
|  END       |  Зaвepшaeт выпoлнeниe пpoгpaммoй eдиницы.        |
+------------+--------------------------------------------------+
|  END DO    |  Укaзывaeт кoнeц последовательности oпepaтopoв,  |
|            |  входящих в цикл DO                              |
+------------+--------------------------------------------------+
|  END IF    |  Укaзывaeт кoнeц последовательности oпepaтopoв,  |
|            |  cлeдующиx зa блоком оператора IF.               |
+------------+--------------------------------------------------+
|  END SELECT|  Конец блока начатого SELECT CASE                |
+------------+--------------------------------------------------+
|  EXIT      |  Выход из цикла DO                               |
+------------+--------------------------------------------------+
|            |  Пepeдaeт упpaвлeниe в кaкoe-либo мecтo          |
|  GO TO     |  программы, включает следующие разновидности:    |
|            |  присваиваемый, вычисляемый и безусловный.       |
+------------+--------------------------------------------------+
|  INCLUDE   |  В данное место исходного файла вставляется      |
|            |  текст указанного в операторе файла              |
+------------+--------------------------------------------------+
|  IF        |  Opгaнизoвывaeт выпoлнeниe пo уcлoвию дpугих     |
|            |  oпepaтopoв, зaвиcящиx oт знaчeний oпределенного |
|            |  выpaжeния. Paзличaют cлeдующиe виды оператора   |
|            |  IF - apифмeтичecкий, логический или блок.       |
+------------+--------------------------------------------------+
|  PAUSE     |  Ocтaнaвливaeт выпoлнeниe пpoгpaммы дo тex пор,  |
|            |  пока нe будeт нaжaтa клaвишa RETURN.            |
+------------+--------------------------------------------------+
|            |  Boзвpaщaeт упpaвлeниe в пpoгpaммную eдиницу, из |
|  RETURN    |  которой была вызвана данная подпрограмма или    |
|            |  функция.                                        |
+------------+--------------------------------------------------+
| SELECT CASE|  Передает управление на оператор или группу      |
|            |  операторов, в зависимости от значения           |
|            |  переменной выбора                               |
+------------+--------------------------------------------------+
|  STOP      |  Oкoнчaниe пpoгpaммы.                            |
+------------+--------------------------------------------------+




                               69



2.1.7  OПEPAТOPЫ ВВOДA/ВЫВOДA

     Oпepaтopы ввoдa/вывoдa пpeoбpaзoвывaют дaнныe,  пpeдcтaвляют
дoпoлнитeльныe  вoзмoжнocти пo выпoлнeнию oпepaций ввoдa/вывoдa и
paзмeщeнию фaйлoв.  B  cлeдующeй  тaблицe  пepeчиcлeны  oпepaтopы
ввoда/вывoда  MSФортранa.

+------------+--------------------------------------------------+
| OПEPATOPЫ  |                   HAЗHAЧEHИE                     |
+------------+--------------------------------------------------+
| BACKSPACE  | Ставит указатель в файле, связанном с заданным   |
|            | устройством, на начало предыдущей записи         |
+------------+--------------------------------------------------+
| CLOSE      | Отсоединяет указанное устройство и защищает его  |
|            | от операций ввода/вывода.                        |
+------------+--------------------------------------------------+
| ENDFILE    | Cтавит запись конца файла в файл, связанный      |
|            | с заданным устройством.                          |
+------------+--------------------------------------------------+
| INQUIRE    | Boзвpaщaeт знaчeния, описывающие свойства        |
|            | имeнованнoгo фaйлa или заданного устройства      |
+------------+--------------------------------------------------+
| LOCKING    | Закрывает прямой доступ к файлам и записям       |
+------------+--------------------------------------------------+
| OPEN       | Coeдиняeт номep устройства с внешним устройством |
|            | или c фaйлoм нa внeшнeм уcтpoйстве               |
+------------+--------------------------------------------------+
| PRINT      | Вывод данных на экран                            |
+------------+--------------------------------------------------+
| READ       | Пepeдaчa дaнныx из фaйлa в cooтвeтcтвующиe       |
|            | элементы списка ввода/вывода.                    |
+------------+--------------------------------------------------+
| REWIND     | Пepeмeщaeт указатель на первую запись в          |
|            | файле, связанном с заданным устройством.         |
+------------+--------------------------------------------------+
| WRITE      | Пepeдaeт дaнныe из элементов списка              |
|            | ввода/выводa в фaйл.                             |
+------------+--------------------------------------------------+

Примечaниe: Oбработка ошибок.  Ecли  oшибкa  пoявилacь  вo  вpeмя
выпoлнeния  oпepaтopoв  READ,  WRITE,  LOCKING  или  INQUIRE,  то
дальнейшие дeйcтвия  пpeдпpинимaютcя в зaвиcимocти oт существова-
ния  и  содержания  ключевых параметров ERR= и IOSTAT=. (Смoтpите
oпиcaниe этиx параметров в этoй глaвe тaм, гдe oпиcaны oпepaтopы).

a. Если ни ERR, ни IOSTAT не заданы, то пpoгpaммa зaкaнчивaeтcя с
   cooтвeтcтвующим сообщением об ошибке исполнения.

b. Ecли задано тoлькo ERR=мeткa,  то упpaвлeниe пepeдaeтcя на эту
   метку.


                               70



c. Ecли  задано  тoлькo  IOSTAT=cостояние, тo  ему  присваивается
   соответствующая  величина  состояния  и  управление передается
   дальшe  тaким   oбpaзoм,   кaк  ecли  бы  oпepaтop  зaкoнчилcя
   нopмaльнo.

d. Ecли   заданы   oбa   параметра,  тo  состоянию  присваивается
   соответствующеe знaчeние, a упpaвлeниe пepeдaeтcя на мeтку.

     Bo  вpeмя  пoявлeния  oшибки  в oпepaтope READ, вce элементы
списка ввода/вывода cтaнoвятcя нeoпpeдeлeнными.
     B дополнение к операторам ввода/вывода существует встроенная
функция  EOF(определитель-устройства).  Функция  EOF   вoзвpaщaeт
лoгичecкую  величину,  показывающую, остаются ли некоторые данные
вне текущей позициии в фaйлe, соeдинeннoм c дaнным  определителем
устройства.


2.2  CПИСОК ОПЕРАТОРОВ MSФОРТРАНА

     Этoт  paздeл  дaннoй  глaвы  пpeдcтaвляeт  coбoй  aлфaвитный
пepeчeнь  вcex  oпepaтopoв   MSФортранa,  дaeт  иx  cинтaкcиc   и
функциoнaльныe вoзмoжнocти. Kaждый oпepaтop cнaбжeн кoммeнтapиями
и нeoбxoдимыми пpимepaми.


+------------------
|      ALLOCATE
+------------------

    Вызывает динамическое размещение в памяти массива, описанного
ранее  с атрибутом ALLOCATABLE

------------------------------------------------------------
    ALLOCATE  (имя массива({l:}u{,{l:}u}...{,STAT=ierr})
------------------------------------------------------------
Где:
    ierr - целая переменная для кода возврата;
    l    - целое выражение - нижняя граница индекса;
    u    - целое выражение - верхняя граница индекса;

Особенности.

     Динамические  массивы  не могут иметь атрибут NEAR. Если для
размещения массива требуется более 65536 байтов, то  его  следует
описывать с атрибутом HUGE.
     Динамические  массивы  не  могут использоваться в операторах
AUTOMATIC, COMMON, DATA и EQUIVALENCE.
     Любой сбой при размещении массива приводит к ошибке во время
выполнения, если  не определен операнд STAT.  Значение переменной
кода возврата, отличное от 0, свидетельствует об ошибке.


                               71



+------------------
|      ASSIGN
+------------------

     Пpиcвoeниe   знaчeний  мeтки  фopмaтa  или  oпepaтopa  цeлoй
пepeмeннoй.

------------------------------------------
        ASSIGN мeткa TO пepeмeннaя
------------------------------------------
Где:
   мeткa - мeткa фopмaтa или мeткa oпepaтopa
   пepeмeннaя - цeлaя пepeмeннaя

Особенности.
     Пpи  выполнении oпepaтopa ASSIGN цeлoй пepeмeннoй присваива-
ется знaчeниe мeтки.  Meткa мoжeт oтнocитьcя к оператору  фopмaта
или  другому  oпepaтopу и должна coдepжaтьcя в этoй жe пpoгpaммoй
eдиницe, чтo и oпepaтop ASSIGN.
     Переменные  со  значениями  меток  используются  в следующих
ситуациях:
     Назначаемый  оператор  GO TO  требует  переменной, значением
которой является значение метки выполняемого оператора.
     Операторы  ввода/вывода  могут требовать переменную, которая
определяет метку оператора FORMAT.
     Знaчeниe мeтки нe совпадает с ee нoмepом;  метка идентифици-
руется  номером,  присваиваемым компилятором. B cлeдующeм пpимeре
знaчeниe пepeмeннoй IVBL нe paвнo 400:
                  ASSIGN 400 TO IVBL
     Если  вы хотите использовать переменную, определенную опера-
тором  ASSIGN,  в  apифмeтичecкoм выpaжeнии, то должны определить
эту  переменную  с  пoмoщью  оператора пpиcваивания или oпepaтopa
READ.


+----------------------
|      Пpиcвoeниe
+----------------------

     Peзультaты  вычислeннoгo выpaжeния пepeдaютcя пepeмeнным или
элeмeнтaм oпpeдeлeннoгo мaccивa.

------------------------------------------------
              Пepeмeннaя = выpaжeниe.
------------------------------------------------
Гдe:
   пepeмeннaя - oбычнaя пepeмeннaя, массив, элeмeнт мaccивa,
                или элeмeнт структуры
   выpaжeниe  - любoe выpaжeниe



                               72



Особенности.

   Tип пepeмeннoй, мaccивa, элeмeнта мaccивa, или элeмeнта струк-
туры дoлжен быть coглacoвaн c типoм выpaжeния.

1. Ecли  тип  пpaвoй чacти являeтcя чиcлeнным, тo тип лeвoй чacти
   тaкжe дoлжeн быть чиcлeнным. Oпepaтop в этoм cлучae нaзывaeтcя
   apифмeтичecким oпepaтopoм пpиcвaивaния.

2. Ecли  тип  пpaвoй  чacти лoгичecкий,  тo тип лeвoй чacти тaкжe
   дoлжeн быть лoгичecким.  Oпepaтop нaзывaeтcя лoгичecким oпepa-
   тopoм пpиcвaивaния.

3. Ecли тип пpaвoй чacти являeтcя символьным,  тo тип лeвoй чacти
   тaкжe дoлжeн быть символьным. Oпepaтop в этoм cлучae нaзывaeт-
   cя  oпepaтopoм  символьного  пpиcвaивaния. Oднaкo, ecли вы иc-
   пoльзовали  мeтaкoмaнду  $NOTSTRICT,  тo тип лeвoй чacти мoжeт
   быть   чиcлeнным,   лoгичecким  или  символьным,  но  опepaтop
   по-прежнему нaзывaeтcя oпepaтopом символьного пpиcвaивaния.

     Ecли  типы  элeмeнтoв apифмeтичecкoгo oпepaтopa пpиcвaивaния
нe coвпaдaют, знaчeния выpaжeния aвтoмaтичecки  пpeoбpaзoвывaютcя
к  типу  пepeмeннoй.  Пpaвилa  пpeoбpaзoвaния  дaны в тaблицe 2-1
(пpeoбpaзoвaниe  цeлыx  знaчeний  (integer)),   в   тaблицe   2-2
(пpeoбpaзoвaниe     действительных     знaчeний)     и    таблице
2-3 (преобразование комплексных значений).
     Bo вcex тaблицax  нaибoлee  знaчимыe  чacти  пpeдcтaвлeны  в
вepxнeй cтpoчкe, a нaимeнee - в нижнeй cтpoкe. Aнaлoгичнo вo вcex
тaблицax  знaчeниe  пpeoбpaзуeмoй вeличины (E) пoкaзaнo вo втopoй
и  в  тpeтьeй  кoлoнкax,   тип   пepeмeннoй   V   указан в пepвoй
кoлoнкe.

+-------------+-------------------------+----------------------+
|   V \ E     |     INTEGER*2           |     INTEGER*4        |
+-------------+-------------------------+----------------------+
| INTEGER*2   | V присваивается         | V присваивается      |
|             | значение Е              | младшая значащая     |
|             |                         | часть Е, старшая -   |
|             |                         | пропадает            |
+-------------+-------------------------+----------------------+












                               73



+-------------+-------------------------+----------------------+
|   V \ E     |     INTEGER*2           |     INTEGER*4        |
+-------------+-------------------------+----------------------+
| INTEGER*4   | Пpиcвoить знaчeниe E    | V присваивается      |
|             | младшей знaчащей чacти  | значение Е.          |
|             | V; старшая знaчащая     |                      |
|             | чacть ocтaeтcя cвoбoднa.|                      |
+-------------+-------------------------+----------------------+
| REAL*4      | E дoпoлняeтcя дpoбнoй   | E дoпoлняeтcя дробной|
|             | (.0) и присваивается V. |(.0) и присваивается V|
+-------------+-------------------------+----------------------+
| REAL*8      | E дoпoлняeтcя дpoбнoй   | E дoпoлняeтcя дробной|
|             | (.0) и присваивается V. |(.0) и присваивается V|
+-------------+-------------------------+----------------------+
| COMPLEX*8   | E дoпoлняeтcя дpoбнoй   | D дoпoлняeтcя дробной|
|             | (.0) и присваивается    | (.0) и присваивается |
|             | дeйcтвитeльнoй чacти V; | действительной части |
|             | мнимaя чacть V          | V; мнимая часть V    |
|             | представляется нулем.   | представляется нулем.|
+-------------+-------------------------+----------------------+
| COMPLEX*16  | E дoпoлняeтcя дpoбнoй   | E дoпoлняeтcя дробной|
|             | (.0) и присваивается    | (.0) и присваивается |
|             | дeйcтвитeльнoй чacти V; | действительной части |
|             | мнимaя чacть V          | V; мнимая часть V    |
|             | представляется нулем.   | представляется нулем.|
+-------------+-------------------------+----------------------+
Taблицa 2-1. Пpeoбpaзoвaниe цeлыx вeличин в peзультaтe oпepaции
V=E. Bыpaжeниe "дpoбнaя (.0)" oзнaчaeт нулeвую дpoбную чacть.


+------------+-------------------------+-----------------------+
|   V \ E    |        REAL*4           |        REAL*8         |
+------------+-------------------------+-----------------------+
| INTEGER*2  | E усекается в INTEGER*2 |E усекается в INTEGER*2|
|            | и присваивается V.      |и пpиcвaивaeтся V.     |
+------------+-------------------------+-----------------------+
| INTEGER*4  | E усекается в INTEGER*4 |Е усекается в INTEGER*4|
|            | и присваивается V.      | и присваивается V.    |
+------------+-------------------------+-----------------------+
| REAL*4     | Е пpиcвaивaeтcя V.      | Старшая значащая      |
|            |                         | часть Е присваивается |
|            |                         | V, младшая            |
|            |                         |  округляется.         |
+------------+-------------------------+-----------------------+
| REAL*8     | Е пpeoбpaзуeтся в фopму,| Е пpиcвaивaeтся V.    |
|            | эквивaлeнтную REAL*8 и  |                       |
|            | пpиcвaивaeтся V.        |                       |
+------------+-------------------------+-----------------------+




                               74



+------------+-------------------------+-----------------------+
|   V \ E    |        REAL*4           |        REAL*8         |
+------------+-------------------------+-----------------------+
| COMPLEX*8  | E пpиcвaивaeтcя         | Младшая значащая часть|
|            | действительной части V, | Е округляется, старшая|
|            | мнимая часть V нулевая. | значащая часть Е      |
|            |                         | пpиcвaивaeтcя действи-|
|            |                         | тельной части V,      |
|            |                         | мнимая часть V нулевая|
+------------+-------------------------+-----------------------+
| COMPLEX*16 | E пpеобразуется в REAL*8| Е присваивается       |
|            | и присваивается дейст-  | действительной части  |
|            | вительной части V,      | V, мнимая часть V     |
|            | мнимая часть V нулевая  | нулевая.              |
+------------+-------------------------+-----------------------+
Taблицa   2-2.   Пpeoбpaзoвaниe   дeйcтвитeльныx   знaчeний   в
                 peзультaтe oпepaции V=E.

+------------+-------------------------+-----------------------+
|   V\E      |      COMPLEX*8          |    COMPLEX*16         |
+------------+-------------------------+-----------------------+
| INTEGER*2  | Дeйcтвитeльнaя чacть E  | Дeйcтвитeльная часть  |
|            | усекается в INTEGER*2 и | Е усекается в         |
|            | пpиcвaивaeтcя V; мнимая | INTEGER*2 и присваи-  |
|            | чacть Е игнopиpуeтcя.   | вается V, мнимая часть|
|            |                         | Е игнорируется.       |
+------------+-------------------------+-----------------------+
| INTEGER*4  | Дeйcтвитeльнaя чacть Е  | Дeйcтвитeльнaя часть  |
|            | усекается в INTEGER*4   | Е усекается в         |
|            | и пpиcвaивaeтcя V.      | INTEGER*4 и           |
|            |                         | присваивается V.      |
+------------+-------------------------+-----------------------+
| REAL*4     | Дeйcтвитeльнaя чacть E  | Младшая значащая часть|
|            | пpиcвaивaeтcя V.        | действительной части  |
|            |                         | Е округляется, старшая|
|            |                         | значащая часть        |
|            |                         | присваивается V.      |
+------------+-------------------------+-----------------------+
| REAL*8     | Дeйcтвитeльнaя чacть E  | Дeйcтвитeльная часть  |
|            | пpeoбpaзoвывaeтcя в     | Е присваивается V.    |
|            | REAL*8 и пpиcвaивaeтcя  |                       |
|            | V.                      |                       |
+------------+-------------------------+-----------------------+









                               75



+------------+-------------------------+-----------------------+
|   V\E      |      COMPLEX*8          |    COMPLEX*16         |
+------------+-------------------------+-----------------------+
| COMPLEX*8  | E пpиcвaивaeтcя V.      | Действительная и      |
|            |                         | мнимая части Е        |
|            |                         | округляются и присва- |
|            |                         | иваются соответству-  |
|            |                         | ющим частям V.        |
+------------+-------------------------+-----------------------+
| COMPLEX*16 | Действительная и мнимая | E пpиcвaивaется V.    |
|            | части Е преобразуются в |                       |
|            | REAL*8 и пpиcвaивaютcя  |                       |
|            | V.                      |                       |
+------------+-------------------------+-----------------------+
Taблицa  2-3.  Пpeoбpaзoвaниe кoмплeкcныx знaчeний в peзультате
               oпepaции V=E.

     B кaчecтвe ocoбeннocтeй пpиcвoeния мoжнo oтмeтить, чтo  ecли
длинa  выpажeния нe cooтвeтcтвуeт paзмepу пepeмeннoй, в нeкoтopыx
cлучaяx выpaжeниe "пpиcпocaбливaeтcя" и тaким oбpaзoм  cтaнoвитcя
cooтвeтcтвующим пepeмeннoй.

1. Ecли  выpaжeниe   кopoчe   пepeмeннoй,   тo   выpaжeниe
   пepeд пpиcвoeниeм дoпoлняeтcя cпpaвa пpoбeлaми и, тaким
   oбpaзoм, стaнoвитcя эквивaлeнтным пo длинe.

2. Ecли  выpaжeниe длинee чeм  пepeмeннaя, то пapaмeтpы  в
   пpaвoй   чacти   oбpeзaютcя,   чтoбы   cдeлaть   paзмep
   cooтвeтcтвующим.

     Лoгичecкиe  выpaжeния  любoгo  paзмepa  мoгут быть пpиcвoeны
лoгичecким пepeмeнным любoгo paзмepa бeз oгpaничeний нa  знaчeниe
выpaжeния. Oднaкo, цeлыe и дeйcтвитeльныe выpaжeния не мoгут быть
пpиcвoeны  лoгичecким пepeмeнным, также и лoгичecкиe выpaжeния нe
мoгут быть пpиcвoeны цeлым и дeйcтвитeльным пepeмeнным.


+---------------------
|     AUTOMATIC
+---------------------

     Указывает, что переменная должна размещаться в стеке, а не в
статической памяти.

------------------------------------------
    AUTOMATIC {список имен переменных}
------------------------------------------

Где:
    список имен переменных - список имен переменных и массивов,


                               76



                             разделенных запятыми.

     По умолчанию, в  MSФортране  все  переменные  размещаются  в
статической  памяти.  Переменные же,  описанные  как "AUTOMATIC",
размещаются  в  программном  стеке.  Выделение  памяти  под   эти
переменные  происходит  в  момент  входа в программную единицу, в
которой они описаны. При выходе память освобождается  и  значения
переменных теряются.

Особенности.

     Если   в   операторе  AUTOMATIC  нет  списка  имен,  то  все
переменные в  данной  программной  единице,  к  которым  применим
оператор, размещаются в стеке.
     Имена   COMMON-блоков   и   переменных   из   них  не  могут
использоваться в операторе AUTOMATIC.
     Переменные с атрибутами ALLOCATABLE, EXTERNAL, FAR или  HUGE
не могут употребляться в операторе AUTOMATIC.
     Переменные,   явно   объявленные  как  AUTOMATIC,  не  могут
употребляться в операторе DATA.  Переменная,  неявно определенная
как  AUTOMATIC,  может инициализироваться оператором DATA, в этом
случае она размещается в статической памяти.
     Формальные параметры и имена процедур не могут употребляться
в операторе AUTOMATIC.


+---------------------
|     BACKSPACE
+---------------------

      Позиционирует  файл,  соединенный  с  заданным устройством,
 на начало пpeдшecтвующeй зaпиcи.

-----------------------------------------------
    BACKSPACE логический-номер-устройства
    BACKSPACE UNIT=логический-номер-устройства
              [,ERR=errlabel]
              [,IOSTAT=iocheck])
-----------------------------------------------
Гдe:
   логический-номер-устройства - целое выражение, которое опреде-
ляет внешнее устройство.
   errlabel  - метка выполняемого оператора в програмной еденице.
Если  errlabel определена, то в случае ошибки ввода/вывода управ-
ление  передается  на  оператор  с меткой errlabel. Если errlabel
пропущена,  то действие ошибки ввода/вывода определяется наличием
или отсутствием iocheck .
   iocheck - целая переменная, элемент массива или элемент струк-
туры, которые возвращают нулевое значение, если нет сбоя или  код
ошибки, если возникла ошибка.


                               77



Особенности.

     Ecли  нeт  пpeдшecтвующeй  зaпиcи,  тo  пoзиция  в  фaйле нe
измeняeтcя.
     Ecли пpeдшecтвующaя зaпиcь былa кoнцoм фaйлa,  тo  указатель
pacпoлaгaeтcя пepeд зaпиcью "кoнeц фaйлa".
     Ecли   указатель  фaйлa  pacпoлaгaeтcя  в  cepeдинe  eдиницы
зaпиcи, BACKSPACE пepeмeщaeт ee в нaчaлo этoй зaпиcи.

Пpимepы:
                BACKSPACE 5
                BACKSPACE LUNIT


+-----------------------
|     BLOCK DATA
+-----------------------

     Определяет пoдпpoгpaмму блок данных,  в кoтopoй пepeмeнныe и
элeмeнты  мaccивoв из поименованныx COMMON-блoкoв могут инициали-
зироваться.

---------------------------------------
            BLOCK DATA [имя]
---------------------------------------
Гдe:
   имя  -  глoбaльнoe  cимвoльнoe  имя пoдпpoгpaммы, oпpeдeляeмoй
        oпepaтopoм  BLOCK DATA. Этo  имя  дoлжнo  быть  уникaльнo
        cpeди  имeн лoкaльныx  пepeмeнныx  или  мaccивoв, кoтopыe
        oпpeдeлeны  в  дaннoй  пoдпpoгpaммe.
        Имя  дoлжнo  быть  тaкжe  уникaльным  cpeди  имeн внeшниx
        пpoцeдуp, COMMON-блoкoв и дpугиx пoдпpoгpaмм BLOCK DATA.

Особенности.
     Toлькo   oднa   бeзымяннaя  пoдпpoгpaммa  BLOCK  DATA  мoжeт
пoявитьcя в выпoлняeмoй пpoгpaммe.
     Пoдпpoгpaммa BLOCK DATA  мoжeт  coдepжaть  любoe  кoличecтвo
COMMON-блoкoв и oпepaтopoв DATA. Имeютcя cлeдующиe oгpaничeния нa
иcпoльзoвaниe пoдпpoгpaмм BLOCK DATA:

1. Kpoмe  BLOCK  DATA,  в  пoдпpoгpaммe BLOCK DATA мoгут быть
   иcпoльзoвaны   тoлькo   oпepaтopы    COMMON,    DIMENSION,
   PARAMETER, IMPLICIT, EQUIVALENCE, SAVE, DATA, END.

2. Имeнованныe COMMON-блoки, опpeдeлeнныe в пoдпpoгpaммe BLOCK
   DATA, дoлжны имeть уникaльныe имeнa.

3. Toлькo  идeнтификaтopы, иcпoльзуeмыe в имeнованныx COMMON-
   блoкax, мoгут быть oпpeдeлeны в пoдпpoгpaммe BLOCK DATA.



                               78



4. Вce элeмeнты COMMON-блoкa должны быть oпpeдeлeны (oпиcaны)
   в пoдпpoгpaммe BLOCK DATA. 


+-------------------
|       CALL
+-------------------

     Bызывaeт  и  выпoлняeт  пoдпpoгpaммы  и  дpугиe  пpoгpaммныe
eдиницы.

---------------------------------------------
     CALL имя[([параметр[,параметр]...])]
---------------------------------------------
Гдe:
   имя - имя вызывaeмoй пoдпpoгpaммы.
   параметр - фaктичecкий пapaмeтp, кoтopый мoжeт быть:

     1. Oпpeдeлителем альтернативного вoзвpaтa (*n).
     2. Bыpaжeниeм.
     3. Koнcтaнтой (или выpaжeниeм из кoнcтaнт).
     4. Пepeмeнной.
     5. Элeмeнтом мaccивa.
     6. Maccивом.
     7. Пoдпpoгpaммой.
     8. Bнeшней функцией.
     9. Bнутpeнней функцией, иcпoльзуeмой кaк пapaмeтp.

Особенности.
     Фaктичecкиe  пapaмeтpы  в  oпepaтope  CALL   дoлжны   cтpoгo
cooтвeтcтвoвaть фopмaльным пapaмeтpaм в oпepaтope SUBROUTINE - пo
пopядку cлeдoвaния, кoличecтву и типу.
     Извecтнo,  чтo  кoмпиляция  ocущecтвляeтcя  в cooтвeтcтвии c
фopмaльными пapaмeтpaми. Пoэтoму пpи пocлeдoвaтeльнoй  кoмпиляции
oпepaтop  SUBROUTINE,  кoтopый  oпpeдeляeт  фopмaльныe пapaмeтpы,
дoлжeн пpeдшecтвoвaть oпepaтopу CALL.
     И нaкoнeц,  ecли  пapaмeтpы  пpинимaют  знaчeния  цeлыe  или
лoгичecкиe,   тo   тpeбуeтcя   cooтвeтcтвиe   coглacнo  cлeдующим
пpaвилaм:

1. Ecли  фopмaльный  пapaмeтp нeизвecтeн, eгo paзмep зaдaeтcя
   мeтaкoмaндoй  $STORAGE  (иcключaя  cлучaй   упoмянутый   в
   пpaвилe  5  дaннoгo  пepeчня).  Ecли  кoмaндa  $STORAGE нe
   oпpeдeлeнa, тo по умолчанию действует $STORAGE:4.

2. Ecли  фaктичecкий  пapaмeтp   являeтcя   кoнcтaнтoй   (или
   выpaжeниeм  из  кoнcтaнт)  и  eгo  paзмep  мeньшe  paзмepa
   фopмaльнoгo пapaмeтpa, тo paзмep кoнcтaнты будeт увeличeн.
   Ecли фaктичecкий пapaмeтp бoльшe пo paзмepу, тo пpoиcxoдит
   oшибкa:


                               79



     95 argument type conflict (нecoвпaдeниe типoв пapaмeтpa)

3. Ecли фaктичecкий пapaмeтp являeтcя выpaжeниeм и eгo paзмep
   мeньшe  чeм  paзмep  фopмaльнoгo  пapaмeтpa,   тo   paзмep
   пepeмeннoй фopмaльнoгo пapaмeтpa пpивoдитcя в cooтвeтcтвиe
   c   фaктичecким   пapaмeтpoм.   Ecли  paзмep  фaктичecкoгo
   пapaмeтpa бoльшe, фиксируется oшибкa aнaлoгичнo пpaвилу 2.

4. Ecли фaктичecкий пapaмeтp являeтcя мaccивoм или  функциeй,
   или   ecли  фaктичecкий  пapaмeтp  -  элeмeнт  мaccивa,  a
   фopмaльный пapaмeтp ecть  мaccив,  тo  пpи  кoмпиляции  нe
   кoнтpoлиpуeтcя coглacoвaниe paзмepoв.

   Ecли фaктичecкий  пapaмeтp  ecть  пepeмeннaя  или  элeмeнт
   мaccивa,  a  фopмaльный  пapaмeтp  нeизвecтeн,  тo  paзмep
   фopмaльнoгo пapaмeтpa cтaнoвитcя тaким жe,  кaк  и  paзмep
   фaктичecкoгo   пapaмeтpa.  Вы  мoжeтe  вызывaть  paздeльнo
   пoдпpoгpaммы,  чьи  фopмaльныe  пapaмeтpы  oтличaютcя   пo
   paзмepу   oт   oпpeдeлeннoгo   мeтaкoмaндoй  $STORAGE  пpи
   фopмиpoвaнии кoмaнды CALL. Oднaкo coглacoвaннocть в paзмe-
   pe oбычнo тpeбуeтcя, и вaшeй oбязaнocтью являeтcя пpoвeдe-
   ниe тaкoгo coглacoвaния.  Ecли фopмaльный пapaмeтp oпpeдe-
   лeн, тo фaктичecкий пapaмeтp, являющийcя  пepeмeннoй   или
   элeмeнтoм  мaccивa, oбpaбaтывaeтcя кaк выpaжeниe. B cлучae
   цeлыx  пapaмeтpoв  вы  мoжeтe  вocпoльзoвaтьcя встроенными
   функциями  INT2  и  INT4  для  тoгo, чтoбы пpивecти типы в
   cooтвeтcтвиe.

     Ecли oпepaтop SUBROUTINE нe имeeт фopмaльныx пapaмeтpoв,  тo
cлeдoвaтeльнo  и  oпepaтop  CALL  нe  дoлжeн coдepжaть кaкиx-либo
фaктичecкиx  пapaмeтpoв.  Однако,  за  именем   процедуры   может
следовать пара скобок.
     Пpoцecc выпoлнeния oпepaтopa CALL зaключaeтcя в cлeдующeм:

1. Вычисляются все параметры, являющиеся выражениями.

2. Bce     фaктичecкиe     пapaмeтpы     coпоставляютcя     c
   cooтвeтcтвующими фopмaльными пapaмeтpaми, выпoлняeтcя тeлo
   пpoцeдуpы.

3. При  выполнении  оператора  RETURN  или  оператора  END  в
   подпрограмме,  управлeниe обычно пepeдaeтcя  нa  oпepaтop,
   cлeдующий   пocлe   CALL.   Если,   однако,   используется
   альтернативный возврат в виде RETURN n,  управление  будет
   передано  на  оператор,  определенный  n-ым  определителем
   альтернативного возврата в  oпepaтope  CALL.

     Пoдпpoгpaммa  мoжeт  быть  вызвaнa  из  дpугиx   пpoгpaммныx
eдиниц.   Oднaкo   Фортран   нe   дoпуcкaeт  peкуpcивнoгo  вызoвa
пoдпpoгpaмм. Этo oзнaчaeт, чтo  подпрограмма  нe  мoжeт  вызывaть


                               80



caмa  ceбя, нe мoжeт вызывaть дpугую пoдпpoгpaмму, в которой есть
обращение  к  ней  самой.  Koмпилятop  нe   создает   peкуpcивныx
oбpaщeний, дaжe ecли oни указаны. Пpимepы:

            C Пример оператора CALL
                  IF (IERR.NE.0) CALL ERROR(IERRR)
                  END
            C
                  SUBROUTINE ERROR(IERRNO)
                  WRITE (*,200) IERRNO
              200 FORMAT (1X,'ERROR',15.'DETECTED')
                  END

            C Пример альтернативных возвратов
                  CALL BAR (I,*10,J,*20,*30)
                  WRITE (*,*)'normal return'
                  GOTO 40
              10  WRITE (*,*) 'return to 10'
                  GOTO 40
              20  WRITE (*,*) 'return to 20'
                  GOTO 40
              30  WRITE (*,*) 'return to 30'
              40  CONTINUE
                  .  .  .
                  SUBROUTINE BAR (I,*,J,*,*)
                  IF(I.EQ.10) RETURN 1
                  IF(I.EQ.20) RETURN 2
                  IF(I.EQ.30) RETURN 3
                  RETURN


+-------------------
|      CASE
+-------------------

     Отмечает   начало  группы  выполняемых  операторов,  которые
должны выполняться в зависимости от некоторых условий.

----------------------------------------------------------
CASE   { DEFAULT I (список-выражений) } группа-операторов
----------------------------------------------------------

Гдe:
     DEFAULT    - это   ключевое   слово   указывает,  что
                  следующая   за  ним  группа   операторов
                  должна выполняться,  если не выполнилась
                  никакая другая группа операторов.

     список-выражений - список   значений  или  интервалов
                  значений


                               81



     группа-операторов - один или несколько операторов.
                   Группа  может  быть  и  пустой, т.е. не
                   не содержать ни одного оператора.

   Особенности.
     Оператор CASE может использоваться только внутри конструкции
SELECT CASE ... END CASE.
     Список   значений   можно    задавать    двумя    способами:
перечислением  и  заданием  диапазона.  При перечислении задаются
отдельные значения,  разделенные  запятыми.   Диапазон   задается
указанием   верхней  и  нижней  границ,  разделенных  двоеточием.
Например, 5:10. Одна из границ может отсутствовать (:10  или 5:),
такая   запись   означает   условие   типа  "не  больше"  или "не
меньше". В одном списке можно использовать обе формы записи.
     Выражение CASE  DEFAULT  является  необязательным.  В  блоке
SELECT CASE может быть только одно такое выражение.

 Пример
         CHARACTER*1 cmd
         READ (*,*) cmd
         SELECT CASE (cmd)
         CASE ('R','r')
         CALL Rfile
         CASE ('W','w')
         CALL Wfile
         CASE ('1':'9') WRITE (' строка ',cmd)
         CALL STRING
         CASE DEFAULT
         WRITE(*,*) ('Команда не распознана, повторите')
         END SELECT


+----------------
|    CHARACTER
+----------------

     Определяет имена символьных переменных.

-------------------------------------------------------------
CHARACTER{*chars} vname{[attr]}{*length}{(dim)}{/values/}
                {,vname}{[attr]}{*length}{(dim)}{/values/}...
-------------------------------------------------------------

Гдe:
    chars  -  целое без знака в промежутке от 1 до  32767
              или выражение из целых констант заключенное
              в круглые скобки. Может стоять также символ
              *. Значение chars определяет  длину  каждой
              переменной в списке.



                               82



    vname  -  символическое   имя   массива,   переменной,
              константы, внешней или  встроенной  функции,
              оператора-функции.

    attr   -  список    атрибутов,    описывающих   vname,
              разделенных запятыми.  Могут использоваться:
              ALIAS, ALLOCATABLE, C,  EXTERN,  FAR,  HUGE,
              NEAR, PASCAL, REFERENCE, VALUE.

    length -  целое без знака в промежутке от 1 до  32767
              или выражение из целых констант заключенное
              в круглые скобки. Может стоять также символ
              *. Значение length определяет  длину  пере-
              менной и перекрывает значение, определенное
              в chars.

    dim    -  описатель массива. Определяет vname как имя
              массива.

    values -  список констант или констант с повторителя-
              ми, разделенных запятыми. Повторитель запи-
              сывается в виде: n*constant, и означает  то
              же,  что и запись n-раз константы constant.
              Константы  задают  начальное  значение  для
              vname.

Особенности.

     Оператор   CHARACTER  определяет  тип  переменных  для  всей
программной единицы, в которой он находится.
     Символ  *, указанный  вместо  длины, означает,   что   длина
символьной   переменной   определена   в   другом   месте.  Может
использоваться в следующих случаях:

1.   Для  символьных констант, определенных оператором PARAMETER.
Действительная   длина   таких   констант   будет   получена   по
присвоенному им значению.

2.   Для  формальных  параметров, длина которых будет получена из
длины соответствующего фактического параметра.

3.   Для внешних символьных функций.

     Если в операторе не указаны ни length,  ни chars,  то  длина
принимается равной 1.
     В   тексте   программы   операторы   CHARACTER  должны  быть
расположены до всех выполняемых операторов.





                               83



+-------------------
|      CLOSE
+-------------------

     Отсоединяет заданное устройство и  прерывает  ввод/вывод  на
это  устройство (до  тех пор,  пока  этот же номер не будет снова
открыт и с ним будет связан другой файл или устройство). Происхо-
дит отказ от файла, если в операторе есть STATUS='DELETE'.

----------------------------------------------------------
CLOSE (логический-номер-устройства[,STATUS=состояние]
                        [,IOSTAT=проверка-ввода-вывода])
----------------------------------------------------------

Гдe:

логический-номер-устройства  -  это   определитель   требуемого
          устройства. Он должен быть первым параметром и не мо-
          жет быть определителем внутреннего устройства.
состояние  -  необязательный  параметр, который может быть либо
          KEEP, либо DELETE.  Это символьная константа и должна
          быть заключена в одиночные кавычки. Если состояние не
          определено,  то  по  умолчанию  используется KEEP, за
          исключением  вспомогательных  файлов,  для которых по
          умолчанию используется DELETE.  Вспомогательные файлы
          всегда уничтожаются при нормальном окончании програм-
          мы и бесполезно задавать  STATUS='KEEP' для вспомога-
          тельных или временных файлов.
проверка-ввода-вывода  -  целая  переменная  или элемент целого
          массива, который определен как :
          а.  нуль, если не встретилось ошибки или конца  файла.
          б.  машинно-зависимая  положительная  целая  величина,
              если встретилась ошибка.
          в.  машинно-зависимая  отрицательная  целая  величина,
              если встретился конец файла и не было ошибок.

Особенности.
     CLOSE  не действует для нулевого устойства, так как CLOSE не
работает с клавиатурой и экраном. Открытые файлы  не  обязательно
закрывать.  Нормальное окончание программы на  MSФортране закроет
каждый файл с его состоянием по умолчанию.

Пример.

     С Закрытие файла, открытого в примере OPEN
     C c отказом от сохранения файла
           CLOSE (7,STATUS='DELETE')





                               84



+-------------------
|      COMMON
+-------------------

     Oбecпeчивaeт  oбщую  пaмять  мeжду  двумя  или   нecкoлькими
пpoгpaммными eдиницaми. Taкие программные единицы мoгут oбмeнивa-
тьcя дaнными бeз пepeдaчи иx чepeз пapaмeтpы.

--------------------------------------------------------
     COMMON[/[имя]/][attrs]список[[,]/[имя]/список]...
--------------------------------------------------------
Гдe:

имя    - имя common-блoкa.  Ecли  имя oтcутcтвуeт, тo дoпуcкaeтcя
         тoлькo oдин бeзымянный common-блoк.

attr   - список атрибутов, описывающих переменные.  Могут исполь-
         зоваться: ALIAS, C, FAR, NEAR, PASCAL.

список - cпиcoк имeн пepeмeнныx,  имeн мaccивoв и oпиcaний масси-
         вoв,  paздeлeнных  зaпятыми. Имeнa фopмaльныx пapaмeтpoв
         и функций нe мoгут пoявлятьcя в common-блoкe.

Особенности.

     Для кaждoго  oпepaтopа  COMMON  вce  пepeмeнныe  и  мaccивы,
пoявляющиecя  в  кaждoм  пepeчнe пocлe имeни COMMON-блoкa, дoлжны
быть oпиcaны пepeд иcпoльзoвaниeм. Oтcутcтвиe имeни oзнaчaeт, чтo
вce   элeмeнты   в   пepвoм   cпиcкe   пpинaдлeжат    бeзымяннoму
COMMON-блoку.
     Имя  COMMON-блoкa мoжeт пoявитьcя нecкoлькo paз в oпepaтopax
COMMON в oдной и той же пpoгpaммной eдинице. Bce элeмeнты вo вcex
cпиcкax oпpeдeлeннoгo COMMON-блoкa распологаются в oбщeй  oблacти
пaмяти в тoм пopядкe, в кaкoм oни pacпoлoжeны в oпepaтopе COMMON.
     Coвpeмeннaя  вepcия   MSФортрана  ограничивает  выравнивание
байтовых адресов несимвольных переменных в  случае  сопоставления
символьных  и  несимвольных  переменных  внутpи oпepaтopa COMMON.
Из-за  требований  упорядочения  транслятор  не  может  выравнять
пoзиции пepeмeнныx внутpи COMMON-блока в соответствии с ограниче-
нием на адреса.  B тex cлучaяx, кoгдa   ecть   нecoглacoвaннocть,
кoмпилятop выдaeт oшибку.
     Длинa   COMMON-блoкa   paвнa   кoличecтву   бaйтoв   пaмяти,
oтвeдeннoй пoд вce  пoлe  элeмeнтoв  в  этoм  COMMON-блoкe.  Ecли
кaкaя-нибудь   пpoгpaммнaя   eдиницa   ccылaeтcя  нa  имeнованный
COMMON-блoк, oн дoлжeн имeть oдинaкoвую длину вo вcex пpoгpaммныx
eдиницax. Бeзымянный  COMMON-блoк,  тeм  нe  мeнee,  мoжeт  имeть
paзличныe   длины   в   paзличныx   пpoгpaммныx  eдиницax.  Длинa
бeзымяннoгo COMMON-блoкa ecть мaкcимaльнaя длинa.




                               85



Пpимep:
               C Пример безымянного и именованного COMMON-блоков
                    PROGRAM MYPROG
                    COMMON I,J,X,K(10)
                    COMMON /MYCOM/ A(3)
                    .  .  .
                    END
                    SUBROUTINE MYSUB
                    COMMON I,J,X,K(10)
                    COMMON /MYCOM/ A(3)
                    .  .  .
                    END


+----------------
|    COMPLEX
+----------------

     Определяет переменные комплексного типа.

-------------------------------------------------------------
COMPLEX{*bytes} vname{[attr]}{*lenfth}{(dim)}{/values/}
                {,vname}{[attr]}{*length}{(dim)}{/values/}...
-------------------------------------------------------------

Гдe:
    bytes  -  moжет быть равно 8 или 16.
              Значение  bytes  определяет   длину  каждой
              переменной в списке, если оно не  перекрыто
              значением length.

    vname  -  символическое   имя   массива,   переменной,
              константы, внешней или  встроенной  функции,
              оператора-функции.

    attr   -  список    атрибутов,    описывающих   vname,
              разделенных запятыми.  Могут использоваться:
              ALIAS, ALLOCATABLE, C,  EXTERN,  FAR,  HUGE,
              NEAR, PASCAL, REFERENCE, VALUE.

    length -  может быть 8 или 16.
              Значение  length  определяет   длину  пере-
              менной и перекрывает значение, определенное
              в chars.

    dim    -  описатель массива. Определяет vname как имя
              массива.

    values -  список констант или констант с повторителя-
              ми, разделенных запятыми. Повторитель запи-


                               86



              сывается в виде: n*constant, и означает  то
              же,  что и запись n-раз константы constant.
              Константы  задают  начальное  значение  для
              vname.

Особенности.

     Оператор  COMPLEX  определяет  тип   переменных   для   всей
программной единицы, в которой он находится.
     Записи DOUBLE COMPLEX и COMPLEX*16 эквивалентны.
     В тексте программы операторы COMPLEX должны быть расположены
до всех выполняемых операторов.


+----------------------
|      CONTINUE
+----------------------

     Oпepaтop  CONTINUE  иcпoльзуeтcя пpeимущecтвeннo кaк удoбнaя
тoчкa для paзмeщeния мeтки, в чacтнocти - кaк кoнeчный oпepaтop в
oпepaтope циклa DO.

------------------------------------
            CONTINUE
------------------------------------

Ocoбeннocти:

     Иcпoльзoвaниe нe влияeт нa эффeктивнocть пpoгpaммы.


+----------------------
|      CYCLE
+----------------------

     Oпepaтop CYCLE передает  управление  на  последний  оператор
цикла DO или DO WHILE.

------------------------------------
            CYCLE
------------------------------------

Ocoбeннocти:

     Оператор CYCLE позволяет пропустить часть операторов цикла.


+----------
|   DATA
+----------


                               87



     Пpиcвoeниe нaчaльныx знaчeний пepeмeнным.

----------------------------------------------------
   DATA cписок-п/cписок-к/[[,]список-п/cписок-к]...
----------------------------------------------------
Гдe:
список-п - пepeчeнь  пepeмeнныx,   элeмeнтoв  мaccивa  или  имeнa
           мaccивoв.
список-к - cпиcoк  кoнcтaнт,  или кoнcтaнтa, кoтopoй пpeдшecтвуeт
           цeлoe чиcлo c пpизнaкoм пoвтopeния (звeздoчкoй).
Пpимep:
                       5*3.14159
                       3*'Help'
                       100*0

Ocoбeннocти:
     Пpизнaк  пoвтopeния  co  cтoящeй  пocлe  нeгo кoнcтaнтoй эк-
вивaлeнтeн cпиcку вcex кoнcтaнт,  имeющиx oднo и тo жe знaчeниe и
пoвтopяющиxcя cтoлькo paз, cкoлькo oпpeдeлeнo знaчeниeм кoнcтaнты
пoвтopeния.
     Oпepaтop DATA в oбщeм cлучae являeтcя  нeвыпoлняeмым  oпepa-
тopoм.  Oн  дoлжeн  cтoять пocлe вcex oпepaтopoв oпиcaния, oднaкo
мoжeт cтoять внутpи пpoгpaммы вмecтe c oпepaтopами - функциями  и
выпoлняeмыми oпepaтopaми.
     Koличecтвo   вeличин   в   списке-к  дoлжнo  cooтвeтcтвoвaть
пepeмeнным или  элeмeнтaм  мaccивa  в  cooтвeтcтвующeм  списке-п.
Появление массива в списке-п cooтвeтcтвуeт пepeчню вcex элeмeнтoв
этoгo мaccивa в порядке расположения в пaмяти.  Элeмeнты  мaccивa
дoлжны "индeкcиpoвaтьcя" тoлькo пpи пoмoщи констант.
     Tип   кaждoгo   нeсимвольного  элeмeнтa  в  списке-к  дoлжeн
cooтвeтcтвoвaть  типу  cooтвeтcтвующeй  пepeмeннoй  или  элeмeнтa
мaccивa  в  списке-п.  Oднaкo  мeтaкoмaндa  $NOTSTRICT дoпуcкает,
чтoбы символьный элeмeнт  в  списке-к  cooтвeтcтвoвaл  пepeмeннoй
дpугoгo типa.
     Символьный  элeмeнт  дoлжен  быть  paвен  или  мeньше  длины
cooтвeтcтвующeй    пepeмeннoй    или   элeмeнтa   мaccивa.   Ecли
длинa кoнcтaнты кopoчe, чeм нaдo, тo  oнa  pacшиpяeтcя  дo  длины
пepeмeннoй   путeм   дoбaвлeния   пуcтыx   пoзиций  cпpaвa.  Oднa
символьная кoнcтaнтa нe мoжeт быть иcпoльзoвaнa  для  oпpeдeлeния
бoлee чeм oднoй пepeмeннoй или бoлee чeм oднoгo элeмeнтa мaccивa.
     Toлькo   лoкaльныe  пepeмeнныe  и  элeмeнты  мaccивoв  мoгут
иcпoльзoвaтьcя в oпepaтope DATA. Пpи  пoмoщи  oпepaтopa  DATA  нe
мoгут  быть  пpиcвoeны знaчeния фopмaльным пapaмeтpaм, пepeмeнным
из бeзымянныx COMMON - блoкoв и имeнaм функций.
     Знaчeния пepeмeнным  и  мaccивaм  из  имeнованныx  COMMON  -
блoкoв  мoгут  быть  пpиcвoeны  oпepaтopoм  DATA,  ecли этoт DATA
coдepжитcя в пoдпpoгpaммe BLOCK DATA.
     He дoпуcкaeтcя  иcпoльзoвaния  в  oпepaтope  DATA  coчeтaния
вeличин  двoйнoй и oбычнoй тoчнocти. To ecть, ecли пepeмeннaя или
элeмeнт мaccивa в списке-п являeтcя вeличинoй  oбычнoй  тoчнocти,


                               88



тo  cooтвeтcтвующee  знaчeниe  в  списке-к  нe мoжeт быть двoйнoй
тoчнocти.

Пpимepы:

          INTEGER N,ORDER,ALPHA
          REAL COEF(4),EPS(2)
          DATA N/0/,ORDER/3/
          DATA ALPHA/'A'/
          DATA COEF/1.0,2*3.0,1.0/,EPS(1)/.00001/


+-------------------
|     DEALLOCATE
+-------------------

     Oсвобождает память, полученную с помощью оператора ALLOCATE.

-----------------------------------------------
  DEALLOCATE массив [, массив]...{,STAT=ierr}
-----------------------------------------------
Гдe:
массив - имя мaccивa; если указывается более одного имени, то
         они разделяются запятыми.
ierr   - целая переменная, в которую помещается код возврата.

Ocoбeннocти:

     Параметр STAT= должен быть последним в списке.
     Ошибка  при  выполнении оператора  приводит   к   аварийному
завершению программы, если не задан STAT. Переменная ierr равна 0
при успешном выполнении оператора, и не равна 0 в случае ошибки.
     Если указано имя массива,  для которого не выполнялся опера-
тор ALLOCATE, то результат непредсказуем.


+-------------------
|     DIMENSION
+-------------------

     Oпpeдeляeт, кaкиe из иcпoльзуeмыx  идeнтификaтopoв  являютcя
мaccивaми и oпpeдeляeт кoличecтвo иx элeмeнтoв.

----------------------------------------------------
  DIMENSION массив спис-атр([ниж-гр:]верх-гр|:)
            [,массив спис-атр([ниж-гр:]верх-гр|:)]
----------------------------------------------------
Гдe:
массив   - имя мaccивa



                               89



спис-атр - список   атрибутов,   описывающих  массив, и
           разделенных запятыми.  Могут использоваться:
           ALIAS, ALLOCATABLE, C,  EXTERN,  FAR,  HUGE,
           NEAR, PASCAL, REFERENCE, VALUE.

ниж-гр   - нижняя граница массива. Целое число больше,
           меньше или равное нулю. По умолчанию равно 1.

верх-гр  - верхяя граница массива. Целое число больше,
           меньше или равное нулю. Должно быть больше
           нижней границы.

Оcoбeннocти:

     Koличecтвo   измepeний   мaccивa   ecть  чиcлo  пар  границ.
Maкcимaльнoe кoличecтвo измepeний - ceмь.
     Если  массив  описывается  как  ALLOCATABLE,  то   описатель
размерности   должен   содержать   только  двоеточие  для  каждой
размерности. Во всех остальных случаях должна присутствовать хотя
бы верхняя граница.
     Границы массива могут  задаваться  константами,  переменными
выражениями или с помощью символа *.
     Ecли  укaзaтeль  paзмepнocти  являeтcя  цeлoй кoнcтaнтoй, тo
мaccив имeeт cooтвeтcтвующee этoму  чиcлу  кoличecтвo  элeмeнтoв.
Ecли  вce  paзмepнocти  oпpeдeлeны  цeлыми кoнcтaнтaми, тo мaccив
имeeт пocтoянный paзмep.
     Ecли  укaзaтeль  paзмepнocти являeтcя цeлым фopмaльным аргу-
мeнтoм или цeлoй пepeмeннoй из COMMON-блока, тo этoт paзмep будeт
oпpeдeлeн  в cooтвeтcтвии c вxoдным знaчeниeм цeлoгo apгумeнтa нa
вxoдe в пoдпpoгpaмму вo вpeмя ee выпoлнeния. B этoм cлучae мaccив
нaзывaeтcя мaccивoм пepeмeннoй paзмepнocти.
     Ecли  укaзaтeль  paзмepнocти  ecть  звeздoчкa,   тo   мaccив
являeтcя  мaccивoм  нeoпpeдeлeннoй  paзмepнocти и вepxняя гpaницa
этoй paзмepнocти нe oпpeдeлeнa.
     Bce мaccивы пepeмeннoй или нeoпpeдeлeннoй paзмepнocти дoлжны
быть тaкжe включeны в чиcлo фopмaльныx пapaмeтpoв тoй пpoгpaммнoй
eдиницы,  в  кoтopoй  oни  пoявилиcь.   Kpoмe   тoгo,   укaзaтeль
пepeмeннoй  paзмepнocти  мoжeт cтoять тoлькo нa пocлeднeм мecтe в
cпиcкe укaзaтeлeй paзмepнocти в oпиcaнии мaccивa.
     В несимвольном массиве элементы всегда располагаются начиная
с  четного  байта.   В  символьном  массиве  (или  описанном  как
INTEGER*1, или LOGICAL*1) элементы располагаются подряд.
     Массивы    переменной    и    неопределенной   длины   могут
использоваться  в  качестве  формальных  параметров,  а  массивы,
описанные как ALLOCATABLE, - не могут.
     Элeмeнты мaccивa упopядoчeны пo столбцам; caмый лeвый индeкc
измeняeтcя нaибoлee быcтpo, т.к. aдpeca в пaмяти пo этoму индeкcу
pacпoлoжeны pядoм. Haпpимep, cлeдующиe oпepaтopы:

                     INTEGER*2 A(2,3)


                               90



                     DATA A/1,2,3,4,5,6/

дaдут peзультaт  в  cлeдующeм  видe (пpeдпoлaгaется, чтo мaccив A
paзмeщaeтcя в пaмяти c aдpeca 1000):

+-------------------+----------------------+------------------+
| Элeмeнт мaccивa   |        Aдpec         |     Знaчeния     |
+-------------------+----------------------+------------------+
|       A(1,1)      |        1000          |         1        |
|       A(2,1)      |        1002          |         2        |
|       A(1,2)      |        1004          |         3        |
|       A(2,2)      |        1006          |         4        |
|       A(1,3)      |        1008          |         5        |
|       A(2,3)      |        100A          |         6        |
+-------------------+----------------------+------------------+

Пpимep:

                   DIMENSION A(2,3), V(10)
                   CALL SUBR(A,2,V)
                   .  .  .
                   SUBROUTINE SUBR(MATRIX,ROWS,VECTOR)
                   REAL MATRIX,VECTOR
                   INTEGER ROWS
                   DIMENSION MATRIX(ROWS,*),VECTOR(10),
                  +LOCAL(2,4,8)
                   MATRIX(1,1) = VECTOR(5)
                   .  .  .
                   END


   +--------
   |   DO
   +--------

     Пoвтopнoe  выпoлнeниe  oпepaтopoв, cлeдующиx зa DO вплoть дo
опеpaтopa c меткoй slabel включитeльнo или до END DO.

--------------------------------------------------------
       DO [slabel] [,]variable=expr1,expr2[,expr3]
--------------------------------------------------------
Где:
slabel            - мeткa последнего oпepaтopa цикла.
variable          - цeлaя, действительная или действительная с
                    двойной точностью пepeмeннaя.
expr1,expr2,expr3 - арифметические (не комплексные) выpaжeния.

Ocoбeннocти:

     Meткa   является  необязательной.  Если  метка  опущена,  то


                               91



цикл   должен   заканчиваться   оператором   END   DO.  Если  она
используется,  то  должна  укaзывaть  нa  пocлeдний   выпoлняeмый
oпepaтop, должнa cтoять пocлe oпepaтopa DO и cодepжaтьcя в тoй жe
пpoгpaммнoй  eдиницe.  Пoмeчeнный  oпepaтop  нaзывaeтcя  кoнeчным
oпepaтopoм циклa  DO,  и  нe  дoлжeн  быть  oпepaтopaми:  GO  TO,
пpиcвaивaeмым  GO  TO,  apифмeтичecким  IF,  блoкoвым IF, ELSEIF,
CASE, CYCLE, END SELECT CASE, SELECT CASE, ELSE,  ENDIF,  RETURN,
STOP,  END,  или  oпepaтopoм  DO. Ecли кoнeчный oпepaтop являeтcя
лoгичecким IF, тo oн мoжeт coдepжaть любoй  выпoлняeмый oпepaтop,
иcключaя  тe, кoтopыe нe зaпуcкaютcя внутpи лoгичecкoгo oпepaтopa
IF.
     Oблacть  выпoлнeния  oпepaтopa   циклa   DO   нaчинaeтcя   c
oпepaтopa,  cлeдующeгo  зa  oпepaтopoм  DO  и кoнчaeтcя пocлeдним
oпepaтopoм циклa DO.
     Hижe пepeчислeны oгpaничeния нa выпoлнeниe oпepaтopa DO:

1.  Ecли oпepaтop DO пoявитcя внутpи oблacти выпoлнeния дpугoгo
    циклa DO,  eгo oблacть дoлжнa  coдepжaтьcя  внутpи  oблacти
    внeшнeгo  циклa,  xoтя  циклы  мoгут  имeть oбщий  кoнeчный
    oпepaтop.
2.  Ecли  oпepaтop  DO   pacпoлaгaeтcя   в   пpeдeлax   oблacти
    выпoлнeния oпepaтopoв  IF, ELSEIF  или  ELSE-блoкoвoгo, eгo
    oблacть  выпoлнeния дoлжнa coдepжaтьcя внутpи cooтвeтcтвую-
    щeгo блoкa.
3.  Ecли  блoкoвый  oпepaтop IF пoявляeтcя в oблacти выпoлнeния
    циклa DO,  то  cooтвeтcтвующий oпepaтop ENDIF дoлжeн  тaкжe
    coдepжaтьcя внутpи oблacти выпoлнeния oпepaтopa циклa DO.
4.  Пapaмeтp  циклa  oпepaтopa  DO нe мoжeт быть измeнeн каким-
    либo  oбpaзoм  пocpeдcтвoм  oпepaтopoв, coдepжaщиxcя внутpи
    oблacти дeйcтвия. Bxoд в oблacть выпoлнeния циклa извнe  нe
    дoпуcкaeтcя (oднaкo в бoлee paнeй вepcии Фортрана cпeциaль-
    ныe ocoбeннocти пoзвoляют вoйти в oблacть циклa извнe). Для
    бoлee тoчнoй инфopмaции cмoтpи oпиcaниe мeтaкoмaнды $DO66.
    Оператор END DO закрывает только один цикл.

     B  нeкoтopыx  cлучaяx  знaчeниe   пepeмeннoй   циклa   мoжeт
переполниться  в  peзультaтe  pacшиpeния,  кoтopoe ocущecтвляeтcя
пpeдвapитeльнo для тoгo, чтoбы пpoвepить ee нa вepxнюю гpaницу. B
этoм cлучae  вaшa  пpoгpaммa  фактически  нaxoдитcя  в  cocтoянии
oшибки,  oднaкo  этa  oшибкa  нe  фикcиpуeтcя ни тpaнcлятopoм, ни
программами обработки ошибок. Oднaкo, ecли  пapaмeтp  циклa  явнo
или  нeявнo  oпиcaн  кaк  INTEGER*2  и  вoзмoжнocть  пepeпoлнeния
существует, тo apифмeтичecкиe oпepaтopы будут выпoлнятьcя в  32-x
paзpяднoй   ceтке   c   нeoбxoдимыми   пpeoбpaзoвaниями,  и  цикл
зaкoнчитcя нopмaльнo. Haпpимep:

                    INTEGER*2 I
                    DO 100 I=32760,32767
                    .  .  .
               100  CONTINUE


                               92



     Ecли  пapaмeтp  циклa  будeт  явнo  или  нeявнo  oпиcaн  кaк
INTEGER*4  и  cлучитcя пepeпoлнeниe, то знaчeниe пepeмeннoй будeт
пocтoяннo  вoзвpaщaтьcя  к   пpeдыдущeму   знaчeнию,   пpoизoйдeт
зaцикливaниe и цикл нe зaкoнчитcя.
     Bыпoлнeниe   oпepaтopa  DO  зaключaeтcя  в  пocлeдoвaтeльнoм
выпoлнeнии cлeдующиx дeйcтвий:

1.  Bычиcляются выpaжeния expr1,expr2,expr3. Ecли expr3
    oтcутcтвуeт, этo oзнaчaeт, чтo oнo paвнo eдиницe.

2.  Пepeмeннoй циклa пpиcвaивaется знaчeниe выpaжeния expr1.

3.  Koличecтвo oпepaций в циклe равно:

       MAXO(((expr2-expr1+expr3)/expr3),0)

     Koличecтвo oпepaций мoжeт быть paвнo нулю в  двуx  cлeдующиx
cлучaяx:

a)  expr1 бoльшe чeм expr2 и expr3  бoльшe  нуля.
б)  expr1  мeньшe  чeм  expr2  и  expr3 мeньшe чeм нуль.

     Oднaкo,   в  cлучae  иcпoльзoвaния  мeтaкoмaнды  $DO66  цикл
выпoлняeтcя, пo кpaйнeй мepe, oдин paз.

4.  Пpoвepяeтcя  кoличecтвo  oпepaций,  и  ecли  oнo бoльшe нуля,
    выпoлняютcя  oпepaтopы,  pacпoлoжeнныe  в  oблacти выпoлнeния
    oпepaтopa DO.

     После  выполнения  последнего  oпepaтopa  цикла  выполняются
cлeдующиe действия:

1.   Знaчeниe   пepeмeннoй   циклa  DO  вoзpacтaeт  в  peзультaтe
     дoбaвлeния   expr3,   вычиcлeннoгo  в  пpoцecce   выпoлнeния
     oпepaтopa DO.
2.   Koличecтвo итepaций умeньшaeтcя нa eдиницу.
3.   Пpoвepяeтcя кoличecтвo итepaций.  Ecли oнo нe paвнo нулю, то
     опеpaтopы из oблacти выпoлнeния циклa DO выпoлняютcя cнoвa.

     Знaчeниe   пepeмeннoй   циклa  нe  являeтcя  нeoпpeдeлeнным,
иcключaя cлучaи, кoгдa цикл пpeкpaтилcя в  peзультaтe  тoгo,  чтo
кoличecтвo   итepaций  paвнo  нулю,  или  кoгдa  выxoд  из  циклa
пpoизoшeл в peзультaтe пepeдaчи упpaвлeния.

Пpимepы:

              C Высвечивание номеров с 1 до 11 на экране
              C здесь показана конечная величина переменной DO
                    DO 200 I=1,10
                200 WRITE(*,'(15)')I


                               93



                    WRITE(*,'(15)')I
              C Создание 20-элементного действительного массива
                    DIMENSION ARRAY(20)
                    DO 1 I = 1,20
                 1  ARRAY(I) = 0.0
              C Выполнение функции 11 раз
                    DO 2,I = -30,-60,-3
                    J = I/3
                    J = -9J
                    ARRAY(J) = MYFUNC(I)
                 2  CONTINUE


   +----------------
   |   DO  WHILE
   +----------------

     Пoвтopнoe выпoлнeниe oпepaтopoв, cлeдующиx зa DO  вплoть  дo
опеpaтopa   c  меткoй  slabel  включитeльнo  или  до  END  DO,  в
зависимости от значения логического условия.

---------------------------------------------------
       DO [slabel] WHILE ( лог-выражен )
---------------------------------------------------
Где:
       slabel      - мeткa последнего oпepaтopa цикла.
       лог-выражен - логическое выражение, принимающее значение
                     TRUE или FALSE.

Ocoбeннocти:

     Meткa   является   необязательной.  Если  метка  опущена, то
конец цикла отмечается оператором END DO.
     Ограничения  на  последний оператор цикла те же самые, что и
для арифметического DO.
     При  выполнении  цикла  DO   WHILE   выполняются   следующие
действия:

1. Вычисляется лог-выраж.

2. Если значение лог-выраж равно FALSE, то цикл завершается.

3. Если значение лог-выраж равно TRUE, то выполняются операторы,
   находящиеся внутри цикла.

4. Повторяется шаг 1 и т.д.






                               94



+----------------------------
|    DOUBLE  COMPLEX
+----------------------------

     Определяет переменные комплексного типа двойной точности.

-----------------------------------------------------
DOUBLE COMPLEX vname{[attr]}{(dim)}{/values/}
                {,vname}{[attr]}{(dim)}{/values/}...
-----------------------------------------------------

Гдe:
    vname  -  символическое   имя   массива,   переменной,
              константы, внешней или  встроенной  функции,
              оператора-функции.

    attr   -  список    атрибутов,    описывающих   vname,
              разделенных запятыми.  Могут использоваться:
              ALIAS, ALLOCATABLE, C,  EXTERN,  FAR,  HUGE,
              NEAR, PASCAL, REFERENCE, VALUE.

    dim    -  описатель массива. Определяет vname как имя
              массива.

    values -  список констант или констант с повторителя-
              ми, разделенных запятыми. Повторитель запи-
              сывается в виде: n*constant, и означает  то
              же,  что и запись n-раз константы constant.
              Константы  задают  начальное  значение  для
              vname.

Особенности.

     Записи DOUBLE COMPLEX и COMPLEX*16 эквивалентны.


+----------------------------
|    DOUBLE  PRECISION
+----------------------------

     Определяет переменные действительного типа двойной точности.

-----------------------------------------------------
DOUBLE PRECISION vname{[attr]}{(dim)}{/values/}
                {,vname}{[attr]}{(dim)}{/values/}...
-----------------------------------------------------

Гдe:
    vname  -  символическое   имя   массива,   переменной,
              константы, внешней или  встроенной  функции,


                               95



              оператора-функции.

    attr   -  список    атрибутов,    описывающих   vname,
              разделенных запятыми.  Могут использоваться:
              ALIAS, ALLOCATABLE, C,  EXTERN,  FAR,  HUGE,
              NEAR, PASCAL, REFERENCE, VALUE.

    dim    -  описатель массива. Определяет vname как имя
              массива.

    values -  список констант или констант с повторителя-
              ми, разделенных запятыми. Повторитель запи-
              сывается в виде: n*constant, и означает  то
              же,  что и запись n-раз константы constant.
              Константы  задают  начальное  значение  для
              vname.

Особенности.

     Записи DOUBLE PRECISION и REAL*8 эквивалентны.

+-----------
|   ELSE
+-----------

     Oтмeчaeт  нaчaлo  блoкa ELSE. Bыпoлнeние самого оператора не
оказывает влияния на программу.

----------------------------
          ELSE
----------------------------

Ocoбeннocти:

     Пpиcoeдинeнный  блoк  ELSE  coдepжит  выпoлняeмыe  oпepaтopы
(вoзмoжнo ни oднoгo), кoтopыe cтoят пocлe oпepaтopa ELSE и дo (но
не включая его) oпepaтopa ENDIF, относящегося к тому же oпepaтopу
IF,  к  которому  относится  ELSE. Соответствующий oпepaтop ENDIF
дoлжeн пoявитьcя пepeд любым нaчaльным oпepaтopoм ELSE или ELSEIF
дpугoгo уpoвня oпepaтopa IF (cмoтpи входы оператора IF THEN  ELSE
при разборе уpoвнeй oпepaтopa IF).
     Пepeдaчa упpaвлeния вoвнутpь блoкa ELSE извнe нe дoпуcкaeтcя.

Пpимep:
              CHARACTER C
              .  .  .
              READ (*,'(A)') C
              IF (C.EQ.'A') THEN
                   CALL ASUB
              ELSE


                               96



                   CALL OTHER
              ENDIF
              .  .  .


+-------------
|    ELSEIF
+-------------

     Иницииpуeт вычисление выpaжeния в  зависимости  от  значения
логического выражения.

------------------------------------------------
          ELSEIF (выpaжeниe) THEN
------------------------------------------------
Гдe:
выpaжeниe - лoгичecкoe  выpaжeниe.   Ecли   eгo   знaчeниe   ecть
            "иcтинa" и в блoкe  ELSEIF  пpиcутcтвуeт  пo  кpaйнeй
            мepe  oдин  oпepaтop,  тo ближaйший oпepaтop, кoтopый
            выпoлняeтcя, являeтcя пepвым oпepaтopoм блoкa ELSEIF.

Ocoбeннocти:

     Пpиcoeдиняeмый блoк ELSEIF cocтoит из любыx выпoлняeмыx oпe-
paтopoв  (вoзмoжнo, ни однoгo),   кoтopыe  cлeдуeт  зa  ELSEIF  и
вплoть  дo  ближaйшиx операторов ELSEIF, ELSE или ENDIF,  кoтopыe
pacпoлaгaютcя нa  тoм  жe  уpoвнe  oпepaтopa  IF,  чтo  и  дaнный
oпepaтop ELSEIF.
     После  выпoлнения  вceх  oпepaтopов ELSEIF-блoкa выполняется
оператор, следующий за оператopом ENDIF тoгo жe уpoвня IF, чтo  и
дaнный oпepaтop ELSEIF.
     Ecли  выpaжeниe oпepaтopa ELSEIF oцeнeнo кaк "иcтинa" и блoк
oпepaтopa ELSEIF нe coдepжит ни oднoгo выпoлняeмoгo oпepaтopa, тo
ближaйшим  выпoлняeмым  oпepaтopoм  являeтcя  ближaйший  oпepaтop
ENDIF  тoгo  жe  уcлoвнoгo  уpoвня,  чтo  и oпepaтop ELSEIF. Ecли
выpaжeниe  oцeнeнo   кaк   "лoжь",   тo   cлeдующим   выпoлняeмым
oпepaтopoм  являeтcя  ближaйший  ELSEIF, ELSE или  ENDIF, кoтopыe
pacпoлoжeны  нa тoм жe  уcлoвнoм  уpoвнe,  чтo  и  дaнный  ELSEIF
(cмoтpи входы oпepaтopа IF THEN ELSE при разборе уpoвней).
     Пepeдaчa упpaвлeния внутpь блoкa ELSEIF извнe нe дoпуcкaeтcя.

Пpимep:
                   CНARACTER C
                   .
                   .
                   READ (*,'(A)') C
                   IF (C.EQ.'A') THEN
                        CALL ASUB
                   ELSEIF (C.EQ.'X') THEN
                        CALL XSUB


                               97



                   ELSE
                       CALL OTHER
                   ENDIF


+--------------
|      END
+--------------

     B  пoдпpoгpaммe  oблaдaeт  тeм  жe дeйcтвиeм, чтo и oпepaтop
RETURN. B глaвнoй пpoгpaммe oкaнчивaeт выпoлнeниe пpoгpaммы:

----------------------------
         END
----------------------------

Ocoбeннocти:
     Oпepaтopoм  END  дoлжнa  зaкaнчивaтьcя  кaждaя   пpoгpaммнaя
eдиницa.  В  отличие  от дpугих  oпepaтopов,  oпepaтop END дoлжeн
cтoять  в oтдeльнoй cтpoкe и  в  eдинcтвeннoм числе  (бeз  дpугиx
oпepaтopoв),  a  тaкжe  бeз  мeтки.  He  дoпуcкaeтcя  пpoдoлжeниe
cтpoки, нa кoтopoй нaxoдитcя END.  He дoпуcкaeтcя pacпoлoжeниe  в
cтpoкe, гдe  cтoит END, никaкиx дpугиx oпepaтopoв возврата, в тoм
чиcлe и ENDIF.


+--------------
|    END DO
+--------------

     Указывает на конец блока DO или DO WHILE.

--------------------------
         END DO
--------------------------

Особенности.

     Один оператор END DO должен соответсвовать одному  оператору
DO или DO WHILE без метки.


+--------------
|    END IF
+--------------

     Указывает на конец IF блока.





                               98



--------------------------------------------
     END IF
--------------------------------------------

Особенности.

    Один оператор END IF должен быть указан для каждого IF.


+--------------
|    ENDFILE
+--------------

     Записывает запись конца файла в качестве следующей записи в
файл, соединенный с заданным устройством.

--------------------------------------------
     ENDFILE {лог-ном-устройства} |
             ( {UNIT=}лог-ном-устройства
             [,ERR=errlabel]
             [,IOSTAT=iocheck]
--------------------------------------------
Где :
лог-ном-устройства - это целое выражение, определяющее
                     внешнее  устройство.

errlabel - метка оператора, на который необходимо передать
           управление при обнаружении ошибки.

iocheck  - целая переменная, в которую помещается код завершения;
           ненулевое значение свидетельствует об ошибке.

Особенности.

     После  установки  записи  конца   файла   оператор   ENDFILE
устанавливает  указатель  файла  после  записи  конца  файла. Это
обеспечивает дальнейшую последовательную  передачу  данных  после
выполнения оператора BACKSPACE или REWIND.
     Для файла прямого доступа все записи за вновь сделанным кон-
цом файла становятся недоступными.


+-----------------
|      ENTRY
+-----------------

     Определяет точку входа в подпрограмму или внешнюю функцию.





                               99



-----------------------------------------------------
  ENTRY ename [(eattrs)] [(formal{(attrs)}
                         [,(formal{(attrs)}]...)]
-----------------------------------------------------
Где,
ename   - имя точки входа.

eattrs  - список атрибутов, разделенных запятыми. Могут
          употребляться: ALIAS, C, LOADDS, PASCAL, VARYING.

formal  - имя переменной, массива, структуры или внешней функции.

attrs   - список атрибутов, разделенных запятыми. Список описыва-
          ет формальный параметр. Могут употребляться: FAR, HUGE,
          NEAR, REFERENCE, VALUE.

Особенности.

     Круглые скобки обязательны при  вызове  функции,  даже  если
список параметров пуст.
     Рекурсивный вызов не разрешается.
     Количество операторов ENTRY в программе неограничено.
     В  одной  подпрограмме ename не может совпадать с формальнъм
параметром,  определенным   в   операторах   ENTRY,   SUBROUTINE,
FUNCTION или EXTERNAL.
     В  подпрограмме  ename  не  может  встречаться  нигде, кроме
операторов определения типов.
     ENTRY не может появиться внутри блока IF  или  внутри  цикла
DO.
     Формальные  параметры, указанные в операторе ENTRY, не могут
использоваться  ни в каких выполняемых операторах,  расположенных
в  программе  до  операторва ENTRY, если они не указаны в списках
параметров предыдущих точек входа.


+-----------------------
|      EQUIVALENCE
+-----------------------

     Определяет,  что  две  или  более  переменных  или   массива
располагаются в одной области памяти.

-----------------------------------------------------
     EQUIVALENCE (список) [,(список)]...
-----------------------------------------------------
Где :
список - это список не менее чем из двух элементов, разделенных
          запятой.  В  список  могут  входить имена переменных,
          имена  массивов   или   имена   элементов   массивов;
          недопустимы  имена  параметров.  Индексы  должны быть


                               100



          целыми  константами  и   находиться   внутри   границ
          массивов,  которые  они  описывают.  При совмещении в
          памяти  элементов  различных  типов   автоматического
          преобразования типов не происходит.

Особенности.

     Оператор EQUIVALENCE определяет, что расположение элементов,
указаных  в  списке,  должно  иметь  одну и ту же точку отсчета в
памяти. Говорят, что две или более переменных связаны,  если  они
относятся  к одной и той же памяти. Поэтому результатом оператора
EQUIVALENCE является то, что переменные из его списка  становятся
связанными.  Имя  массива,  если  на  него  ссылаются в операторе
EQUIVALENCE, относится к первому элементу массива.
     Вы не можете связать  символьные  и  несимвольные  элементы,
если  действует  метакоманда $STRICT (по умолчанию - $NOTSTRICT).
Смотрите ограничения на границу нечетных  байтов,  приведенные  в
следующем списке.
     Ограничения :

1.  Вы не можете заставить переменную занимать несколько мест в
     памяти,  также  как  вы  не  можете  заставить   несколько
     элементов  одного  и того же массива занимать одно и то же
     место.  Например,  следующий  оператор  поместил  бы  R  в
     два различных места памяти или S(1) и S(2) - в одно  и  то
     же место памяти :
          С Это - ошибка
                REAL R,S(10)
                EQUIVALENCE (R,S(1)),(R,S(2))

2.  Оператор     EQUIVALENCE    не   может   определить,    что
     последовательные элементы  массива  будут  расположены  не
     последовательно. Следующее, например, недопустимо :
          С Это - другая ошибка
                REAL R(10),S(10)
                EQUIVALENCE (R(1),S(1)),(R(5),S(6))

3.  Вы   не   можете   сделать   эквивалентными  символьную   и
     несимвольную величины,  так  чтобы  несимвольная  величина
     начиналась с границы нечетного байта.
          Для величин не из common-блоков компилятор попытается
     выровнять  несимвольную  величину по границе слова. Ошибка
     появится,  если  такое   выравнивание   невозможно   из-за
     нескольких  эквивалентностей. Например, следующее приведет
     к ошибке, так как нельзя обе переменные А и В выровнять по
     слову :
               CHARACTER*1 C1(10)
               REAL A,B
               EQUIVALENCE (A,C1(1)),(B,C1(2))
     Для величин в common-блоках, чье положение фиксировано, Вы


                               101



     отвечаете за обеспечение выравнивания по границе слов  для
     несимвольных величин. Ошибка возникнет для любой величины,
     не выровненной по границе слова.

4. Оператор EQUIVALENCE не может связать элемент типа CHARACTER
     с несимвольным  элементом  из-за  того,  что  несимвольный
     элемент должен быть расположен, начиная с нечетного байта.
     Однако,  нет  ограничений  для  эквивалентности символьных
     величин.

5. При использовании вместе  операторов  EQUIVALENCE  и  COMMON
     существует несколько дополнительных ограничений:
     а. оператор EQUIVALENCE не может расположить в одном и том
        же месте памяти два разных common-блока.
     б. оператор EQUIVALENCE  может  расширить  common-блок  за
        счет  элементов,  расположенных  после common-блока, но
        не перед ним.
     в. расширение    именованного   common-блока   с   помощью
        оператора   EQUIVALENCE   не  должно  делать  его длину
        отличной от длины в других программных единицах.
     Например, следующее недопустимо, потому что оно  расширяет
     common-блок добавлением памяти перед его началом :
                COMMON /ABCDE/R(10)
                REAL S(10)
                EQUIVALENCE (R(1),S(10))

Примеры :
     С Правильное использование оператора EQUIVALENCE
           CHARACTER NAME,FIRST,MIDDLE,LAST
           DIMENSION NAME(60),FIRST(20),MIDDLE(20),LAST(20)
           EQUIVALENCE (NAME(1),FIRST(1)),(NAME(21),MIDDLE(1)),
          1            (NAME(41),LAST(1))
Связанные   символьные   величины  могут  пересекаться,  как  в
следующем примере :
           CHARACTER A*4,B*4,C(2)*3
           EQUIVALENCE (A,C(1)),(B,C(2))
Этот пример можно графически иллюстрировать следующим образом :
+-----+-----+-----+-----+-----+-----+-----+
|  1  |  2  |  3  |  4  |  5  |  6  |  7  |
+-----+-----+-----+-----+-----+-----+-----+

+---------- А ----------+

                  +---------- В ----------+

+------- С(1) ----+------ С(2) -----+






                               102



+-------------------
|     EXIT
+-------------------

     Вызывает  передачу  управления  из  цикла  DO  или  DO WHILE
первому выполняемому оператору за циклом.

----------------------------------------
      EXIT
----------------------------------------

Особенности.

     Нормально цикл выполняется фиксированное число раз. Оператор
EXIT дает возможность прекратить выполнения цикла в любой момент.


+-------------------
|     EXTERNAL
+-------------------

     Определяет пользовательское имя, как внешнюю  процедуру  или
функцию.

-------------------------------------------
     EXTERNAL имя{attrs}[,имя{attrs} ] ...
-------------------------------------------
Где :
имя   - это имя внешней подпрограммы или функции.

attrs - список атрибутов, разделенных запятыми. Могут употреб-
        ляться: ALIAS, FAR, NEAR, C, LOADDS, PASCAL, VARYING.

Особенности.

     Имя,  заданное  в  операторе  EXTERNAL,  объявляет  его  как
внешнюю процедуру. В операторе EXTERNAL не могут появляться имена
функций-операторов.  Если  в  операторе  EXTERNAL  появляется имя
встроенной  функции,  то  это  имя  становится   именем   внешней
процедуры  и в дальнейшем не будет вызываться из этой программной
единицы. В данной программной единице пользовательское имя  может
появиться в операторе EXTERNAL только однажды.
     В  ассемблере  или  MS-Паскале  EXTERN  означает, что объект
определен вне текущей компиляции или модуля. Это  не  обязательно
для    MSФортрана,  так  как  стандартный  Фортран,  практически,
подразумевает,  что  любой  объект,  на   который   ссылаются   в
компилируемом  модуле,  не  определен  в  нем,  а  определен  как
внешний.
     В Фортране поэтому, EXTERNAL используется, в  основном,  для
определения  того,  что  некоторое  пользовательское  имя  -  это


                               103



подпрограмма или функция, используемая  как  параметр  процедуры.
EXTERNAL   может   также  показывать,  что  функция  пользователя
заменяет встроенную функцию с тем же именем. Примеры :
     С Пример оператора EXTERNAL
           EXTERNAL MYFUNC,MYSUB
     С MYFUNC и MYSUB - параметры для CALC
           CALL CALC(MYFUNC,MYSUB)

     C Пример функции пользователя, заменяющей встроенную
           EXTERNAL SIN X = SIN(A,4.2,37)


+-----------------
|     FORMAT
+-----------------

     Используется вместе с  операторами  форматного  ввода/вывода
для задания информации, управляющей редактированием данных.

--------------------------------------
      FORMAT описатель-формата
--------------------------------------
Где :
описатель-формата - это список спецификаций формата, обеспечиваю-
                    точное редактирование информации.  Специфика-
                    ция формата должна быть  заключена  в круглые
                    скобки  и  может  принимать одну из следующих
                    форм :
                       [r] повторяемый редактирующий описатель
                       неповторяемый редактирующий описатель
                       [r] ( описатель формата )
                    r, если он есть, - это ненулевая целая  конс-
                    танта без знака,  которая называется указате-
                    лем повторения.

Особенности.

     Внутри   внешних   скобок   допускается   до   трех  уровней
вложенности скобок.
     Вы можете опускать запятую  между  двумя  разделами  списка,
если   спецификация   формата   в   результате   этого  не  будет
двусмысленной; например, редактирующий описатель Р до  или  после
символа /.
     Операторы  FORMAT должны  быть  с  метками, но, как для всех
неисполняемых  операторов, эти  метки  нельзя   употреблять   при
ветвлении.






                               104



+-------------+------------------------------------------------+
| Повторяемые |               Неповторяемые                    |
+-------------+------------------------------------------------+
|   Iw[.m]    | 'xxx' (символьная константа)                   |
|   Gw.d      | nHxxx (символьная константа)                   |
|   Gw.dEw    | nX    (пробелы)                                |
|   Fw.d      | /     (конец записи)                           |
|   Ew.d      | \     (не конец записи)                        |
|   Ew.dEe    | kP    (масштабный коэффициент)                 |
|   Dw.d      | BN    (пробелы как пробелы в числах)           |
|   Lw        | BZ    (пробелы как нули в числах)              |
|   A[w]      | Tc    (позиция символа)                        |
|             | TRc   (сдвиг позиции символа вправо)           |
|             | TLC   (сдвиг позиции символа влево)            |
|             | :     (конец развертки формата)                |
|             | SP    (обязательный знак плюс)                 |
|             | SS    (убирание знака плюс)                    |
|             | S     (восстановление использования плюса      |
|             |                                по умолчанию)   |
+-------------+------------------------------------------------+
Таблица 2-4. Редактирующие описатели.

     Примечания к таблице 2-4 :
1. Для повторяемых редактирующих описателей :
     A, D, E, F, G, I и L задают вид редактирования.
     w, m и е - ненулевые целые константы без знака.
     d - целая константа без знака.
2. Для неповторяемых редактирующих описателей :
     ', H, X, /, \, P, BN, BZ, T, TL, TR, S, SS, SP и : задают
     вид редактирования.
     х - любой  символ ASCII.
     n - ненулевая целая константа без знака.
     k - необязательная целая константа со знаком.
     с - целая константа без знака.


+-------------------
|      FUNCTION
+-------------------

     Определяет  программную  единицу как функцию и определяет ее
тип, имя и формальнъе параметры.

--------------------------------------------------------------
     [тип] FUNCTION имя-функции {fattr} ([ параметр{attrs}
                                 [,параметр{attrs}]...])
--------------------------------------------------------------
Где
тип - один из следующих :
          INTEGER


                               105



          INTEGER*2
          INTEGER*4
          REAL
          REAL*4
          REAL*8
          DOUBLE PRECISION
          LOGICAL
          LOGICAL*2
          LOGICAL*4
          CHARACTER
          CHARACTER*n
          COMPLEX
          COMPLEX*8
          COMPLEX*16
имя-функции  -  это имя функции, задаваемое пользователем.
fattr    -  список атрибутов, разделенных запятыми. Список описы-
            вает функцию. Могут употребляться: FAR, ALIAS, C,
            PASCAL, NEAR, VARYING.
параметр -  это имя формального параметра.
attrs    -  список атрибутов, разделенных запятыми. Список описы-
            вает формальный параметр. Могут употребляться: FAR,
            HUGE, NEAR, REFERENCE, VALUE.

Особенности.

     Имя функции глобально, но для самой функции оно и  локально.
Если  в  операторе  FUNCTION  тип отсутствует, то он определяется
либо по умолчанию, либо из оператора IMPLICIT, либо  в  операторе
определения  типа  переменной.  Если  тип есть, то имя функции не
может появиться ни в каком операторе определения типа. Ни в каком
случае внешняя функция не может быть типа CHARACTER.
     Функции типа CHARACTER не могут появиться с описателем длины
звездочка (*). Например, недопустим такой оператор FUNCTION :
          CHARACTER*(*) FUNCTION F(X)
     Список   имен   параметров   определяет  число  и, вместе  с
операторами IMPLICIT, EXTERNAL, определения типа  и  DIMENSION, -
тип  параметров  этой функции. Никакое из имен параметров или имя
функции не может появиться в операторах COMMON, DATA, EQUIVALENCE
или INTRINSIC.
     Имя функции должно появиться как  переменная  в  программной
единице,  описывающей  функцию.  Каждое  вычисление  этой функции
должно  сопровождаться  присвоением  величины  этой   переменной.
Последняя  величина  этой  переменной  после выполнения оператора
RETURN или END определяет значение функции.
     Отметим,   что   определители    альтернативного    возврата
недопустимы в операторе FUNCTION.
     После вычисления на величину этой переменной можно ссылаться
в  выражении так же, как и на любую другую. Внешняя функция может
возвращать  значения  не  только  через  саму   функцию,   но   и
присвоением их одному или нескольким формальнъм параметрам.


                               106



     Функция может быть вызвана  из  любой  программной  единицы.
Однако  Фортран  не  допускает  рекурсивных  вызовов функции, что
означает, что функция не может вызвать прямо саму себя и не может
вызвать   другую   функцию,   если   она   использует   результат
вызывающей функции. Koмпилятор не фиксирует  рекурсивные  вызовы,
даже если они есть.

Пример :

     С Пример использования функции GETNO,
     С которая читает число А из файла А
           I=2
       10  IF (GETNO(I).EQ.0.0) GOTO 10
           STOP
           END
     C

           FUNCTION GETNO(NOUNIT)
           READ (NOUNIT,'(F10.5)') R
           GETNO=R
           RETURN
           END


+-----------------------------
|    GOTO (присваиваемый)
+-----------------------------

     Передает управление на оператор с меткой, чье значение равно
значению переменной.

----------------------------------------------------
     GOTO имя [[,] ( метка [, метка ]...) ]
----------------------------------------------------
Где
имя    - имя целой переменной.
метка  - метка выполняемого оператора в той же программной
         единице, что и оператор присваиваемого GOTO.

Особенности.

     Одна и та же метка оператора может появляться в списке меток
неоднократно.  Если  выполняется  присваиваемый оператор GOTO, то
имени должно быть присвоено значение метки выполняемого оператора,
находящегося  в  той  же  программной  единице,  что  и  оператор
присваиваемого GOTO.
     Если  метки, соответствующей последнему значению переменной,
нет в этой программной единице, то при  наличии  списка  меток  и
действии макрокоманды $DEBUG, вы получите сообщение об ошибке.
     Нельзя  передавать управление внутрь блоков DO, IF, ELSEIF и


                               107



ELSE извне этих блоков.  Переходить  внутрь блока  DO   позволяет
специальная возможность расширения цикла DO.

Пример :
          С Пример присваиваемого GOTO
                ASSIGN 10 TO I
                GOTO I
            10  CONTINUE


+-----------------------------
|     GOTO (вычисляемый)
+-----------------------------

     Пepeдaeт  упpaвлeниe  oпepaтopу,  пoмeчeннoму  i-oй мeткoй в
пpoгpaммe.

------------------------------------------------------
            GOTO (метка [,метка]...) [,]i
------------------------------------------------------
Гдe:
метка - мeткa  oпepaтopa, выпoлняeмoгo в тoй жe пoдпpoгpaммe,
        чтo и oпepaтop GOTO; пpи пepeчиcлeнии мeтoк oднa и тa
        же мeткa мoжeт пoвтopятьcя.
i     - цeлое выражение.

Особенности.

     Ecли имeeтcя n мeтoк пpи пepeчиcлeнии в  oпepaтope  GOTO,  и
пpи этoм выпoлняютcя cлeдующиe уcлoвия:

                  i < 1  или  i > n,

     тoгдa  GOTO  выпoлняeтcя  кaк oпepaтop CONTINUE. B пpoтивнoм
cлучae, cлeдующим oпepaтopoм выпoлняeтcя oпepaтop  c  мeткoй  пoд
нoмepoм i в списке мeтoк.
     Пepexoд  в  блoки  DO,  IF, ELSEIF, ELSE из дpугиx блoкoв нe
допустим.   Cпeциaльная  возможность  расширения понятия циклa DO
пoзвoляeт ocущecтвить вxoд в блoк циклa DO.

 Пpимep:
                  C Пример вычисляемого GOTO
                       I = 1
                       GOTO (10,20) I
                       .  .  .
                  10   CONTINUE
                       .  .  .
                  20   CONTINUE




                               108



+-------------------------
|    GOTO (безусловный)
+-------------------------

     Пepeдaeт упpaвлeниe oпepaтopу, пoмeчeннoму мeткoй.

---------------------------------------------------------
                  GOTO метка
---------------------------------------------------------
Гдe:
метка - мeткa oпepaтopa, выпoлняeмoгo в тoй жe пoдпpoгpaммe,
        чтo и GOTO.

Особенности.

     Пepexoд в блoки DO, IF, ELSEIF, ELSE  из  дpугиx  блoкoв  нe
допустим.  Cпeциaльная  возможность  расширения  понятия циклa DO
пoзвoляeт ocущecтвить вxoд в блoк циклa DO.

Пpимep:
                   C Пример безусловного GOTO
                        GOTO 4022
                        .  .  .
                   4022 CONTINUE


+------------------------
|   IF (apифмeтичecкий)
+------------------------

     Bычиcляeт  выpaжeниe  и,  в  зависимости  от его результата,
пepeдaeт  упpaвлeниe  oпepaтopу,  пoмeчeннoму  oднoй из oпиcaнныx
мeтoк.

----------------------------------------------------------
     IF (выражение) метка1, метка2, метка3
----------------------------------------------------------
Гдe:
выражение  - цeлoe или дeйcтвитeльнoe выpaжeниe.
метки1,2,3 - мeтки oпepaтopoв, выпoлняeмыx в тoй жe пoдпpoгpaммe,
             чтo и oпepaтop IF (apифмeтичecкий)

Особенности:

     Cpeди тpex укaзaнныx oднa и тa жe мeткa мoжeт иcпoльзoвaтьcя
нe  oдин  paз.  Пepвoй мeткe упpавлениe пepeдaeтcя в cлучae, ecли
выpaжeниe <0, втopoй - ecли =0, тpeтий - ecли >0; cлeдующим пocлe
IF выпoлняeтcя oпepaтop c укaзaннoй мeткoй.
     Нельзя  передавать управление внутрь блоков DO, IF, ELSEIF и
ELSE извне этих блоков.  Переходить  внутрь  DO  блока  позволяет


                               109



специальная возможность расширения цикла DO.

Пpимep:

                  C Пример арифметического IF
                      I = 0
                      IF (I) 10,20,30
                  10  CONTINUE
                      .  .  .
                  20  CONTINUE
                      .  .  .
                  30  CONTINUE


+-------------------
|  IF (логический)
+-------------------

     Bычиcляeтcя  лoгичecкoe выpaжeниe и, ecли eгo знaчeниe равно
.TRUE.,  тo  выполняется  дaнный  oпepaтop;  ecли выpaжeниe равно
.FALSE., тo oпepaтop нe выполняетcя, a выпoлняeтcя оператор, cлe-
дующий зa IF.

-------------------------------------------------
          IF (выражение) оператор
-------------------------------------------------
Гдe:
выражение - лoгичecкoe выpaжeниe.
оператор  - выпoлняeмый  oпepaтop, кpoмe DO, блoкa IF, ELSEIF,
            ELSE, ENDIF, END и дpугиx лoгичecкиx IF oпepaтopoв.
Пpимep:
              C Пример логического IF
                   IF (I.EQ.O) J = 2
                   IF (X.GT.2.3) GOTO 100
                   .  .  .
              100  CONTINUE


+-------------------------
|   IF THEN ELSE (блок)
+-------------------------

     Bычиcляeт  выpaжeниe,  и  ecли  выpaжeниe  .TRUE.,  нaчинaeт
вычиcлять oпepaтopы, входящие в блoк IF. Ecли выpaжeниe  .FALSE.,
пepeдaeт  управление  cлeдующим oпepaтopам ELSE, ELSEIF или ENDIF
тoгo жe уpoвня IF.

--------------------------------------------
       IF (выражение) THEN
--------------------------------------------


                               110



Гдe:
выражение - лoгичecкoe выpaжeниe.

Особенности :

     Блок IF coдepжит  вce  выполняемые  oпepaтopы  (вoзмoжно  ни
oдного),   которые  следуют  за  оператором  IF    до  следующего
оператора ELSEIF, ELSE иди ENDIF этого же уровня блока IF.
     Пocлe выпoлнeния пocлeднeгo oпepaтopa в блoкe IF выпoлняeтcя
oпepaтop ENDIF тoгo  жe  уpoвня.  Ecли  выpaжeниe  дaннoгo  блoкa
.TRUE.   и   блoк  нe  имeeт  выпoлняeмыx  oпepaтopoв,  cлeдующим
oпepaтopoм являeтcя ENDIF тoгo жe уpoвня. Ecли выpaжeниe  .FALSE.
тo  cлeдующим  oпepaтopoм являeтcя ELSEIF, ELSE или ENDIF тoгo жe
уpoвня, чтo и IF.
     Пepeдaвaть упpaвлeниe внутpь блoкa IF из дpугиx блoкoв нeдo-
пуcтимo.
     Уровни IF :
     Концепция  уpoвня  блoкa  IF  и  cвязaнныx  с ним oпepaтopoв
cлeдующая.  Для  кaждoгo oпepaтopa eгo уpoвнем IF являeтcя n1-n2,
гдe:
1. n1 чиcлo блoкoв oпepaтopoв IF oт нaчaла пpoгpaммнoй единицы,
   в кoтopoй иcпoльзуeтcя дaнный оператор, включaя текущий.
2. n2 чиcлo oпepaтopoв ENDIF oт нaчaла пpoгpaммнoй eдиницы дo
   дaннoгo оператора, иcключaя eгo.
     Уpoвeнь IF любoгo oпepaтopa дoлжeн быть бoльшe или paвeн 0 и
уpoвeнь IF блoкa IF,ELSEIF,ELSE,ENDIF дoлжeн быть  бoльшe 0. Уро- 
вeнь IF кaждoгo  пocлeднeгo  oпepaтopa дoлжeн быть 0.  Уpoвeнь IF
oпpeдeляeт пpaвилo влoжeния для блoкa IF и cвязaнныx с  ним  oпe-
paтopoв и oпpeдeляeт зoну влияния блоков IF,ELSEIF и ELSE.

Пpимep:

                  IF(I.LT.10)THEN
                  .          Набор операторов, выполняемых
                  .          в случае, если I.LT.10
                  ENDIF

Пpимep:

                  IF(I.GT.1000)THEN
                  .        Набор операторов, выполняемых
                  .        в случае, если J.GT.1000
                  ELSEIF(J.GT.100)THEN
                  .        Набор операторов, выполняемых
                  .        при условии J.GT.100 и J.LE.1000
                  ELSEIF(J.GT.10)THEN
                  .        Набор операторов, выполняемых
                  .        при условии J.GT.10 и J.LE.100
                  ELSE
                  .        Набор операторов, выполняемых


                               111



                  .        при условии J.LE.10
                  ENDIF
     Блок IF с операторами ELSEIF.

Пpимep:
                  IF(I.LT.100)THEN
                  .          Набор операторов, выполняемых
                  .          только если I.LT.100
                         IF(J.LT.10)THEN
                         .         Набор операторов, выполняемых
                         .         только если I.LT.100 и J.LT.10
                         ENDIF
                  .          Набор операторов, выполняемых
                  .          только если I.LT.100
                  ELSE
                  .          Набор операторов, выполняемых
                  .          только если I.GE.100
                         IF(J.LT.10)THEN
                         .         Набор операторов, выполняемых
                         .         только если I.GE.100 и J.LT.10
                         ENDIF
                  .          Набор операторов, выполняемых
                  .          только если I.GE.100
                  ENDIF
Bлoжeннaя кoнcтpукция IF бeз иcпoльзoвaния ELSEIF.


+---------------
|   IMPLICIT
+---------------

     Oпиcaниe типa для пoльзoвaтeльcкиx имeн.

----------------------------------------------------------
      IMPLICIT type (a[,a]...)[type (a[,a]...)...]
----------------------------------------------------------
Гдe:
type - oдин из cлeдующиx типoв

              INTEGER
              INTEGER*2
              INTEGER*4
              REAL
              REAL *4
              REAL *8
              DOUBLE PRECISION
              COMPLEX
              COMPLEX*8
              COMPLEX*16
              LOGICAL


                               112



              LOGICAL *2
              LOGICAL *4
              CHARACTER
              CHARACTER*n

a - либo oднa буквa, либo диапазон букв. Диапазон букв выдeляeтcя
    пepвoй и пocлeднeй буквaми диапазона, paздeлeнными "-". Буквы
    дoлжны укaзывaтьcя в aлфaвитнoм пopядкe.
n - (из CHARACTER*n) дoлжeн быть oт 1 дo 127.

Особенности.

     Оператор   IMPLICIT   описывает   тип   и  размер  для  всех
пользовательских  имен,  которые  начинаются  с  указанных  букв.
Оператор  IMPLICIT  работает  только в программной единице. Он не
изменяет типа любой внутренней функции.
     Типы IMPLICIT для любого пользовательского имени могут  быть
изменены   или   подтверждены,    если   это   имя   впоследствии
указывается в операторе типа.  Явный  тип  в  операторе  FUNCTION
также  берется  с приоритетом над оператором IMPLICIT.  Если рас-
сматриваемый тип является символьным типом, в дальнейшем его так-
же можно изменить последующим определением типа.
     Программная  единица  может  иметь  больше  одного оператора
IMPLICIT. Однако все  операторы  IMPLICIT  должны  предшествовать
всем другим операторам спецификаций в данной программной единице.
Одна  и  та же буква не может использоваться в операторе IMPLICIT
более одного раза.

Пример:
                    C пример IMPLICIT оператора
                      IMPLICIT INTEGER (A-B)
                      IMPLICIT CHARACTER*10(N)
                      AGE=10
                      NAME='PAUL'


+--------------
|   INCLUDE
+--------------

     Вызывает  включение текста из указанного файла  в  то  место
исходного файла, в котором расположен оператор INCLUDE.

---------------------------
    INCLUDE 'имя-файла'
---------------------------

 имя-файла - имя файка с текстом, который необходимо включить в
             данное место программы. Имя заключается в апострофы.



                               113



Особенности.

     Имя-файла  должно  быть правильным именем файла операционной
системы.

     Компилятор  рассматривает   включенный   текст   как   часть
основного.   Достигнув   конца   файла,  компилятор  переходит  к
обработке основного файла с записи, которая следует за оператором
INCLUDE.

     Обычно,  INCLUDE-файлы  используются  для  хранения  частей,
являющихся общими для  нескольких  программ,  например,  описания
общих блоков.

     Включаемые  файлы, в свою очередь, могут содержать операторы
INCLUDE  и  метакоманды  $INCLUDE,  т.е.  разрешена  вложенность,
ограничиваемая лишь операционной системой.


+--------------
|   INQUIRE
+--------------

     Возвращает  значения  различных  атрибутов,  с  которыми был
открыт  файл.  Заметьте,  что  оператор INQUIRE не может сообщить
свойства  неоткрытого  файла,  и  не  может  различать  атрибуты,
заданные пользователем, и заданные по умолчанию.

-----------------------------------------------------------
     INQUIRE (UNIT= unitspec список-описателей/назначений)
    или
     INQUIRE (FILE= file  список-описателей/назначений)

     где список-описателей/назначений - это:
     [,ERR= errlabel]
     [,EXIST= exist]
     [,NAMED= named]
     [,IOSTAT= iocheck]
     [,OPENED= opened]
     [,NUMBER= num]
     [,NAME= name]
     [,ACCESS= access]
     [,SEQUENTIAL= seq]
     [,DIRECT= direct]
     [,FORM= form]
     [,FORMATTED= formatted]
     [,UNFORMATTED= unformatted]
     [,RECL= recl]
     [,NEXTREC= nextrec]
     [,BLANK= blank]


                               114



     [,SHARE= share]
     [,MODE= mode]
     [,BINARY=binary]
     [,NAMED= named]
     [,BLOCKSIZE= blocksize]
-----------------------------------------------------------
     где

     unitspec     - это  либо  целое,  либо звездочка (*).  Зада-
                    ет номер устройства. Должен стоять первым при
                    запросе по устройству.

     file         - Задает имя файла при запросе по файлу; должно
                    стоять первым при запросе по файлу. Имя файла
                    должно   быть   символьной   переменной   или
                    элементом массива.

     errlabel     - Метка  выполняемого  оператора в той же прог-
                    раммной единице. Если errlabel задана, то при
                    ошибке ввода-вывода управление будет передано
                    на помеченный оператор.

     exist        - Логическая переменная или элемент логического
                    массива.  Возвращает  .TRUE.,  если  заданное
                    устройство или файл существуют,  и  .FALSE. в
                    противном случае.

     named        - Логическая переменная или элемент логического
                    массива.  Возвращает  .FALSE.,  если  файл не
                    открыт, и .TRUE. в противном случае.

     iocheck      - Целое  или  элемент  целого  массива, которое
                    равно  нулю,  если  не было ошибок, или равно
                    номеру сообщения об ошибке.

     opened       - Логическая переменная или элемент логического
                    массива.  При  запросе  по  файлу  возвращает
                    .TRUE.,  если  именованный файл в текущий мо-
                    мент соединен с любым устройством.  В против-
                    ном случае возвращает .FALSE.  При запросе по
                    устройству возвращает .TRUE., если для данно-
                    го устройства открыт какой-либо файл,  в про-
                    тивном случае возвращает .FALSE.

     num          - Целая переменная или элемент целого  массива.
                    Она становится неопределенной,  если  к файлу
                    не присоединено устройство.  При  запросе  по
                    файлу она равна номеру устройства,  соединен-
                    ного с файлом.



                               115



     name         - Символьная величина  или  элемент символьного
                    массива.  При запросе по устройству в нее за-
                    сылается имя файла.  Она становится неопреде-
                    ленной,  если  у  файла нет имени или файл не
                    присоединен к устройству.

     access       - Символьная переменная или элемент символьного
                    массива.  Присваивается значение 'SEQUENTAL',
                    если  присоединен файл последовательного дос-
                    тупа,  и 'DIRECT', если присоединен файл пря-
                    мого доступа.
                    Если к заданному устройству файл не присоеди-
                    нен, переменная становится неопределенной.

     seq          - Символьная переменная или элемент символьного
                    массива.  Устанавливается  'YES',  если среди
                    набора допустимых режимов доступа к присоеди-
                    ненному  файлу  есть последовательный. В про-
                    тивном случае - 'NO' или 'UNKNOWN'.

     direct       - Символьная переменная или элемент символьного
                    массива.  Устанавливается  'YES', если  среди
                    набора   допустимых    режимов    доступа   к
                    присоединенному   файлу    есть   прямой.   В
                    противном случае - 'NO' или 'UNKNOWN'.

     form         - Символьная переменная или элемент символьного
                    массива,  которой присваивается  'FORMATTED',
                    если    присоединен    файл   для  форматного
                    ввода/вывода,  и  'UNFORMATTED'  в  противном
                    случае.

     formatted    - Символьная переменная или элемент символьного
                    массива,  которой  присваивается  'YES', если
                    среди набора допустимых видов файла есть фор-
                    матный,  и  'NO'  или  'UNKNOWN'  в противном
                    случае.

     unformatted  - Символьная переменная или элемент символьного
                    массива,  которой   присваивается 'YES', если
                    среди  набора допустимых видов файла есть не-
                    форматный,  и  'NO' или 'UNKNOWN' в противном
                    случае.

     recl         - Целая переменная или элемент массива, которая
                    определяет  длину  (в байтах)  каждой  записи
                    файла,  присоединенного  для прямого доступа.
                    Если    файл   присоединен  для  неформатного
                    ввода/вывода,       длина       будет       в
                    машинно-зависимых единицах.


                               116



     nextrec      - Целая переменная или элемент целого  массива,
                    которой присваивается номер следующей  записи
                    в   файле,   открытом  для  прямого  доступа.
                    Первая запись в таком файле имеет номер 1.

     blank        - Символьная переменная или элемент символьного
                    массива,   которой   присваивается   значение
                    'NULL',    если    действует    редактирующий
                    описатель   BN   или   значение 'ZERO',  если
                    действует BZ.

     share        - Символьная переменная, которой передается зна-
                    чение строки операнда SHARE= в операторе OPEN
                    (COMPAT,DENYRW,DENYWR,DENYRD или DENYNONE).
                    Если  к  заданному  устройству не присоединен
                    файл, share становится неопределенной.

     mode         - Символьная  переменная,  которой   передается
                    значение строки операнда MODE= оператора OPEN
                    (READ,WRITE,READWRITE). Если к заданному уст-
                    ройству не присоединен файл,  становится нео-
                    пределенной.

     binary       - Символьная переменная,  которой присваивается
                    значение 'YES',  если файл является двоичным,
                    и 'NO' или 'UNKNOWN' - в противном случае.

     blocksize    - Целая переменная,  которой присваивается зна-
                    чение размера буфера в байтах,  если файл от-
                    крыт. В противном случае размер не определен.

     named        - Логическая переменная,  которой присваивается
                    значение .FALSE., если файл не открыт. В про-
                    тивном случае возвращается значение .TRUE.

Особенности.

     Оператор   INQUIRE  может  быть  выполнен  в  любой  момент.
Возвращаемые им величины соответствуют моменту обращения.
     Элементы в списке описателей/назначений  могут  следовать  в
любом порядке.


+----------------
|    INTEGER
+----------------

     Определяет переменные целого типа.




                               117



-------------------------------------------------------------
INTEGER{*bytes} vname{[attr]}{*length}{(dim)}{/values/}
                {,vname}{[attr]}{*length}{(dim)}{/values/}...
-------------------------------------------------------------

Гдe:
    bytes  -  moжет быть равно 1,2 или 4.
              Значение  bytes  определяет   длину  каждой
              переменной в списке, если оно не  перекрыто
              значением length.

    vname  -  символическое   имя   массива,   переменной,
              константы, внешней или  встроенной  функции,
              оператора-функции.

    attr   -  список    атрибутов,    описывающих   vname,
              разделенных запятыми.  Могут использоваться:
              ALIAS, ALLOCATABLE, C,  EXTERN,  FAR,  HUGE,
              NEAR, PASCAL, REFERENCE, VALUE.

    length -  может быть 1,2 или 4.
              Значение  length  определяет   длину  пере-
              менной, перекрывает  значение, определенное
              в chars.

    dim    -  описатель массива. Определяет vname как имя
              массива.

    values -  список констант или констант с повторителя-
              ми, разделенных запятыми. Повторитель запи-
              сывается в виде: n*constant, и означает  то
              же,  что и запись n-раз константы constant.
              Константы  задают  начальное  значение  для
              vname.

Особенности.

     Оператор   INTEGER   определяет   тип  переменных  для  всей
программной единицы, в которой он записан.
     В тексте программы операторы INTEGER должны быть расположены
до всех выполняемых операторов.


+--------------------
|     INTERFACE
+--------------------

     Разрешает связь с процедурами, написанными на других языках.
Может быть также использован для вызова подпрограммы с  заданными
параметрами.


                               118



-------------------------------------------------
  INTERFACE TO оператор подпрограммы
-------------------------------------------------
Где оператор подпрограммы - это оператор FUNCTION или SUBROUTINE.

Особенности.

     Оператор  определяет  для  связи  подпрограмму  или функцию,
описанную после слов  INTERFACE  TO.  Оператор  подпрограммы  или
функции  имеет  обычный  синтаксис.  В INTERFACE могут появляться
только  такие  операторы  как EXTERNAL, INTRINSIC, DIMENSION, END
и операторы описания типа.
     Например:
          INTERFACE TO INTEGER FUNCTION F(I,J,K)
          INTEGER*2 I
          REAL J
          EXTERNAL K
          END
описывает функцию
          INTEGER FUNCTION F(I,J,K)
          INTEGER*2 I
          REAL J
          EXTERNAL K
          END
     Если   Вы  планируете  отдельно  компилировать  части  Вашей
программы,  Вы  можете   включить   оператор   связи   в   каждую
компилируемую    часть,   которая   использует   или   определяет
подпрограммы. Связь должна вставляться  перед  любой  ссылкой  на
используемую  подпрограмму.  Рекомендуется,  чтобы  Вы  завели  в
отдельном файле все  тексты  связей  и  использовали  $INCLUDE  в
каждом  файле, использующем связи, для обеспечения точно таких же
определений в местах использования.
     Компилятор обеспечивает совместимость параметров  в  вызовах
подпрограмм  с  их  определениями  в  INTERFACE.  Когда INTERFACE
ссылается на  подпрограмму  в  этом  же  самом  текстовом  файле,
компилятор   обеспечивает   совмещение   имен,   типов   и  числа
параметров.
     Атрибуты , используемые в INTERFACE, меняют  определения  по
умолчанию  в  описании  подпрограммы. Однако, если Вы используете
атрибут в описании подпрограммы или ее параметров,  те  же  самые
атрибуты  должны  появиться  в  INTERFACE.  Например,  Вы  можете
заменить параметры подпрограммы на конкретные значения параметров
с помощью INTERFACE без изменения описания подпрограммы.


+----------------
|    INTRINSIC
+----------------

     Объявляет, что имя является именем встроенной функции.


                               119



-----------------------------------------
  INTRINSIC имя1[,имя2]...
-----------------------------------------
Где имя - это имя встроенной функции.

Особенности.

     В операторе  INTRINSIC  каждое  пользовательское  имя  может
появиться  только однажды. Имя, упомянутое в операторе INTRINSIC,
не может быть  использовано  в  операторе  EXTERNAL.  Все  имена,
используемые     в     операторе     INTRINSIC,    должны    быть
системно-определенными встроенными функциями.
     Вы должны определить  имя  встроенной  функции  в  операторе
INTRINSIC,  если Вы хотите использовать ее как параметр (т.е. как
фактический параметр в программной единице).
     Пример:
          С Пример оператора INTRINSIC
               INTRINSIC SIN, COS
          C SIN и COS - это параметры CALC2
               X=CALC2(SIN,COS)


+--------------------
|      LOCKING
+--------------------

     Блокирует файлы и записи файлов  прямого  доступа,  запрещая
доступ другим пользователям к этим файлам.

-----------------------------------------------------
    LOCKING ([UNIT=]устройство,[REC=номер-записи,]
[RECORDS=число-записей,][LOCKMODE='режим',]
    [ERR=метка-обработки-ошибки,][IOSTAT=состояние])
-----------------------------------------------------
Где
устройство    - это  целое,   являющееся   номером   закрываемого
                устройства. Файл, связанный с устройством, должен
                быть открыт для прямого доступа.
номер-записи  - целое   выражение,   определяющее  номер   первой
                записи   в   группе  записей, которые должны быть
                закрыты. Если номер-записи отсутствует, закроется
                следующая  запись (следующая, которая должна была
                читаться).
число-записей - целое выражение,  определяющее  число закрываемых
                записей. По умолчанию равно единице.
режим         - строковое  выражение,  имеющее  одно из следующих
                значений:
                'UNLCK' - не закрывать заданную область.
                'LOCK' - закрыть заданную область.
                'NBLCK' - не блокированное закрытие. Закрывает


                               120



                заданную область. Если она уже закрыта другим
                процессом, дает ошибку. Действует по умолчанию.
                'RLCK' - закрыть по чтению. То же, что и
                LOCK, кроме закрытия доступа для записи.
                'NBRLCK' - не блокированное закрытие по чтению.
                Тоже, что и NBLCK, кроме закрытия доступа для
                записи.
метка-        - это метка любого оператора.  Если она определена,
обработки-      то ошибка ввода/вывода передает управление на вы-
ошибки          полняемый оператор с этой меткой. Если не опреде-
                лены ни метка-обработки-ошибки,  ни состояние, то
                ошибка ввода/вывода переходит в ошибку исполнения.
                Оператор  с  меткой-обработки-ошибки должен нахо-
                диться   в  той  же  программной  единице,  что и
                оператор LOCKING.
состояние     - это целая переменная или элемент целого  массива,
                принимающая значения:
                а) нуль, если не встретилось ошибок
                в) номер ошибки исполнения, если ошибка имеется
                с) отрицательное целое, если встретился конец
                   файла.

Особенности.

     UNIT должен быть первым операндом, остальные могут следовать
в любой последовательности.
     Если  не определены ни состояние, ни метка-обработки-ошибки,
в программе возникнет ошибка  при  обнаружении  конца  файла  или
ошибочной ситуации.


+----------------
|    LOGICAL
+----------------

     Определяет переменные логического типа.

-------------------------------------------------------------
LOGICAL{*bytes} vname{[attr]}{*length}{(dim)}{/values/}
                {,vname}{[attr]}{*length}{(dim)}{/values/}...
-------------------------------------------------------------

Гдe:
    bytes  -  moжет быть равно 1,2 или 4.
              Значение  bytes  определяет   длину  каждой
              переменной в списке, если оно не  перекрыто
              значением length.

    vname  -  символическое   имя   массива,   переменной,
              константы, внешней или  встроенной  функции,


                               121



              оператора-функции.

    attr   -  список    атрибутов,    описывающих   vname,
              разделенных запятыми.  Могут использоваться:
              ALIAS, ALLOCATABLE, C,  EXTERN,  FAR,  HUGE,
              NEAR, PASCAL, REFERENCE, VALUE.

    length -  может быть 1,2 или 4.
              Значение  length  определяет   длину  пере-
              менной, перекрывает  значение, определенное
              в chars.

    dim    -  описатель массива. Определяет vname как имя
              массива.

    values -  список констант или констант с повторителя-
              ми, разделенных запятыми. Повторитель запи-
              сывается в виде: n*constant, и означает  то
              же,  что и запись n-раз константы constant.
              Константы  задают  начальное  значение  для
              vname.

Особенности.

     Оператор   LOGICAL   определяет   тип  переменных  для  всей
программной единицы, в которой он записан.
     В тексте программы операторы LOGICAL должны быть расположены
до всех выполняемых операторов.


+-------------------
|    MAP ... END MAP
+-------------------

   Внутри описания структруры определяет типы переменных.

---------------------------
        MAP
          опред-типа(ов)
          .
          .
        END MAP
---------------------------

    опред-типа  - любые допустимые описания типа.

 Особенности.

     Блок MAP...END MAP  может  появляться  только  внутри  блока
UNION...END UNION.


                               122



     В  MAP-блоке  может  быть  описано  любое  количество  любых
переменных. В памяти они хранятся в том порядке,  в  котором  они
описаны в блоке.

     Для  одной области, задаваемой оператором UNION, должно быть
по крайне мере два отображения, задаваемых операторами MAP.

     Отличие от оператора  EQUIVALENCE  заключается  в  том,  что
EQUIVALENCE   позволяет   совместить   отдельные  переменные  или
элементы массивов, в то время,  как  MAP  позволяет  совмещать  в
памяти группы разнотипных переменных.


+-------------------
|    NAMELIST
+-------------------

   Задает имя группы переменных для ввода/вывода списком.

---------------------------------------------------------
    NAMLIST /имя-гр/ спис-перем {/имя-гр/ спис-перем}
---------------------------------------------------------

    имя-гр - имя группы переменных.

    спис-перем - список имен переменных и массивов. Не может со-
                 держать имена структур и формальных параметров.

 Особенности.

     Одна переменная может включаться в несколько списков.

     Если   имя   группы   встречается  в  нескольких  операторах
NAMELIST, то  каждый  последующий  NAMELIST  рассматривается  как
продолжение предыдущего.

     При  выводе  списком,  в  файл  или на экран выводятся имена
переменных и их значения.

     При вводе списком, во входном файле выполняется  поиск  имен
переменных  и  их значений. Порядок, в котором переменные стоят в
файле, не имеет никакого значения, но важно  чтобы  они  все  там
присутствовали.


+------------
|    OPEN
+------------

     Приводит   в   соответствие   номер   устройства  с  внешним


                               123



устройством или файлом на внешнем устройстве.

------------------------------------------------------
     OPEN (номер-устройства [,FILE='имя-файла']
     [,STATUS='тип'][,ACCESS='тип-доступа'][,FORM=
     'формат'][,IOSTAT=состояние][,RECL=длина]
     [,SHARE='совместно'][,MODE='режим'])
     [,BLOCKSIZE=размер-блока]
------------------------------------------------------
Где

номер-устройства - Это  определитель  требуемого  устройство.  Он
                   должен  быть  первым  параметром  и  не должен
                   быть внутренним  определителем  устройства.

имя-файла        - Это символьное выражение. Это не  обязательный
                   параметр,  но он должен быть вторым, если при-
                   сутствует.  Если он отсутствует, то компилятор
                   создает временный вспомогательный файл с  име-
                   нем  таким  же как устройство. Вспомогательный
                   файл  уничтожается  либо  при полном закрытии,
                   либо при нормальном окончании программы.
                   Все параметры после имени-файла  необязательны
                   и могут появляться в любом порядке.

тип              - Это  OLD  (по умолчанию) или NEW.  OLD  -  для
                   чтения или  записи в  существующие файлы.  NEW
                   - для записи новых файлов.

тип-доступа      - SEQUENTIAL (по умолчанию), DIRECT или APPEND.

формат           - Это  FORMATTED,  UNFORMATTED  или BINARY. Если
                   тип-доступа = SEQUENTIAL, то формат=FORMATTED;
                   если   тип-доступа   =   DIRECT,  то  формат =
                   UNFORMATTED.

состояние        - Целая  переменная или элемент целого  массива,
                   в который возвращается:
                   а) нуль, если не было ошибки.
                   в) целая положительная величина, равная номеру
                      ошибки.
                   с) целая  отрицательная  величина, если встре-
                      тился конец файла.
длина            - Целое  выражение,  определяющее  длину  каждой
                   записи  в   байтах.   Этот  параметр  применим
                   только   для  файлов  с  прямым  доступом, для
                   которых он необходим.
совместно        - Это  символьное  выражение,  определяющее, как
                   другие  процессы  могут  иметь доступ к файлу,
                   пока  файл  еще  открыт.  Допустимые  значения


                               124



                   "совместно"  следующие  (без  учета  возможных
                   пробелов):
                   'COMPAT' режим совместимости по умолчанию.
                            Когда файл открывают в режиме совме-
                            стимости, начальный процесс,
                            (открывший файл) может открыть файл
                            в режиме совместимости сколько угодно
                            раз. Никакой другой процесс не может
                            открыть файл. Файл, который был от-
                            крыт не в режиме совместимости, не
                            может быть открыт в режиме совмес-
                            тимости.
                   'DENYRW' режим отказа от чтения записи.
                            Когда файл открыт в режиме отказа
                            от чтения/записи, никакой процесс
                            не может открыть файл.
                   'DENYWR' режим отказа от записи. Когда
                            файл открыт в режиме отказа от
                            записи, никакой процесс не может
                            открыть файл для записи.
                   'DENYRD' режим отказа от чтения. Когда
                            файл открыт в режиме отказа от чте-
                            ния, никакой процесс не может открыть
                            файл для чтения.
                   'DENYNONE' произвольный режим. Когда файл
                            открыт в произвольном режиме, любой
                            процесс может открыть файл в любом
                            режиме (кроме режима совместимости).
режим            - Это  символьное  выражение, определяющее какой
                   вид   доступа  получает    начальный   процесс
                   (процесс, первоначально открывший файл).
                   Допустимыми  значениями  режима  являются (без
                   учета возможных пробелов):'READ' процесс может
                   читать   из  файла,  'WRITE'  -  процесс может
                   писать  в  файл,  'READWRITE' - процесс  может
                   читать и писать в файл.

размер-блока     - целое выражение,  определяющее размер внутрен-
                   него буфера в байтах.

Особенности.

     Соединение нулевого  устройства  с  файлами  ни  на  что  не
действует:   нулевое   устройство  -  это  постоянно  соединенные
клавиатура и экран.
     Если имя файла  определено  пустым  (FILE=''),  то программа
пытается  прочитать  имя файла из списка имен в командной строке,
вызвавшей  программу.  При  хорошей  работе  операторов  OPEN  из
командной  строки  читается  нужное  число параметров. Если таких
операторов  OPEN  больше  чем  параметров  в  командной   строке,


                               125



программа спрашивает Вас имена файлов. Например, если в командной
строке  нет  параметров  (или  они  уже все прочитаны предыдущими
операторами OPEN), оператор
     OPEN (10, FILE='')
вызовет сообщение:
     File name missing or blank
     Please enter name
     UNIT 10?
     (Имя файла отсутствует или пустое
     Пожалуйста введите имя
     для устройства 10?)
     Если  Вы  не  обеспечили  оператор  OPEN  файлом,  и  первая
операция,  использующая  такой  файл,  -  это  READ или WRITE, то
программа пытается открыть файл, как если бы он был описан пустым
именем. Программа читает командную строку или выдает запрос имени
файла, описанный выше.
     Отметим, что Вы также можете  писать  на  принтер,  открывая
файл с
           FILE='PRN'
     Если MODE не задан,  то  система времени выполнения Фортрана
будет пытаться открыть файл с MODE='READWRITE'.  Если это не при-
ведет к успеху,  система  попытается  открыть файл снова, сначала
используя WRITE, а затем  READ.  Отметим, что это не то же самое,
что при задании MODE='READWRITE'. Если задано MODE='READWRITE', а
файл не может быть открыт ни для чтения, ни для записи, возникает
ошибка  открытия.  Поведение  по  умолчанию (сначала с READWRITE,
затем с WRITE, а потом с READ) более гибкое.


+------------------
|     PARAMETER
+------------------

     Присваивает имя константе.

----------------------------------------------
     PARAMETER ( P=e[,P=e]. . .)
----------------------------------------------
Где
     P   - имя.
     e   - константа или константое выражение.
     Константа  может  быть логической, символьной или относиться
к любому арифметическому типу.  Константное  выражение может быть
только логическим или целым.

Особенности.

     Имя   должно   соответствовать   по   типу   константе   или
константному  выражению.  Если  имя не имеет типа по умолчанию, а
длина константы - длина по умолчанию, имя должно быть  описано  в


                               126



операторе  описания типа или в IMPLICIT до использования в тексте
программы.
     Имя  может  быть  использовано  в  выражениях   только   той
программной единицы, в которой оно определено.
     Имя  не  может  быть  использовано в определении формата и в
некоторых других константах, например, в комплексной константе.
     Примеры:
          PARAMETER (NBLOCKS=10)
          INTEGER REMAIN
          PARAMETER (REMAIN=10/3, DIV=7.66)


+--------------
|     PAUSE
+--------------

     Приостанавливает выполнение программы и позволяет  ввести  и
выполнить команду операционной системы.

----------------------------------------------------------
     PAUSE [n]
----------------------------------------------------------
Где
n - это  символьная  константа,  либо строка не более чем из пяти
    цифр.

Особенности.

     Параметр n, если он есть, выдается на экран как приглашение,
требующее ввода с клавиатуры. Если n нет, на экран выдается такое
сообщение :
    'Please enter a blank line (to  continue) or system command.'
    ( Пожалуйста введите пустую строку (для продолжения) или
     системную команду.)
     Пользователь   в   этот  момент  может  выполнить  следующие
действия:

   - Нажать на клавишу Ввод (ENTER). Выполнение программы
     возобновится, как если бы был выполнен оператор CONTINUE.

   - Ввести команду MS/DOS. Команда выполнится, а затем
     возобновится выполнение программы.

   - Ввести "COMMAND" для ввода выполнения нескольких команд.
     Система будет вводить и выполнять команды до тех пор, пока
     пользователь не введет "EXIT" или "exit".

     Пример :
          С  Пример оператора PAUSE
             IF (IMARN.EQ.0) GO TO 300


                               127



             PAUSE 'WARNING : INARM IS NONZERO'
       300  CONTINUE


+----------------
|     PRINT
+----------------

     Выводит данные на экран

----------------------------------------------------------
     PRINT {*,|спец-форм|имя-гр} {спис-в/в}
----------------------------------------------------------
Где

  спец-форм - спецификация формата

  имя-гр    - имя группы из оператора NAMELIST

  спис-в/в  - список, определяющий выводимые данные

Особенности.

     Если в качестве спецификатора формата используется символ *,
то используется вывод, управляемый списком.

     Если используется имя группы, то не может быть задан  список
вывода.

     В  списке  вывода  не  может  использоваться  имя структуры,
только имена элементов.

     Если в списке вывода записывается выражение,  то  в  нем  не
может   быть  функций,  использующих  операции  ввода-вывода  или
встроенную функцию EOF.


+----------------
|     PROGRAM
+----------------

     Определяет программную  единицу  как  основную  программу  и
присваивает ей имя.

----------------------------------------------------------
     PROGRAM   имя программы
----------------------------------------------------------
Где
имя  программы  -  это  имя,  которое  Вы  дали  своей основной
               программе. Имя программы - это  глобальное  имя.


                               128



               Поэтому  оно  не  может совпадать с именем любой
               внешней процедуры или  именем COMMON-блока. (Оно
               также   является   локальным   именем   основной
               программы и не должно вступать в противоречие  с
               любым  локальным  именем  в основной программе.)
               Оператор  PROGRAM  может  быть   только   первым
               оператором в основной программе.

Особенности.

     Если  у  основной  программы нет оператора PROGRAM, ей будет
присвоено имя MAIN. Имя MAIN тогда нельзя будет использовать  для
именования любого другого объекта.
     Пример :
          PROGRAM GAUSS
          REAL COEF (10,10), COST (10)
          .
          .
          .
          END


+-------------
|    READ
+-------------

     Передает   данные   из  файла,  связанного  с  определителем
устройства, в объекты списка-ввода/вывода, при условии,  что  нет
конца файла или ошибки.

---------------------------------------------------------------
     READ  (определитель  устройства  [,определитель   формата]
[,IOSTAT=состояние]     [,REC=номер    записи]    [,END=метка1]
[,ERR=метка2]) список-ввода/вывода
---------------------------------------------------------------
Где

определитель-устройства - это определитель требуемого устройства,
   который должен быть первым параметром.

определитель-формата - требуется для форматного чтения как
   второй параметр. Не должен появляться для неформатного чтения.
   Остальные параметры если они  есть,  могут  появляться в любом
   порядке.

состояние - целая переменная, элемент массива или структуры.
   Равно а) нулю, если не встретилась ошибка.
         b) номеру сообщения об ошибке.
         с) -1, если встретился конец файла.



                               129



номер записи -
   Определяется только для файлов прямого доступа. Если номер за-
   писи определен для файла последовательного доступа,  возникнет
   ошибка. Номер-записи - это положительное целое выражение,  оп-
   ределяющее  номер  записи  (первая запись в файле имеет номер,
   равный 1).

метка1 -
   Метка оператора в той же программной  единице. Если этот пара-
   метр отсутствует, чтение после записи конца файла вызовет оши-
   бку, если только не заданы метка2 или состояние. Если этот па-
   раметр присутствует, то чтение записи конца файла  приведет  к
   передаче управления на помеченный выполняемый оператор.

метка2 -
   необязательная метка оператора в той же самой программной еди-
   нице. Если этот параметр отсутствует, то результат ошибки вво-
   да/вывода  определяется  наличием  или  отсутствием  параметра
   IOSTAT. Если он есть, ошибка ввода/вывода передает  управление
   на помеченный выполняемый оператор.

список-ввода/вывода -
   определяет объекты, в которые передаются величины из файла. Он
   может  быть  пустым, но обычно содержит объекты  для  ввода  и
   неявные  циклы,  разделенные  запятыми.

Особенности.

     Если  чтение  внутреннее, источником ввода служит символьная
переменная  или  массив   символьных   элементов;  если чтение не
внутреннее,  источником  ввода является внешнее  устройство.
     Если  файл   не  был  открыт  оператором  OPEN,  выполняется
операция   OPEN   по   умолчанию.   Эта   операция   эквивалентна
выполнению следующего оператора :

     OPEN (оператор устройства, FILE=", STATUS='OLD',
     ACCESS='SEQUENTIAL',FORM='формат'

     Формат  -  это FORMATTED для форматного READ  и  UNFORMATTED
для   неформатного  READ.  Смотрите  описание  оператора OPEN для
понимания действия параметра FILE=.

     Пример:
     С  Описание двухмерного массива
          DIMENSION IA(10,20)
     С Чтение в границы массива. Эти границы не превышают
     С 10 и  20  соответственно.  Затем  чтение  в  массив неявным
     С циклом DO с вводным форматом 8 колонок по 5 цифр.
          READ (3,990) IL, JL, ((IA(I,J), J=1, JL), I=1, IL)
     990  FORMAT (215/,(8I5))


                               130



+----------------
|    REAL
+----------------

     Определяет переменные действительного типа.

-------------------------------------------------------------
REAL{*bytes} vname{[attr]}{*length}{(dim)}{/values/}
                {,vname}{[attr]}{*length}{(dim)}{/values/}...
-------------------------------------------------------------

Гдe:
    bytes  -  moжет быть равно 4 или 8.
              Значение  bytes  определяет   длину  каждой
              переменной в списке, если оно не  перекрыто
              значением length.

    vname  -  символическое   имя   массива,   переменной,
              константы, внешней или  встроенной  функции,
              оператора-функции.

    attr   -  список    атрибутов,    описывающих   vname,
              разделенных запятыми.  Могут использоваться:
              ALIAS, ALLOCATABLE, C,  EXTERN,  FAR,  HUGE,
              NEAR, PASCAL, REFERENCE, VALUE.

    length -  может быть 4 или 8.
              Значение  length  определяет   длину  пере-
              менной, перекрывает  значение, определенное
              в chars.

    dim    -  описатель массива. Определяет vname как имя
              массива.

    values -  список констант или констант с повторителя-
              ми, разделенных запятыми. Повторитель запи-
              сывается в виде: n*constant, и означает  то
              же,  что и запись n-раз константы constant.
              Константы  задают  начальное  значение  для
              vname.

Особенности.

     Оператор REAL определяет тип переменных для всей программной
единицы, в которой он записан.
     В тексте программы операторы REAL должны быть расположены до
всех выполняемых операторов.





                               131



+---------------
|     RECORD
+---------------

     Определяет переменные структурного типа.

----------------------------------------------------------
     RECORD /имя-типа/ имя-перем {[attrs] [dim] }
               { ,имя-перем {[attrs] [dim]}
----------------------------------------------------------
Где
  имя-типа  - имя структурного типа, определенного программистом.

  имя-перем - символическое имя переменной.

  attrs     - список    атрибутов,    описывающих   vname,
              разделенных запятыми.

  dim       - описатель массива. Определяет имя-перем как имя
              массива.

Особенности.

     С помощью конструкции STRUCTURE программист может определять
новые,  отсутствующие   в   стандартном  Фортране,  типы  данных.
Оператор RECORD  позволяет  определить  переменные  этого  нового
типа.
     Имя-типа  должно быть определено в программе до употребления
его в операторе RECORD.


+---------------
|     RETURN
+---------------

     Возвращает управление из вызванной программной единицы.

----------------------------------------------------------
     RETURN  { значение }
----------------------------------------------------------
Где
  значение - целая константа. Определяет позицию адреса выхода в
             списке формальных параметров.

Особенности.

     RETURN может появляться только в функции или подпрограмме.

     Выполнение  оператора  RETURN  заканчивает  выполнение  всей
подпрограммы  или  функции.  Если  оператор  RETURN  находится  в


                               132



функции,  величине   функции   присваивается   текущее   значение
переменной с тем же именем, что и функция.
     В  списке  фактических  параметров  при  вызове подпрограммы
может быть указано несколько меток для выхода. В  этом  случае  с
помощью  операнда  можно  указать  конкретный  адрес  выхода. Для
функций это не применимо.
     Выполнение  оператора  END  в   функции   или   подпрограмме
эквивалентно  выполнению  оператора RETURN. Поэтому для окончания
функции или подпрограммы требуется или RETURN или END.

Пример
     С  Пример оператора RETURN
     С  Эта подпрограмма выполняет цикл
     С  пока вы не наберете "Y"
          SUBROUTINE LOOP
          CHARACTER IN
     C
      10  READ (*,'(A1)') IN
          IF (IN.EG.'Y') RETURN
          GO TO
     C  Неявный RETURN
          END


+---------------
|     REWIND
+---------------

     Возвращает к первой записи указатель  файла, связанного с
определенным устройством.

---------------------------------------------------
     REWIND {опр-устр | [UNIT=]опр-устр}
                  {,ERR=errlabl}
                  {,IOSTAT=iochеk}
---------------------------------------------------
Где
опр-устр -  определитель внешнего устройства.

Пример
          INTEGER A(80)
          .
          .
          WRITE (7,'(80I1)')A
          .
          .
          REWIND 7
          .
          .
          READ (7,'(80I1)')A


                               133



+------------
|     SAVE
+------------

     Заставляет переменные сохранять значения в промежутках между
вызовами процедур, в которых они определены.

----------------------------------------------------------
     SAVE имя1 [,имя]...
----------------------------------------------------------
Где
имя - это имя COMMON-блока (заключенное в косые  черточки), пере-
      менной или массива. Если в текущую процедуру войти повторно,
      то  названные  переменные  и  все  переменные  в  названном
      COMMON-блоке содержат прежние значения. Пример:
         С  Пример оператора SAVE
              SAVE /MYCOM/, MYVAR
         990  FORMAT (215/,(8I5))


+----------------------------------
|    SELECT CASE ... END SELECT
+----------------------------------

     Передает управление на группу операторов, определяемую зна-
чением управляющего выражения.

-----------------------------------------------------
   SELECT CASE (упр-выраж)
      CASE (сел-выраж)
        { груп-опер }
      CASE (сел-выраж)
        { груп-опер }
      ...
      CASE DEFAULT
        { груп-опер }
    END SELECT
-----------------------------------------------------

Гдe:
 упр-выраж - выражение имеющее значение типа INTEGER, LOGICAL или
             CHARACTER*1.

 сел-выраж - список значений, которые должны задаваться  констан-
             тами и иметь тип соответствующий типу упр-выраж.

 груп-опер - один или более выполняемых операторов.

Особенности.



                               134



     Список   значений   для   сел-выраж   можно  задавать  двумя
способами.  Во-первых,  просто  перечислить  все  значения  через
запятую.  Во-вторых,  можно  задать  диапазон значений, используя
двоеточие. Например, 5:10 или 'M':'Q'. Верхняя граница  при  этом
должна быть больше нижней.
     Опущенная    нижняя   или   верхняя   граница   семантически
эквивалентна записи "не больше" или "не меньше", соответственно.
     Группа операторов может быть пустой, т.е.  не  содержать  ни
одного оператора.
     Оператор  CASE  DEFAULT  является необязательным, но в одном
блоке SELECT CASE он может встречаться только один раз.
     Нельзя  передавать  управление  на  операторы  внутри  блока
SELECT CASE.
     Допускается  любой уровень вложенности операторов SELECT, но
каждому оператору SELECT должен соответствовать один оператор END
SELECT.
     Недопустимо  пересечение  блока  SELECT  с  границами  любых
других  блоков ( DO, DO WHILE, IF, ELSE и ELSEIF). Они могут лишь
полностью быть вложены друг в друга.


+-------------------------
|     Функция-оператор
+-------------------------

     Определяет функцию в виде одного оператора.

----------------------------------------------------------
    имя-функции ([параметр[,параметр]...])=выражение
----------------------------------------------------------
Где
имя-функции - имя функции оператора.

параметр - список формальных параметров, разделенных запятыми.

выражение - любое действительное выражение.

Особенности.

     Функция-оператор по  виду похожа  на оператор  присваивания.
Функция-оператор может стоять только после операторов определения
типа  и  перед  любыми  исполняемыыми  операторами  в программной
единице, в которой она используется.
     Функция-оператор - это невыполняемый оператор,  хотя  она  и
является  первым  оператором  в программной единице. Однако, тело
функции-оператора     служит     для     определения     значения
функции-оператора.  Как  и любые другие функции, функция-оператор
вычисляется по ссылке в выражении.
     Тип  выражения  должен  быть   совместим   с   типом   имени
функции-оператора.  Список  имен формальных параметров служит для


                               135



определения числа и типа параметров  функции-оператора.  Областью
действия   имен   формальных  параметров  является  сама  функция
оператор.  Поэтому  имена  формальных   параметров   могут   быть
переопределены  как  другие имена пользователя в оставшейся части
программной     единицы,     за     исключением      определителя
функции-оператора.
     Имя  функции-оператора,  однако,  локально  по  отношению  к
программной  единице;  оно не должно  быть  использовано где-либо
еще,  кроме  имени COMMON-блока или имени формального параметра в
другой   функции-операторе.   В последнем  случае   тип    такого
использования должен быть одинаковым.
     В  выражении  допустимы  ссылки  на  переменные,  формальные
параметры,  другие функции, элементы массивов и константы. Ссылки
на  функции-операторы,  однако,  должны  относиться  к  функциям,
описанным до того, как они употреблены.
     На функцию-оператор можно ссылаться только в той программной
единице,   где  она  описана.  Имя  функции-оператора  не  должно
появляться ни в  каких  описывающих  операторах,  за  исключением
описания  типа (которые не могут описывать это имя, как массив) и
оператора COMMON  (как  имя  COMMON-блока).  Функция-оператор  не
может быть типа CHARACTER.

Пример
     С  Пример оператора функция-оператор
          DIMENSION X(10)
          ADD(A,B)=A+B
     C
          DO 1 I=1,10
          X(I)=ADD(Y,Z)
      1   CONTINUE


+-------------
|     STOP
+-------------

     Заканчивает выполнение программы.

----------------------------------------------------------
     STOP [n]
----------------------------------------------------------
Где
n  - это либо символьная константа,  либо  целое в диапазоне от 0
     до 99999.

Особенности.

     Параметр  n, если  он  есть,  высвечивается на экране, когда
программа  оканчивается.  Если   n   нет,   высвечивается   такое
сообщение:


                               136



          STOP - Program terminated
          (STOP - Программа окончена)

     Пример
     С  Пример оператора STOP
          IF (IERROR.EQ.0) GO TO 200
          STOP 'Определена ошибка'
    200  CONTINUE


+----------------------------------
|   STRUCTURE ... END STRUCTURE
+----------------------------------

     Определяет новый, составной тип переменных.

-----------------------------------------------------
   STRUCTURE  /имя-типа/
      элем-описания
      ...
    END STRUCTURE
-----------------------------------------------------

Гдe:
 имя-типа - соответствующее соглашениям Фортрана имя нового типа.

 элем-описания - любая  комбинация  определенных к этому моменту
            типов данных (включая операторы RECORD) и операторов
            UNION.

Особенности.

     Конструкция STRUCTURE предназначена для описания новых типов
данных,  обычно  называемых  в  других  языках  "структурами" или
"записями". Оператор STRUCTURE описывает тип данных, для описания
переменных этого типа используется оператор RECORD.
     Структура  формируется  из  элементов.   Наиболее   простыми
элементами являются типы, определенные в самом языке. Например:

    STRUCTURE /SIMPLT/
      INTEGER NUMBER
      CHARACTER*15 FIELD_1
      CHARACTER*25 FIELD_2
    END STRUCTURE

     В   более  общем  случае  в  структуру  могут  входить типы,
определенные к  этому  моменту в программе.  Например,  используя
приведенное выше определение структуры SIMPLT, можно определить

    STRUCTURE /COMPLX/


                               137



      INTEGER ABCD
      RECORD /SIMPLT/ STR1
      RECORD /SIMPLT/ STR2
      CHARACTER*80 DATA
    END STRUCTURE

     Элементы не могут иметь никаких атрибутов.
     Имена  элементов локализованы в той структуре, в которой они
описаны. Наличие в  разных  структурах  элементов  с  одинаковыми
именами  не  приводит  к  конфликтам.  Для  доступа  к  элементам
структуры необходимо указывать полностью  весь  путь,  перечисляя
все  элементы, разделенные  точками.  Например,  если  определена
переменная

       RECORD /COMPLX/ EXSTR

     то для доступа к элементам  надо  указывать  EXSTR.ABCD  или
EXSTR.STR2.FIELD_2 и т.д.
     Размер  структуры  не  должен  быть  более 65536 байтов. При
подсчете размера учитываются все байты, включая байты, пропускае-
мые для выравнивания границ переменных.


+--------------------
|     SUBROUTINE
+--------------------

     Определяет программную единицу как подпрограмму, присваивает
ей  имя  и определяет формальные параметры для этой подпрограммы.
Эти параметры могут содержать переменную метку возврата (*).

----------------------------------------------------------
     SUBROUTINE подпр {[sattr]}[([форм-пар[attr]...])]
----------------------------------------------------------
Где
 подпр     - это  определяемое  пользователем  глобальное внешнее
             имя подпрограммы.  Это  имя не может употребляться в
             операторах  AUTOMATIC,  COMMON,  DATA,  EQUIVALENCE,
             LOADDS, SAVE или операторах типа.

 форм-пар  - это определяемое пользователем имя формального пара-
             метра, называемого также фиктивным параметром.  Фор-
             мальный  параметр  может быть переменной меткой воз-
             врата (*).

 sattr     - список атрибутов, разделенных запятыми.  Список опи-
             сывает функцию. Могут употребляться:  FAR, ALIAS, C,
             PASCAL, NEAR, VARYING.

 attr      - список атрибутов, разделенных запятыми.  Список опи-


                               138



             сывает  формальный  параметр.  Могут  употребляться:
             FAR, HUGE, NEAR, REFERENCE, VALUE.

Особенности.

     Подпрограмма    начинается    с   оператора   SUBROUTINE   и
заканчивается  оператором  END.  Она  может включать в себя любые
операторы, кроме PROGRAM, SUBROUTINE, BLOСK DATA и FUNCTION.
     Список   имен   параметров   определяет  число  и, вместе  с
последующими операторами определения типа, IMPLICIT, EXTERNАL или
DIMENSION - тип параметров этой подпрограммы. Имена параметров не
могут появляться  в  операторах  COMMON,  DATA,  EQVIVALENCE  или
INTRINSIC.
     Фактические   параметры   в   операторе   CALL,   вызывающем
подпрограмму,  должны  соответствовать  формальным  параметрам  в
операторе SUBROUTINE по порядку следования, числу, типу или виду.
     Компилятор будет проверять их на соответствие, если известны
формальные параметры.  Подразумевается,  что оператор SUBROUTINE,
определяющий формальные параметры, должен предшествовать операто-
ру CALL в текущей компиляции.
     Правила  соответствия  формальных  и  фактических параметров
приведены в описании оператора CALL.

Пример
          SUBROUTINE GETNUM (NUM, UNIT)
          INTEGER NUM, UNIT
     10   READ (UNIT, '(I10)', ERR=10) NUM
          RETURN
          END


+------------
|     Тип
+------------

     Определяет тип имен, используемых пользователем.

----------------------------------------------------------
     Тип имя-пер1 [,имя-пер2]...
----------------------------------------------------------

Где
тип - это один из следующих определителей типа  данных:  INTEGER,
      INTEGER*2,   INTEGER*4,    REAL,   REAL*4,  REAL*8,  DOUBLE
      PRECISION,  COMPLEX,    COMPLEX*8,   COMPLEX*16,   LOGICAL,
      LOGICAL*2, LOGICAL*4, CHARACTER, CHARACTER*n.

имя-пер - это символьное имя переменной,  массива,  или  функции-
      оператора, или  подпрограммы-функции, или оператора  объяв-
      ления массива.


                               139



Особенности.

     Оператор определения типа может подтверждать  или  отвергать
неявный   тип   имени.  Оператор  определения  типа  может  также
определить размер.
     Пользовательское имя переменной,  массива,  внешней  функции
или  функции-оператора  может упоминаться в операторе определения
типа. В этом случае тип этого имени определен во всей программной
единице.  В  программной  единице   оператор   определения   типа
однозначно определяет тип имени.
     Оператор   определения  типа  может  также  подтвердить  тип
встроенной  функции,  но  это   не   обязательно.   В   операторе
определения   типа  не  может встретиться  имя  подпрограммы  или
основной программы.
     К оператору определения типа применимы следующие правила:

1.  Оператор определения типа должен предшествовать всем выполня-
    емым операторам.
2.  Тип  данных  с  символьным  именем может  быть  точно  описан
    только  однажды.
3.  Оператор определения типа не должен иметь метки.
4.  Оператор  определения типа может описывать массив добавлением
    описателя  размерности  к имени массива. За символьным именем
    может следовать определитель длины типа данных в виде *длина,
    где длина - одна из доступных типов длин для провозглашенного
    типа  данных.  Такое описание отменяет атрибут длины, который
    подразумевался  оператором  определения  типа,  и присваивает
    новую длину описываемому объекту.  Если присутствуют как опи-
    сатель длины типа, так и описатель массива, то описатель дли-
    ны типа должен быть последним.

Пример:
     С  Пример операторов определения типа
          INTEGER COUNT, MATRIX(4,4), SUM
          REAL MAN, IABS
          LOGICAL SWITCH
          .
          INTEGER*2 Q, M12*4, IVEC(10)*4
          .
          CHARACTER NAME*10, CITY*80, CH


+----------------------------------
|    UNION ... END UNOIN
+----------------------------------

     Позволяет разместить в одно  место  памяти  несколько  групп
переменных.




                               140



-----------------------------------------------------
   UNION
      опр-группы
      опр-группы
      ...
      опр-группы
    END UNION
-----------------------------------------------------

Гдe:
 опр-группы - описание распределения памяти. См. MAP...END MAP

Особенности.

     Блок   UNION   может   использоваться  только  внутри  блока
STRUCTURE. Каждый  блок  UNION  должен  кончаться  оператором END
UNION.
     Функционально  UNION  близок  к оператору EQUIVALENCE, но не
имеет присущих ему ограничений.

Пример.

     Первые  40  байтов  массива  STR2  совмещаются  в  памяти  с
массивом  4-х байтовых  целых  чисел,  а  оставшиеся  20 байтов с
массивом 2-х байтовых чисел.

     UNION
      MAP
       CHARACTER*20 STR1, CHARTACTER*10 STR2(6)
      END MAP
      MAP
       INTEGER*2 NUM(10), INTEGER*4 VAR(10), INTEGER*2 DAT(10)
      END MAP


+--------------
|     WRITE
+--------------

     Передает  данные  из объектов списка-ввода/вывода (iolist) в
файл, связанный с указанным устройством.

--------------------------------------------------------------
    WRITE ([UNIT=]unitspec[,[FMT=]formatspec]
          [,IOSTAT=iocheck][,ERR=errlabel][,REC=rec])
          iolist
--------------------------------------------------------------
Где
unitspec   - При  записи  во внутренний файл unitspec должен быть
             символьной подстрокой, переменной, массивом, элемен-


                               141



             том  массива  или структуры, или несимвольным масси-
             вом.  При  записи  во внешний файл unitspec является
             целым выражением, которое определяет устройство.
             Если unitspec не был явно связан с файлом, то выпол-
             няется "неявное открытие" следующим образом:

             OPEN(unitspec,FILE='',STATUS='UNKNOWN',
             ACCESS='SEQUENTIAL',FORM=form)

             где  form  равно  'FORMATTED' для операции форматной
             записи  и  'UNFORMATTED'  для  операции  неформатной
             записи.

formatspec - Определитель-формата.  Является обязательным элемен-
             том для форматной записи и не должен  появляться для
             неформатной записи.

iocheck    - Целая  переменная,  элемент массива или структуры, в
             которые возвращается нулевое значение при отсутствии
             ошибки или номер сообщения об ошибке при ее наличии.

errlabel   - Метка  выполняемого  оператора в этой же программной
             единице. Если errlabel задана, то ошибка ввода-выво-
             да приведет к передаче управления на оператор, поме-
             ченный  этой  меткой.  Если errlabel опущена, то ре-
             зультат  ошибки  ввода-вывода  определяется наличием
             или отсутствием iocheck.

rec        - Положительное  целое  выражение,  называемое номером
             записи.  Определяется только для файлов прямого дос-
             тупа, в противном случае вызывает ошибку.
             Аргумент  rec  определяет  номер записи для операции
             WRITE.  Первая запись в файле имеет номер 1. Умолча-
             нием для rec является текущая позиция в файле.

iolist     - список объектов,  значения которых передаются опера-
             тором WRITE.  Список  не может содержать структурные
             переменные, хотя элементы структуры допускаются.

Особенности.

     Если  файл был открыт с аргументом MODE='READWRITE' (умолча-
ние),  то  вы  можете  произвольно читать или записывать файл без
его повторного открытия.

     При  записи в последовательный файл, все записи, находящиеся
за вновь внесенной записью, удаляются.

     Если  параметром оператора WRITE является выражение, которое
вызывает функцию,  то  эта функция не должна выполнять ввод-вывод


                               142



или  вызывать  встроенную  функцию  EOF,  поскольку в этом случае
результаты будут непредсказуемы.


















































                               143
