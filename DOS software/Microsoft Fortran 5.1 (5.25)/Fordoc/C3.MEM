






                             ГЛАВА 3

            УПРАВЛЕНИЕ ОПЕРАЦИЯМИ С ПЛАВАЮЩЕЙ ТОЧКОЙ

     MSФортран позволяет вам контролировать, как  ваша  программа
выполняет   математические   операции   с  плавающей  точкой.   В
программах с интенсивными  вычислениями  правильный  выбор  опции
плавающей    точки   может   ускорить   выполнение   и   улучшить
характеристики программ.  В  этой  главе  описаны  математические
пакеты,  которые  вы  можете установить в библиотеки Фортрана при
выполнении  программы  SETUP.   В  ней  обсуждаются  также  опции
команды FL для выбора соответствующей библиотеки для связывания и
вызова команд плавающей точки.

     В этой главе объясняется также, как подавить опции плавающей
точки  и  изменить  библиотеки во время связывания, как управлять
сопроцессором  8087,  80287  или  80387  с   помощью   переменной
окружения  NO87,  и  как  управлять  исключениями плавающей точки
8087/80287/80387.


     3.1 ВЫБОР МАТЕМАТИЧЕСКОГО ПАКЕТА

     Компилятор MSФортрана позволяет выбрать следующие  пакеты  с
плавающей точкой:

      o  Пакет 8087/287/387 (действует по умолчанию)

      o  Пакет эмулятора

      o  Альтернативный математический пакет

     ЗАМЕЧАНИЕ:  Опции выбора математического пакета поддерживают
математические  сопроцессоры  Intel  8087, 80287 и 80387.  В этой
книге для краткости все три  сопроцессора  обозначаются  термином
"8087/287/387".

     При  выполнении  программы  SETUP  выберите  один  из   этих
математических  пакетов.   Программа SETUP включит выбранный вами
пакет  в  библиотеку,  которую  она  создаст.    Все   программы,
связываемые  с  этой  библиотекой,  используют  имеющийся  в  ней
математический пакет:  для подключения этой библиотеки  на  этапе
редактирования связей используется соответствующая опция FL.

     Для того, чтобы во время выполнения  SETUP  вам  было  легче
выбрать  опцию,  лучше  всего соответствующую вашим потребностям,


                               144



прочтите следующее описание.  (Программу  SETUP  можно  выполнять
столько   раз,  сколько  необходимо  для  построения  нужных  вам
библиотек).


     3.1.1 ПАКЕТ 8087/287/387

     Математический пакет 8087/287/387  Фортрана  использует  все
преимущества математического сопроцессора для выполнения операций
с плавающей точкой .  Интенсивные  операции  с  плавающей  точкой
стремятся замедлить работу компьютера.  Сопроцессоры 8087/287/387
это математические микросхемы, специально созданные для  быстрого
выполнения операций с плавающей точкой.

     Этот  пакет  требует  наличия  микросхемы  с  математическим
сопроцессором:    программы,  скомпилированные  на  использование
этого пакета, при выполнении без сопроцессора закончатся аварийно
(будет  выдано  сообщение об ошибке "floating point not loaded" -
буквально, "плавающая точка не загружена").  Этот  математический
пакет программа SETUP устанавливает по умолчанию, если вы явно не
выбрали другой пакет.


     3.1.2 ПАКЕТ ЭМУЛЯТОРА

     Если один из сопроцессоров 8087, 80287 или 80387 установлен,
то  пакет  эмулятора  его  использует.  Если сопроцессора нет, то
этот пакет программно эмулирует большинство функций 8087/287/387.
Пакет  эмулятора  является  наилучшим  выбором,  если  вы желаете
максимизировать  точность  и  скорость  выполнения  программы   и
хотите,   чтобы   программа   выполнялась   в   системах   как  с
сопроцессором, так и без него.

     Пакет эмулятора может выполнять основные операции с  той  же
степенью  точности, как и микросхема 8087/287/387.  Тем не менее,
процедуры    эмулятора,    используемые    для    трансцендентных
математических  функций,  немного  отличаются  от соответствующих
функций 8087/287/387.  Это может  привести  к  небольшой  разнице
(обычно,  не  более  2  бит)  в  результатах  таких  операций при
выполнении с эмулятором вместо 8087/287/387.

     ЗАМЕЧАНИЕ:  Если вы используете сопроцессор 8087, 80287  или
80387   или   эмулятор,   то  исключения  разрешения  прерываний,
точности,  потери  значимости   и   денормализованного   операнда
маскируются по умолчанию.  Остальные исключения не маскируются.


     3.1.3 АЛЬТЕРНАТИВНЫЙ МАТЕМАТИЧЕСКИЙ ПАКЕТ

     Альтернативный математический пакет дает вам самые маленькие


                               145



и  самые  быстрые программы, возможные без сопроцессора.  Однако,
результаты программ теряют в точности до нескольких значащих цифр
по  сравнению с результатами, полученными с пакетом эмулятора и с
сопроцессорами 8087/287/387.

     Альтернативный математический пакет использует  подмножество
IEEE  (Institute  of  Electrical  and  Electronics Engineers) для
стандартных форматных чисел.  Бесконечности, NAN (Not a Number) и
денормализованные числа не используются.


     3.2 ИСПОЛЬЗОВАНИЕ ОПЦИЙ ПЛАВАЮЩЕЙ ТОЧКИ (/FP)

     Опции   /FP   команды   FL   контролируют,   как   программа
обрабатывает  операции плавающей точки.  На основании опции /FP и
выбранной вами опции  модели  памяти  команда  FL  вставляет  имя
библиотеки  в  объектный файл, который она создает.  (Список имен
библиотек, используемых для каждой комбинации, есть в таблице 3.1
"Сводка  опций  плавающей  точки").  Если не задана опция /Lp или
/Lr, то эта библиотека становится  умалчиваемой  библиотекой,  то
есть  линкер  ищет в стандартных местах библиотеку с этим именем.
Если линкер  находит  такую  библиотеку,  то  использует  ее  для
разрешения  внешних ссылок в объектном файле.  В противном случае
линкер выводит на экран сообщение о том, что он  не  может  найти
библиотеку.

     Этот  механизм  позволяет  линкеру   автоматически   связать
объектный файл с нужной библиотекой.  Имеются, однако, исключения
из этого правила:  в некоторых случаях вам разрешается  связывать
с  другой  библиотекой  (как  описано  дальше  в этом разделе и в
разделе 3.3).

     Вы можете использовать в командной строке FL только одну  из
этих  опций.  Опция действует на всю командную строку, независимо
от  ее  позиции.   (Обратите   внимание,   что   x   представляет
метасимвол,  так  что xLIBFORA.LIB относится либо к LLIBFORA.LIB,
либо к MLIBFORA.LIB).  Ниже перечислены доступные опции.

Опция      Действие
-----      --------
/FPa       Генерирует вызовы плавающей точки; выбирает
           xLIBFORA.LIB.

/FPc       Генерирует вызовы плавающей точки; выбирает
           xLIBFORE.LIB.

/FPc87     Генерирует вызовы плавающей точки; выбирает
           xLIBFOR7.LIB.

/FPi       Генерирует встроенные команды; выбирает


                               146



           xLIBFORE.LIB.

/FPi87     Генерирует встроенные команды; выбирает
           xLIBFOR7.LIB (умолчание).

     Каждая опция /FP включает две спецификации:

     1.  Команды с плавающей  точкой:   либо  встроенные  команды
         8087/287/387,  либо  обращения к библиотечным функциям с
         плавающей  точкой.   Буква   "i"   означает   встроенные
         команды,  буква  "c"  или  "a" означает вызовы функций с
         плавающей точкой.

     2.  Умалчиваемый пакет с плавающей точкой для  использования
         во время редактирования связей программы.

     В таблице 3.1 приведен полный список опций /FP и их действие
(In line означает "встроенный", Calls - вызовы).

Таблица 3.1  Сводка опций плавающей точки
-----------------------------------------------------------------
                                    Использование  Выбираемая
Опция   Метод    Преимущества       сопроцессора   библиотека (1)
-----------------------------------------------------------------
/FPi87  In line  Наименьшие требо-  Необходим      LLIBFOR7.LIB
                 вания к памяти и                  или MLIB-
                 самая быстрая оп-                 FOR7.LIB (2)
                 ция, доступная с
                 сопроцессором

/FPc87  Calls    Медленнее, чем     Необходим      LLIBFOR7.LIB
                 /FPi87, но допус-                 или MLIB-
                 кает изменение                    FOR7.LIB (3)
                 библ-ки во время
                 связывания

/FPi    In line  Больше, чем        Используется,  LLIBFORE.LIB
                 /FPi87, но рабо-   если есть (4)  или
                 тает без сопроце-                 MLIBFORE.LIB
                 ссора, максимизи-
                 рует точность без
                 сопроцессора

/FPc    Calls    Медленнее, чем     Используется,  LLIBFORE.-
                 /FPi, но допуска-  если есть (4)  LIB (3) или
                 ет изменение биб-                 MLIBFORE.LIB
                 лиотеки во время
                 связывания
-----------------------------------------------------------------



                               147



-----------------------------------------------------------------
                                    Использование  Выбираемая
Опция   Метод    Преимущества       сопроцессора   библиотека (1)
-----------------------------------------------------------------
/FPa    Calls    Самая быстрая и    Игнорирует     LLIBFORA.LIB
                 наименьшая опция,  сопроцессор    или MLIB-
                 доступная без со-                 FORA.LIB (3)
                 процессора, но
                 теряет в точности
                 из-за скорости
-----------------------------------------------------------------
(1) Выбирается при отсутствии опций /Lp, /Lr и /Lc, которые
    вынуждают использовать двухрежимные библиотеки OS/2.
(2) Во время связывания может быть явно связано с LLIBFORE.LIB
    или MLIBFORE.LIB. Если используется библиотека эмулятора, то
    использование сопроцессора должно быть запрещено установкой
    NO87.
(3) Во время связывания может быть явно связано с любой
    библиотекой правильной модели памяти.
(4) Может быть запрещено установкой NO87.

     Опция  /AL  (большой)  модели  памяти  является  умолчанием.
Поэтому,  если  в  этой  же командной строке FL не задано никакой
опции  модели  памяти,  то  умалчиваемой  библиотекой  для  опции
плавающей  точки является LLIBFORx.LIB (где x равно 7, E или A, в
зависимости   от    математического    пакета,    поддерживаемого
библиотекой).    Если   задана   опция   модели  памяти  /AM,  то
умалчиваемой библиотекой является MLIBFORx.LIB.

     Компилятор  может  оценивать  некоторые  выражения.    Такие
оценки  всегда  используют  наивысшую  точность,  по  возможности
независимую от опции плавающей точки, которую вы задаете.

     В разделах 3.2.1 - 3.2.5 описаны опции /FP и преимущества  и
недостатки каждой опции.


     3.2.1 ОПЦИЯ /FPi87

     Умалчиваемой опцией плавающей точки является /FPi87, которая
включает  имя  библиотеки  8087/287/387  (либо LLIBFOR7.LIB, либо
MLIBFOR7.LIB, в зависимости от модели памяти) в  объектный  файл.
Во время связывания вы можете изменить свое мнение и явно связать
с  библиотекой  эмулятора  (LLIBFORE.LIB  или   MLIBFORE.LIB,   в
зависимости от модели памяти).  Если вы используете эту опцию при
связывании с библиотекой 8087/287/387,  то  во  время  выполнения
должен  иметься  сопроцессор  8087, 80287, 80387, иначе программа
потерпит неудачу и математический пакет выдаст сообщение

     floating point not loaded


                               148



     Если вы компилируете с /FPi87  и  связываете  с  библиотекой
эмулятора,  и  сопроцессор  доступен  во  время выполнения, то вы
можете использовать переменную  окружения  NO87,  если  пожелаете
запретить  использование  сопроцессора.  (Описание NO87 имеется в
разделе 3.4).  Если вы связываете с библиотекой 8087/287/387,  то
опция  /FPi87  является  самой  быстрой и самой маленькой опцией,
доступной для операций с плавающей точкой.

     Компилятор MSФортрана не генерирует подлинный встроенный код
8087/287/387,  если  вы  используете  опцию /FPi87.  Вместо этого
компилятор вставляет программные прерывания в часть  программы  с
библиотечным   кодом,   который   заставляет   каждое  прерывание
использовать либо эмулятор, либо сопроцессор.   Если  вы  связали
программу  с  кодом  эмулятора,  то эти прерывания будут вызывать
эмулятор, если математическая микросхема не доступна.

     Если  ваша  программа  создана  для  выполнения   только   с
сопроцессором,   то   вы  можете  ускорить  программу  с  помощью
ассемблирования и связывания следующего кода,  который  устраняет
эту  специальную  обработку.   Кроме  того, все ошибки деления на
нуль будут маскироваться.

PUBLIC PIARQQ, PICRQQ, PIDRQQ, PIERQQ, PISRQQ, PIWRQQ
PUBLIC PJARQQ, PJCRQQ, PJSRQQ

FIARQQ EQU 0
FICRQQ EQU 0
FIDRQQ EQU 0
FIERQQ EQU 0
FISRQQ EQU 0
FIWRQQ EQU 0
FJARQQ EQU 0
FJCRQQ EQU 0
FJSRQQ EQU 0

extern __fpmath:for
extern __fpsignal:for
extern __fptaskdata:for

CDATA segment word common 'DATA'
    dw 0
    dw__fpmath
    dw__fpsignal
    dw__fptaskdata
CDATA ends

END





                               149



     3.2.2 ОПЦИЯ /FPc87

     Опция  /FPc87  генерирует  вызовы  процедур  из   библиотеки
8087/287/387  (LLIBFOR7.LIB  или  MLIBFOR7.LIB,  в зависимости от
модели  памяти),  которые   выполняют   соответствующие   команды
8087/287/387.   Как  и  в случае с опцией /FPi87, вы должны иметь
установленный сопроцессор 8087, 80287 или  80387  для  выполнения
программ,   скомпилированных   с   этой   опцией  и  связанных  с
библиотекой 8087/287/387.  Однако, опция /FPc87  позволяет  также
изменить   ваше   мнение   во  время  связывания  и  связывать  с
альтернативной  математической   библиотекой   вместо   библиотек
эмулятора  или  8087/287/387.  (Информация об изменении библиотек
во время связывания имеется в разделе 3.3)

     ЗАМЕЧАНИЕ:    Если   используется   /FPc87,   то   некоторые
оптимизации  не  выполняются, уменьшая эффективность вашего кода.
Результаты могут немного отличаться, поскольку может  выполняться
арифметика различной точности.


     3.2.3 ОПЦИЯ /FPi

     Опция /FPi генерирует встроенные  команды  для  сопроцессора
8087, 80287 или 80387, и помещает в объектный файл имя библиотеки
эмулятора (LLIBFORE.LIB или MLIBFORE.LIB).   Эта  опция  особенно
полезна,   если  вы  заранее  не  знаете,  будет  ли  сопроцессор
8087/287/387   доступен   во   время   выполнения.     Если    вы
распространяете   свою  программу  для  использования  на  других
компьютерах, то должны использовать опцию /FPi.

     Если сопроцессор доступен во время выполнения, то  программа
его  использует.   Если  нет,  то  операции  с  плавающей  точкой
выполняются эмулятором.  Если во время выполнения сопроцессор  не
доступен,   то   опция   /FPi  это  наиболее  эффективный  способ
максимизировать точность плавающей точки.


     3.2.4 ОПЦИЯ /FPc

     Опция /FPc генерирует вызовы (обращения) плавающей  точки  к
библиотеке  эмулятора  и  затем  помещает  в  объектный  файл имя
библиотеки   эмулятора   (LLIBFORE.LIB   или   MLIBFORE.LIB,    в
зависимости  от  модели  памяти).   Опция  /FPc  дает  вам больше
гибкости, чем /Fpi, поскольку  она  позволяет  связывать  либо  с
8087/287/387,  либо  с  альтернативной математической библиотекой
вместо библиотеки эмулятора.  (Информация об изменении библиотеки
во   время   связывания   имеется  в  разделе  3.3).   Эта  опция
рекомендуется  также,  если   вы   связываете   с   библиотеками,
отличающимися от библиотек, построенных SETUP.



                               150



     3.2.5 ОПЦИЯ /FPа

     Опция /FPa генерирует  вызовы  плавающей  точки  и  выбирает
альтернативную   математическую   библиотеку   (LLIBFORA.LIB  или
MLIBFORA.LIB, в зависимости от модели  памяти).   Эта  библиотека
является  самой быстрой и самой маленькой, если вы не используете
сопроцессор 8087, 80287 или 80387.   Подобно  опции  /FPc,  опция
/FPa  позволяет вам выбирать во время связывания, использовать ли
эмулятор или библиотеку 8087/287/3387.


     3.3 ИСПОЛЬЗОВАНИЕ БИБЛИОТЕК ДЛЯ ВЫБОРЕ ОПЦИЙ /FP

     Для опции плавающей точки, заданной вами в командной  строке
FL,  иногда  может  понадобиться  использовать другие библиотеки,
помимо  умалчиваемой.    Например,   вы   можете   создать   свои
собственные  библиотеки  или  другие  наборы  подпрограмм  в виде
объектных файлов, и позднее связывать эти библиотеки с объектными
файлами,   которые  компилировались  с  другими  опциями  FL.   В
следующих разделах эти случаи  обсуждаются  достаточно  подробно.
Хотя  в  обсуждении  предполагается,  что  вы загрузили объектные
файлы в библиотеки, но те же самые рассуждения  действуют  и  при
использовании отдельных объектных файлов.


     3.3.1 ВЫБОР ВСТРОЕННЫХ КОМАНД ИЛИ ВЫЗОВОВ

     Для того,  чтобы  выбрать  соответствующую  опцию  плавающей
точки,  вам  необходимо сначала решить, хотите ли вы использовать
встроенные команды и компилировать с опцией /FPi87 или /FPi,  или
вы   хотите   использовать   вызовы  функций  плавающей  точки  и
компилировать с опцией /Fpc87, /FPc или /FPa.

     Если  вы  выбрали  встроенные  команды  для   предварительно
откомпилированных  объектных файлов, то вы не можете использовать
альтернативный  математический  пакет  (то  есть,  вы  не  можете
связывать   с   библиотекой  xLIBFORA.LIB).   Однако,  встроенные
команды дают более  лучшие  характеристики,  если  вы  выполняете
программу на машинах с сопроцессором 8087, 80287 или 80387.

     Если  вы  выбрали  вызовы,  то  ваш  код  выполняется  более
медленно,  но  во  время  связывания вы можете использовать любую
стандартную  библиотеку  Фортрана  (то  есть,  любую  библиотеку,
созданную  программой SETUP), которая поддерживает текущую модель
памяти.


     3.3.2 ИСПОЛЬЗОВАНИЕ СТАНДАРТНОЙ БИБЛИОТЕКИ ДЛЯ СВЯЗЫВАНИЯ

     Во  время  связывания  (редактирования  связей)  вы   должны


                               151



использовать   только   одну   стандартную  библиотеку  Фортрана.
Контроль над этим можно осуществлять двумя путями:

     1.  Первым именем в списке объектных файлов, которые  должны
         быть  связаны,  ставьте объектный файл, который содержит
         имя  нужной  библиотеки.   Например,  если  вы   желаете
         использовать  альтернативную  математическую библиотеку,
         то должны задать имя объектного файла, скомпилированного
         с использованием опции /FPa.  Все вызовы плавающей точки
         в  этом  объектном  файле  обращаются  к  альтернативной
         математической библиотеке.

     2.  Во  время  связывания   выберите   опцию   /NOD   (поиск
         не-умалчиваемой  библиотеки), а имя библиотечного файла,
         содержащего нужный вам пакет плавающей точки, задайте  в
         поле "Libraries" или в ответ на приглашение "Libraries".
         Эта библиотека  замещает  имена  библиотек  в  объектных
         файлах;   все   вызовы   плавающей  точки  ссылаются  на
         указанную библиотеку.

     Каждая библиотека в связываемых объектных файлах добавляется
в  "список  поиска линкера" (то есть, в список библиотек, которые
линкер просматривает для разрешения внешних к  Фортрану  ссылок).
Такой поиск может усложнить выбор стандартной библиотеки.

     Предположим, например,  что  вы  используете  опцию  /FPa  с
программой  большой  модели  памяти для создания набора объектных
файлов и затем  используете  утилиту  LIB  для  объединения  этих
объектных  файлов  в  библиотеку.   Очень  возможно,  что  каждый
объектный файл будет включать  имя  умалчиваемой  библиотеки  (то
есть,  вы  не  использовали  при  компиляции опцию /Zl).  Если вы
хотите связать эту библиотеку с  объектным  файлом,  созданным  с
помощью   опции   /FPc87,   то  учтите,  что  и  LLIBFOR7.LIB,  и
LLIBFORA.LIB находятся в списке поиска линкера (предполагая,  что
вы  компилировали с опцией умалчиваемой модели памяти).  Линкер в
первую  очередь  просматривает  библиотеки  в  командной  строке,
поэтому  LLIBFOR7.LIB он просматривает до просмотра LLIBFORA.LIB.
Поскольку LLIBFOR7.LIB разрешит все внешние ссылки правильно,  то
этот механизм и сработает правильно.

     Вы можете гарантировать явное использование  выбранной  вами
стандартной  библиотеки, поместив ее имя в командной строке LINK.
В этом случае LINK всегда  просматривает  вашу  библиотеку  перед
просмотром  библиотек,  упомянутых  в  объектных  файлах.  Тем не
менее, удостоверьтесь, что  в  командной  строке  вы  задали  эту
библиотеку  после задания всех ваших собственных библиотек.  Если
вы ее не задали и в вашей  библиотеке  указана  другая  директива
поиска, то вы можете столкнуться с проблемами.

     Предположим, например, что объектные модули в  библиотеке  B


                               152



были  скомпилированы  с  опцией  /FPc87  так,  что  каждый модуль
содержит  директиву  поиска  для  библиотеки  LLIBFOR7.LIB.    Вы
желаете связывать с объектным файлом A, скомпилированным с опцией
/FPa так, что этот объектный файл содержит директиву  поиска  для
LLIBFORA.LIB.   Следующая командная строка связывает библиотеку B
с объектным файлом A:

LINK A,,,LLIBFOR7+B;

     После этого  линкер  просматривает  библиотеки  в  следующем
порядке:

     1.  LLIBFOR7.LIB (поскольку она задана  первой  в  командной
         строке).

     2.  B (поскольку она задана второй в командной строке).

     3.  LLIBFORA.LIB  (поскольку  объектный  модуль  A  содержит
         директиву поиска длю этой библиотеки).

     4.  LLIBFOR7.LIB (поскольку  модули  в  вашей  библиотеке  B
         содержат директивы поиска для этой библиотеки).

     Процедура связывания должна работать следующим образом:

     1.  Линкер ищет LLIBFOR7.LIB и разрешает в объектном файле A
         все  ссылки на стандартные процедуры времени выполнения,
         поскольку вы задали эту библиотеку в командной строке.

     2.  Линкер   закрывает   LLIBFOR7.LIB   и   ищет   следующую
         библиотеку   для   разрешения   ссылок  на  процедуры  в
         библиотеке B.  Эти процедуры обычно содержат  ссылки  на
         стандартные  процедуры  времени  выполнения.   Поскольку
         LLIBFORA.LIB является следующей библиотекой  для поиска,
         то   эта   библиотека  разрешает  ссылки  в  B.  Однако,
         она не является  библиотекой,  которую  вы  намеревались
         использовать,  поскольку  вы  компилировали  B  с опцией
         /FPc87, которая использует LLIBFOR7.LIB  для  разрешения
         ссылок на стандартные процедуры времени выполнения.

     Как  показано  в  этом  примере,  вы  не  можете   смешивать
библиотеки  таким  образом, иначе столкнетесь с ошибками линкера.
Обратите внимание, что если бы вы задали в командной строке  LINK
библиотеку  B+LLIBFOR7.LIB вместо LLIBFOR7.LIB+B, то линкер искал
бы LLIBFOR7.LIB вместо  библиотеки  LLIBFORA.LIB  для  разрешения
стандартных  ссылок  времени выполнения в B и операция связывания
происходила бы корректно.

     Для того, чтобы избежать такого рода неопределенности и быть
абсолютно   уверенным,  что  вы  задаете  правильную  стандартную


                               153



библиотеку для связывания, используйте опцию линкера  /NOD.   Эта
опция  заставляет линкер просматривать только библиотеки, которые
вы задаете в командной строке.

     И наоборот, для подавления поиска по  умолчанию  в  заданной
библиотеке  используйте  форму  /NOD:имябиблиотеки.  Это полезно,
если библиотека, заданная в командной строке, включает  директивы
поиска  для  других библиотек, которые вы не хотите явно задать в
командной строке.

     Возможно,   что   самым   надежным,   особенно    если    вы
распространяете  библиотеку  среди других пользователей, является
компиляция объектных файлов  для  создания  библиотеки  с  опцией
/FPc.   Эта  опция предписывает компилятору не включать директивы
поиска  в  объектные  файлы.   Позднее,   когда   вы   связываете
библиотеку   с   различными   объектными   файлами,   стандартная
библиотека, используемая для связывания, зависит только от  опций
плавающей  точки  и  модели  памяти,  задаваемых  при  компиляции
последующих  объектных  файлов.   Опция  /FPc  рекомендуется  для
максимальной гибкости при связывании с такими библиотеками.

     В следующем примере исходный файл CALC.FOR  компилируется  с
умалчиваемой опцией плавающей точки /FPi87:

FL /c CALC.FOR
LINK CALC+ANOTHER+SUM;

     /FPi87 генерирует встроенные команды и  выбирает  библиотеку
8087/287/387  (то  есть,  LLIBFOR7.LIB,  поскольку  никакой опции
плавающей точки не задано, а библиотека большой  модели  является
умолчанием).

     В следующем примере CALC.FOR компилируется с  альтернативной
математической опцией (/FPa):

FL /c /FPa CALC.FOR
FL CALC ANOTHER SUM /link LLIBFORE.LIB /NOD

     При связывании с  помощью  команды  FL  поле  /link  (опции,
следующие  после /link) определяет опцию /NOD так, что библиотека
LLIBFORA.LIB (имя которой вставлено в объектный файл CALC.OBJ) не
просматривается.    Это   поле  содержит  имя  LLIBFORE.LIB,  что
заставляет все вызовы плавающей  точки  обращаться  к  библиотеке
эмулятора вместо альтернативной математической библиотеки.

     В  следующем  примере  SAMPLE.FOR  компилируется  с   опцией
/FPc87,  которая  выбирает  в  качестве  умалчиваемой  библиотеки
библиотеку 8087/287/387 (LLIBFOR7.LIB):

FL /FPc87 SAMPLE.FOR /link /NOD:LLIBFOR7.LIB LLIBFAP.LIB


                               154



     Здесь командная строка использует опцию  /NOD:   для  отмены
выбора  LLIBFOR7.LIB  и  предписывает линкеру использовать взамен
LLIBFAP.LIB (защищенный режим OS/2 альтернативной  математической
библиотеки).    Опция   /NOD:    заставляет  линкер  игнорировать
следующую библиотеку, заданную в командной  строке,  но  включить
все  последующие  библиотеки  (и все ссылки на другие библиотеки,
которые они содержат).  Таким образом, DOSCALLS.LIB  (на  которую
есть ссылки в LLIBFAP.LIB) будет также просматриваться.


     3.3.3 ОБЕСПЕЧЕНИЕ СОВМЕСТИМОСТИ МЕЖДУ ОПЦИЯМИ

     Опцию  плавающей  точки  вы  можете  задавать   при   каждой
компиляции   исходного   файла.   Если  вы  связываете  несколько
объектных файлов для создания исполняемого программного файла, то
должны    обеспечить,   чтобы   операции   с   плавающей   точкой
обрабатывались правильно, и чтобы текущая среда позволила линкеру
найти   необходимую  библиотеку.   Предоставленный  самому  себе,
линкер может и не выбрать нужную вам библиотеку.

     ЗАМЕЧАНИЕ:  Если  вы  строите  свои  собственные  библиотеки
процедур,  которые  содержат  операции  плавающей точки, то опция
/FPc рекомендуется для всех компиляций.


     3.3.4 СПЕЦИАЛЬНАЯ ПРОЦЕДУРА ДЛЯ ПОЛЬЗОВАТЕЛЕЙ MS-DOS 3.2

     Этот раздел имеет значение в том случае, если  ваша  система
содержит все нижеперечисленное:

      o  Вы используете MS-DOS версии 3.2.

      o  Вы загружаетесь с жесткого диска.

      o  Ваш  компьютер  использует  математический   сопроцессор
         (например, 80387).

      o  Вы исполняете программы, которые используют  операции  с
         плавающей точкой.

     Для систем, которые удовлетворяют  всем  этим  условиям,  вы
можете   разрешить   все   проблемы  плавающей  точки  установкой
маленькой "заплаты" в DOS.

     ЗАМЕЧАНИЕ:   Проблемы  плавающей  точки  были  устранены   в
версиях DOS выше 3.2, включая DOS 3.21 и 3.3.

     Если  вы  не  уверены  в  необходимости  заплаты,  выполните
следующие действия:



                               155



     1.  Скопируйте  программу  PATCH87.EXE  (включенную  в   эту
         поставку) в корневой каталог вашего жесткого диска.

     2.  Перезагрузите   систему   с   жесткого   диска.    После
         перезагрузки  не  выполняйте  никаких операций с гибкими
         дисками.  Очень важно избежать  ввода-вывода  с  гибкого
         диска  после  перезагрузки, поскольку он будет влиять на
         надежность   диагностических   проверок,   которые    вы
         собираетесь выполнять.

     3.  Если необходимо,  используйте  команду  CD  из  DOS  для
         перемещения в корневой каталог жесткого диска.

     4.  Выполните   программу   PATCH87.EXE,   введя   следующую
         команду:

         PATCH87

     Эта  программа  выполняет  диагностическую  проверку   вашей
системы, чтобы определить, нужна ли заплата на DOS и, если да, то
может ли она быть выполнена успешно.

     Если тест показывает, что вы должны поставить заплату в DOS,
то выполните следующие действия:

     1.  Отформатируйте  пустой  гибкий  диск.   (Не  используйте
         опцию  форматирования  /S для передачи на диск системных
         файлов.

     2.  Используйте  команду  SYS  для  копирования   IO.SYS   и
         MSDOS.SYS (или PCDOS.SYS) из корневого каталога жесткого
         диска  на  новый  гибкий  диск.    Например,   если   вы
         загружаетесь  с  диска  C:,  то  должны ввести следующие
         команды:

         C:
         SYS A:

     3.  Используйте команду COPY для копирования  COMMAND.COM  и
         SYS.COM на этот же гибкий диск.

     4.  Используйте  команду  COPY  для  копирования   программы
         PATCH87.EXE  (входящую  в  эту версию) на этот же гибкий
         диск.

     5.  Смените текущие диск и каталог на гибкий диск, введя:

         A:

     6.  Поставьте заплату в DOS, введя:


                               156



         PATCH87 /F

         ----------------------------------------------------------
         ПРЕДУПРЕЖДЕНИЕ: Если вы столкнулись с какой-либо дисковой
         ошибкой при выполнении шагов с 2 по 6, то не переходите к
         шагу 7. Перезагрузитесь с жесткого диска и повторите весь
         процесс.
         ----------------------------------------------------------

     7.  Если ошибок не встретилось, используйте команду SYS  для
         передачи  файлов  IO.SYS  и  MSDOS.SYS  (или  PCDOS.SYS)
         обратно с гибкого диска на жесткий диск.  Например, если
         ваша  система загружается из корневого каталога на диске
         C:, то вам нужно ввести следующую команду по приглашению
         DOS:

         A:
         SYS C:

     8.  Заплата DOS установлена.  Перезагрузите систему.


     3.3.5 ИСПОЛЬЗОВАНИЕ $FLOATCALLS И $NOFLOATCALLS

     Метакоманды  $FLOATCALLS   и   $NOFLOATCALLS   контролируют,
обрабатываются  ли  операции с плавающей точкой через обращения к
библиотечным подпрограммам, или с помощью встроенных команд.  Эти
метакоманды   больше   не  рекомендуются.   Опции  /FP  выполняют
аналогичный контроль и  являются  более  гибкими,  поскольку  они
выбирают библиотеку, которая должна использоваться, а также метод
обработки.

     Тем не менее, если у вас  есть  код,  который  содержит  эти
метакоманды,  то  имейте  в виду, что $FLOATCALLS и $NOFLOATCALLS
контролируют только метод обработки для операций плавающей точки.
Они  не  влияют  на имя библиотеки, которое компилятор помещает в
объектный  файл;  это  определяется  опциями  /FP,   которые   вы
выбираете в командной строке FL.

     Обратите внимание также, что эти метакоманды имеют приоритет
над  опциями  плавающей точки, задаваемыми в командной строке FL.
Это может  означать,  например,  что  исходный  файл,  содержащий
$NOFLOATCALLS,   может  дать  объектный  файл,  который  содержит
встроенные команды, даже если  он  был  откомпилирован  с  опцией
/FPa.   Такой  объектный  файл  не  будет корректно связываться с
альтернативной математической библиотекой.






                               157



     3.4 ИСПОЛЬЗОВАНИЕ ПЕРЕМЕННОЙ ОКРУЖЕНИЯ NO87

     Программы, компилируемые с опцией /FPc или /FPi,  используют
во время выполнения сопроцессор 8087/287/387, если он установлен.
Вы  можете  запретить  это  и   заставить   использовать   вместо
сопроцессора  эмулятор,  установив  переменную  окружения (среды)
NO87.

     Если при  выполнении  программы  переменной  NO87  присвоено
какое-либо   значение,   то   программа   игнорирует  сопроцессор
8087/287/387.  Значение NO87 появляется в качестве  сообщения  на
стандартном  выходном  устройстве.  Сообщение появляется только в
том случае,  если  8087/287/387  присутствует  и  запрещен;  если
сопроцессор  отсутствует, то сообщение не появляется.  Если вы не
хотите  вывода  сообщения,  присвойте  NO87  один  или  несколько
пробелов.

     Заметьте,  что  для  запрещения  использования  сопроцессора
важно   только   наличие   или   отсутствие   определения   NO87.
Фактическое значение NO87 влияет только на появление сообщения на
экране.

     Переменная  NO87  действует  с  программами,  связанными   с
библиотекой  эмулятора  (LLIBFORE.LIB  или MLIBFORE.LIB).  Она не
влияет на программы с  LLIBFOR7.LIB,  MLIBFOR7.LIB,  MLIBFORA.LIB
или LLIBFORA.LIB.

     Ниже показан пример использования NO87:

SET NO87=Use of coprocessor suppressed

     Этот оператор вызывает появление на экране сообщения Use  of
coprocessor suppressed, если выполняется программа, которая может
использовать установленный сопроцессор  8087,  80287  или  80387.
Заметьте,  что  если  за  знаком  равенства  следует  пробел,  то
сопроцессор запрещается, но сообщение не выводится.

     Пример  ниже  не  присваивает  значения   переменной   NO87;
оператор  не  запрещает  сопроцессор.   Обратите внимание, что за
знаком равенства не следует никаких символов или пробелов:

SET NO87=

     Программы,   которые    могут    использовать    сопроцессор
8087/287/387, используют его, если он просутствует.







                               158



     3.5  ОБРАБОТКА ИСКЛЮЧИТЕЛЬНЫХ СИТУАЦИЙ ПЛАВАЮЩЕЙ ТОЧКИ
          8087/287/387

     Сопроцессор 8087/287/387 и процедуры поддержки  вещественной
математики поддерживают пять исключительных ситуаций (исключений)
плавающей арифметики,  требуемых  стандартом  IEEE.   Исключения,
приводящие  к  сообщению  NAN  ("Not  a  Number"), разрешаются по
умолчанию.  Остальные запрещаются.

     Метакоманда  $DEBUG  не  влияет  на  эти   исключения;   они
контролируются  словами  "состояния"  и  "контроля",  как описано
ниже.

     В таблице 3.2 перечислены шесть исключений и их умалчиваемые
и альтернативные действия.

Таблица 3.2  Исключения плавающей точки
-----------------------------------------------------------------
Исключения
плавающей                        Действие по       Альтернативное
точки          Описание          умолчанию         действие
-----------------------------------------------------------------
Недопустимая   Приводит к NAN,   Разрешено: дает   Нет: не может
операция       например, квад-   сообщение об      быть маскиро-
               ратный корень     ошибке M6101 во   вано
               из -1 или 0*INF   время выполнения

Деление        Оценивается ве-   Разрешено: дает   Запрещено:
на нуль        щественным чис-   сообщение об      возвращает INF
               лом, делимым на   ошибке M6103 во   со знаком
               нуль: r/0.0       время выполнения  (бесконечность)

Переполнение   Приводит к чис-   Разрешено: дает   Запрещено:
               лу, превышающе-   сообщение об      возвращает INF
               му максимальное   ошибке M6104 во
               представимое      время выполнения
               число

Потеря         Приводит к чис-   Запрещено: воз-   Разрешено:
значимости     лу, меньшему      вращает нуль      дает сообщение
               наименьшего                         об ошибке
               представимого                       M6105 во время
               числа                               выполнения
-----------------------------------------------------------------








                               159



Таблица 3.2  Исключения плавающей точки
-----------------------------------------------------------------
Исключения
плавающей                        Действие по       Альтернативное
точки          Описание          умолчанию         действие
-----------------------------------------------------------------
Денормали-     Приводит к та-                      Нет: не может
зованный       кому маленькому                     быть маскиро-
операнд        числу, которое                      вано
               может быть пред-
               ставлено только
               приблизительно

Точность (или  Имеет место вся-  Запрещено: воз-   Разрешено:
неточность)    кий раз, когда    вращает соответ-  дает сообщение
               результат под-    ствующий округ-   об ошибке
               вержен ошибке     ленный результат  M6106 во время
               округления                          выполнения
-----------------------------------------------------------------

     Если какие-либо  из  этих  шести  исключений  запрещены,  вы
можете  получить в ваших переменных нечисловые (NAN), бесконечные
или неопределенные значения.  Если вы печатаете  такое  значение,
то  выходное  поле  будет содержать NAN, INF или IND, дополненное
точками до ширины поля.  Если выходное поле меньше трех пробелов,
печатаются только точки.


     3.5.1 УПРАВЛЕНИЕ СРЕДОЙ ОБРАБОТКИ

     Процессоры  8086/286/386   и   8087/287/387   контролируются
словами  состояния  и  контроля,  соответственно.  В этом разделе
описано использование этих ячеек памяти.

     Если имеет место одна из исключительных  ситуаций  плавающей
точки,  указанных  выше  в  таблице  3.2,  то  в  слове состояния
устанавливается  соответствующий   бит.    Этот   флаг   остается
установленным, пока вы его не очистите.

     На рисунке 3.1 показан формат слова состояния.












                               160



             15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
            |  |  |  |  |  |  |  |  |IR|  |  |  |  |  |  |  |
            |  |  |  |  |  |  |  |  |or|  |  |  |  |  |  |  |
            |B |C0|ST|ST|ST|C2|C1|C0|ES|  |PE|UE|OE|ZE|DE|IE|
            +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
             |   | \______/ \______/  |     |  |  |  |  |  |
Busy (8087)  |   |    |        |      |     |  |  |  |  |  |
or NEU busy  |   |    |        |      |     |  |  |  |  |  |
(80287)(a) --+   |    |        |      |     |  |  |  |  |  |
Condition code(b)+    |        |      |     |  |  |  |  |  |
Stack top pointer (a)-+        |      |     |  |  |  |  |  |
         Condition code (b) ---+      |     |  |  |  |  |  |
           Interrupt request (8087) --+     |  |  |  |  |  |
                                 or   |     |  |  |  |  |  |
   Error-summary status (80287) (c) --+     |  |  |  |  |  |
                      Precision exception --+  |  |  |  |  |
                         Underflow exception --+  |  |  |  |
                            Overflow exception ---+  |  |  |
                             Zero-divide exception --+  |  |
                       Denormalized-operand exception --+  |
                             Invalid-operation exception --+

    (Все остальные биты не используются и могут быть 1 или 0).

(a) Эмулятор игнорирует установку битов указателя
    верхушки стека (ST) и занятости (B).
(b) Интерпретация битов кода состояния имеется
    в дукументации Intel.
(c) Для 80287 бит ES устанавливается, если установлен любой
    бит немаскируемого исключения, иначе ES очищается.

Рисунок 3.1  Формат слова состояния

     Если  бит,  соответствующий  одному  из   этих   исключений,
установлен   (равен  1)  в  слове  контроля,  то  это  исключение
маскируется и  операция,  вызвавшая  исключение,  продолжается  с
умалчиваемым  действием.   Иначе,  если  бит очищен (равен 0), то
соответствующее  исключение  генерирует  сообщение   об   ошибке,
останавливает  операцию  и  прекращает  выполнение  программы.  В
любом случае исключение логически включается  (с  помощью  OR)  в
слово состояния.

     На рисунке 3.2 показан формат слова контроля.









                               161



            15 14 13 12 11-10  9-8   7  6  5  4  3  2  1  0
           |  |  |  |  |     |     |   |  |  |  |  |  |  |  |
           |  |  |  |IC|  RC |  PC |IEM|  |PM|UM|OM|ZM|DM|IM|
           +--+--+--+--+-----+-----+---+--+--+--+--+--+--+--+
                     |    |     |    |     |  |  |  |  |  |
Infinity control(a) -+    |     |    |     |  |  |  |  |  |
      Round control (b) --+     |    |     |  |  |  |  |  |
        Precision control (c) --+    |     |  |  |  |  |  |
 Interrupt-enable mask (8087 only) --+     |  |  |  |  |  |
                         Precision mask ---+  |  |  |  |  |
                            Underflow mask ---+  |  |  |  |
                                Overflow mask ---+  |  |  |
                                Zero-divide mask ---+  |  |
                          Denormalized-operand mask ---+  |
                                Invalid-operation mask ---+
(a) Контроль бесконечности:
     0 = Проективный
     1 = Аффинный
(b) Контроль округления:
    00 = Округление к ближайшему или четному
    01 = Округление вниз (к -INF)
    10 = Округление вверх (к +INF)
    11 = Отсечение (усекает к 0)
(c) Контроль точности:
    00 = 24 бита мантиссы
    01 = (зарезервировано)
    10 = 53 бита мантиссы
    11 = 64 бита мантиссы

Рисунок 3.2  Формат слова контроля

     Кроме маскируемых исключительных  ситуаций,  слово  контроля
используется  для  установки  следующих  режимов  для  внутренней
арифметики, требуемых стандартом IEEE:

Режим           Описание
-----           --------
Контроль        Выбирает   аффинный   режим   (режим,  в  котором
бесконечности   используется хорошо  известный  стиль  арифметики
                +INF и -INF)  или  проективный  режим  (режим,  в
                котором +INF и -INF считаются одинаковым числом).
                Главное действие проективного режима в том, чтобы
                изменить характер сравнений; проективная  INF  не
                сравнивается ни с чем, кроме себя.

Контроль        Округляет  до  ближайшего  (или  четного), вверх,
округления      вниз, или отсекает.

Контроль        Определяет бит мантиссы (24, 53 или 64), в котором
точности        имеет место округление.   Все результаты занимают


                               162



                64 бита, независимо от контроля точности, который
                влияет только на округление во внутреннем виде.

     Текущие умолчания для слова контроля приведены  в  следующем
списке:

Режим или маска              Умолчание
---------------              ---------
Контроль бесконечности       Аффинный

Контроль округления          Ближайший

Контроль точности            64 бита

Маска разрешения прерываний  Не маскируется

Маска точности               Маскируется

Маска потери значимости      Маскируется

Маска переполнения           Не маскируется

Маска деления на нуль        Не маскируется

Маска денормализованного     Маскируется (не может быть
операнда                     изменена)

Маска недействительной       Не маскируется
операции

     В таблице  3.3  определены  значения  масок  для  исключений
переполнения,   деления  на  нуль  и  недействительной  операции,
связанных  с  несколькими   необязательными   словами   контроля.
Значение  слова  контроля,  равное  десятичному  4914, определяет
значение умалчиваемой маски, которое является  обычным  во  время
операций 8087/287/387.

Таблица 3.3  Маски, устанавливаемые для исключений операций
-----------------------------------------------------------------
Слово контроля        Переполнение         Деление на нуль
-----------------------------------------------------------------
4914 = 16#1332        Не маскируется       Не маскируется
4915 = 16#1333        Не маскируется       Не маскируется
4918 = 16#1336        Не маскируется       Маскируется
4919 = 16#1337        Не маскируется       Маскируется
4922 = 16#133A        Маскируется          Не маскируется
4923 = 16#133B        Маскируется          Не маскируется
4926 = 16#133E        Маскируется          Маскируется
4927 = 16#133F        Маскируется          Маскируется
-----------------------------------------------------------------


                               163



     3.5.2 ЧТЕНИЕ И УСТАНОВКА ЗНАЧЕНИЙ СОСТОЯНИЯ И КОНТРОЛЯ

     Вы можете использовать следующие  процедуры  и  функции  для
чтения   и   установки  значений  слов  состояния  и  контроля  -
аргументов INTEGER*2, передаваемых в  соответствующие  процедуры,
описанные  ниже.   Их  значения  определяют поведение процессоров
8086/286/386 (слово состояния) и 8087/287/387 (слово контроля).

     Функция  запоминания-слова-состояния   (SSWRQQ)   возвращает
значение  слова  состояния.   Используйте  следующее описание для
этой процедуры:

      INTERFACE TO INTEGER*2 FUNCTION SSWRQQ()
      END

     Функция   запоминания-слова-контроля   (SCWRQQ)   возвращает
значение слова контроля.  Используйте следующее описание для этой
процедуры:

      INTERFACE TO INTEGER*2 FUNCTION SCWRQQ()
      END

     Процедура загрузки-слова-контроля (LCWRQQ) присваивает слову
контроля заданное значение.  LCWRQQ имеет следующee описание:

      INTERFACE TO SUBROUTINE LCWRQQ(CW)
      INTEGER*2 CW
      END

     Для изменения слова контроля всегда используйте LCWRQQ.  Для
того,   чтобы   специальные  процедуры,  обрабатывающие  стековые
исключительные  ситуации  и   распространение   денормализованных
чисел,    всегда    работали    корректно,   слово   контроля   и
вспомогательные переменные должны быть установлены точно так  же,
как  их  организует  LCWRQQ.  (Денормализованные числа это числа,
очень близкие к нулю - порядка 10**(-38)  или  меньше  -  которые
допускают  постепенную  потерю  значимости.   Функции MSФортрана,
такие как NEAREST и PRECISION, не применяются к денормализованным
числам).

     ЗАМЕЧАНИЕ:  Если вы используете сопроцессор  8087/287/387  с
языком  Microsoft,  то изменение слова контроля с помощью команды
макроассемблера FLDCW не рекомендуется.

     Поскольку распространение денормализованных чисел не  входит
в    стандарт   IEEE,   то   обработчик   исключений   MSФортрана
перехватывает денормализованные исключения для получения  эффекта
маскирования.    Сами   микросхемы   8087/287/387   не  маскируют
денормализованные числа.  Вы не  можете  изменить  эту  обработку
денормализованных    чисел,    независимо    от   значения   бита


                               164



денормализации в слове контроля LCWRQQ.

     Обработчик  исключений  MSФортрана  разрешает   программному
обеспечению  маскировать  неправильные  операции, но не разрешает
маскировать  их  математической  микросхеме.   Если   вы   решили
использовать  программное  маскирование, то знайте, что это может
повлиять на выполнение программы, если вы выполняете ее на других
компьютерах    или   компилируете   программу,   написанную   для
MSФортрана, с помощью другого компилятора.


     3.5.3 ИСКЛЮЧЕНИЯ ПЛАВАЮЩЕЙ ТОЧКИ В PC-DOS 3.2

     Программы, выполняемые на IBM PC под управлением PC-DOS 3.2,
которая   перехватывает  исключения  плавающей  точки,  могут  не
работать, если имеют место эти исключения.

     Используйте следующую процедуру для  наложения  "заплаты"  в
IBM PC-DOS 3.2:

     1.  Используйте  команду  SYS   из   PC-DOS   для   передачи
         IBMDOS.COM и IBMBIO.COM на записываемый диск.

     2.  Скопируйте COMMAND.COM, SYS.COM и  DEBUG.COM  с  гибкого
         диска PC-DOS 3.2 на новый диск.

     3.  Скопируйте   STKPAT.BAT,   STKPAT.SCR,    RMRHS.EXE    и
         SETRHS.EXE    из    каталога   \PATCH   (включенного   в
         дистрибутив) на новый диск.

     4.  Перезагрузите систему с нового диска.

     5.  Выполните STKPAT.BAT.  Это поставит заплату в IBMBIO.COM
         на новом диске.

     6.  Используйтд команду SYS из PC-DOS для  передачи  заплаты
         на любой другой диск PC-DOS 3.2.

     Если вы работаете с версией DOS 3.2, отличной от IBM  PC-DOS
3.2,  и  у вас возникли проблемы, обратитесь в фирму-изготовитель
вашего компьютера.


     3.6 ИСПОЛЬЗОВАНИЕ КОМПЬЮТЕРОВ, СОВМЕСТИМЫХ С IBM

     Если ваш компьютер не является IBM  или  близко  совместимым
компьютером  и  вы желаете использовать сопроцессор 8087/287/387,
то   удостоверьтесь,   что   компьютер   правильно   обрабатывает
исключения.     Все   языки   Microsoft,   которые   поддерживают
сопроцессоры  8087/287/387,  должны  перехватывать  исключения  и


                               165



правильно  обнаруживать  ошибочные  ситуации.  Большинство других
языков, имеющихся в продаже, не обнаруживают  или  не  исправляют
этих ошибок.

     Обработчик исключений в библиотеках эмулятора и 8087/287/387
(то  есть,  LLIBFORE.LIB  или  MLIBFORE.LIB,  и  LLIBFOR7.LIB или
MLIBFOR7.LIB, соответственно) работает без изменения на следующих
компьютерах:

     1.  Семейство IBM PC.

     2.  Компьютеры, близко совместимые с IBM PC, например,  WANG
         PC и AT&T 6300.

     3.  Профессиональный компьютер Texas Instruments.

     4.  Любая   машина,   которая    использует    немаскируемые
         прерывания (NMI) для исключений 8087/287/387.

     Если ваш компьютер входит в этот список или же  вы  уверены,
что  он  является  близко  совместимым  с IBM, то вы можете сразу
приступать к связыванию (сборке)  ваших  программ.   В  противном
случае вам нужно модифицировать библиотеки 8087/287/387.

     Дистрибутивный  диск  содержит  исходный   файл   на   языке
ассемблера  EMOEM.ASM,  который поможет выполнить все необходимые
модификации.    Любая   машина,   которая   посылает   исключение
8087/287/387  на  контроллер  приоритетных  прерываний 8259 (8259
Priority  Interrupt  Controller),  может  быть  легко  поддержана
простым  изменением  таблицы  в  модуле EMOEM.ASM.  Исходный файл
содержит дополнительные инструкции для  модификации  EMOEM.ASM  и
наложения заплат на исполняемые файлы.


     3.7 ВЫБОР МОДЕЛИ ПАМЯТИ

     Вы  можете  получить  больший  контроль  над  использованием
памяти,  определяя модель памяти программы.  В следующих разделах
дано общее представление о моделях памяти и подробно описаны  все
модели, используемые компилятором MSФортрана:  средняя, большая и
гигантская модели.  В последних разделах даны рекомендации о том,
как  выбрать  подходящую модель для вашей программы и как сделать
необходимую настройку этой модели.

     Настройка модели памяти  под  требования  программы  создает
более эффективный код, чем при использовании умалчиваемой модели.
После  знакомства  с  умалчиваемыми  моделями  вы  узнаете,   как
модифицировать их под конкретные требования.

     "Модель памяти" это набор предопределенных  правил,  которых


                               166



придерживается  компилятор  при  трансляции  программного  кода и
данных в "сегменты" по 64K (килобайт) в  памяти.   Модель  памяти
определяет,  как компилятор организует в сегменты код и данные, и
какой  вид  адресов  (ближние,  дальние  или  гигантские)   будет
использоваться  для  доступа  к  информации  в  каждом  сегменте.
Ближний  адрес  это  16-битовое  "смещение"  (адрес  относительно
начала  текущего  сегмента),  которое  может  использоваться  для
обращения к 64K памяти (максимум); дальний или  гигантский  адрес
это  64-битовый  адрес,  который  позволяет  обращаться  ко  всей
имеющейся памяти.  (Описание сегментированной  памяти  и  адресов
для  семейства  микропроцессоров  8086/80286  находится в разделе
3.8.2).

     При выборе модели памяти вы сообщаете  компилятору,  что  он
может  делать некоторые предположения о характеристиках программы
и генерировать соответствующий машинный код.  Например,  если  вы
выбрали большую модель памяти (умалчиваемая модель для Фортрана),
то компилятор разрешает программам использовать  более,  чем  64K
для  кода  и  64K  для  данных.   Компилятор  должен генерировать
дальние адреса для кода и данных.  В  средней  модели  компилятор
ожидает только 64K данных или меньше, и генерирует ближние адреса
для обращения к элементам данных.


     3.8 ПОНИМАНИЕ МОДЕЛЕЙ ПАМЯТИ

     Для того, чтобы понять,  как  работают  модели  памяти,  вам
необходимо    познакомиться   с   сегментированной   архитектурой
семейства процессоров 8086.  В  этом  разделе  представлен  обзор
соглашений  об  адресации,  используемых в процессорах 8086, и их
отношение к моделям памяти.


     3.8.1 СЕГМЕНТЫ КОДА И ДАННЫХ

     Когда   вы   загружаете   программу   в   память,   ее   код
(прокомпилированные  исполняемые операторы) и данные (информация,
используемая программой) помещается в отдельных областях  памяти.
Процессор  рассматривает  хранящийся  код  как последовательность
операций, подлежащих выполнению.  Программа обращается  к  другим
областям кода, вызывая подпрограммы или функции.  Хранимые данные
это  любые   значения,   необходимые   программе,   для   которых
резервируется  область  памяти, включая имена переменных, массивы
или общие блоки.

     Все процессоры следуют этому фундаментальному различию между
кодом  и  данными.   Однако, способ хранения и обращения к коду и
данным программы  зависит  от  архитектуры  и  системы  адресации
используемого процессора.



                               167



     На 8086, 80286 и  80386  код  и  данные  занимают  отдельные
сегменты  и  обращение  к  ним осуществляется с помощью отдельных
сегментных  регистров.   (Описание  различных  типов  адресов   и
использование  сегментных  регистров  на  8086/286/386 изложено в
разделе 3.8.2).


     3.8.2 БЛИЖНИЕ, ДАЛЬНИЕ И ГИГАНТСКИЕ АДРЕСА

     Процессор  8086  и  его  родственники  являются  16-битовыми
машинами.   Обычно, машина, использующая 16-битовые адреса, может
обращаться только  к  64K  памяти.   Семейство  процессоров  8086
использует  специальную  схему  адресации  для  преодоления этого
ограничения.

     Для того, чтобы расширить количество памяти, к которой может
адресоваться  программа, физическая память на 8086 разделяется на
сегменты длиной по 64K каждый.  Начальная точка каждого  сегмента
в памяти представляется 16-битовым адресом.


     3.8.2.1 БЛИЖНИЕ АДРЕСА

     8086 содержит четыре регистра для хранения  базовых  адресов
сегментов:   CS  (сегмент кода), DS (сегмент данных), SS (сегмент
стека) и ES (дополнительный  сегмент).   Однако,  адрес  сегмента
указывает  только  на  "базу" (начало) сегмента.  Для обращения к
отдельному элементу внутри сегмента вам необходимо  также  задать
адрес  элемента  внутри сегмента.  Это требует 16-битового адреса
смещения, который определяет адрес элемента  относительно  начала
конкретного  сегмента.   16-битовое смещение называется "ближним"
адресом.

     Всякий раз,  когда  это  возможно,  компилятор  предпочитает
генерировать  ближние  адреса  для  обращения  к коду и элементам
данных.  Ближние адреса  много  более  эффективней,  чем  дальние
адреса,  поскольку  они  требуют  меньше  пространства  и  меньше
времени для вычисления.

     Хотя   полный   адрес   8086/286/386   занимает   32   бита,
8086/286/386  использует  зарезервированные  сегментные  регистры
таким образом, что становится возможным  обращаться  к  элементам
данных  с  помощью именно ближних адресов.  Чтобы понять, как это
работает, возьмем простейший случай, когда программа  имеет  один
сегмент  кода  и  один  сегмент данных.  Семейство 8086 имеет два
машинных  регистра,  которые  предназначены   для   обращения   к
сегментам  кода  и  данных:   регистры  CS  и  DS.   При загрузке
программы в регистр  CS  помещается  адрес  сегмента  кода,  а  в
регистр  DS  -  адрес  сегмента  данных.   Поскольку эти регистры
зарезервированы  для  этой  цели,  то  встроенные  команды   8086


                               168



предполагают,  что  соответствующие  адреса  сегментов могут быть
найдены именно там.


     3.8.2.2 ДАЛЬНИЕ АДРЕСА

     Многие программы, однако, содержат более 64K  кода  и  более
64K  данных.   Для  больших  программ  схема адресации становится
более сложной.

     Полный адрес на 8086/286/386 требует 32 бита:   16  бит  для
адреса  сегмента  и 16 бит для смещения.  Полный 32-битовый адрес
называется "дальним" адресом.

     Если программа превышает 64K, то она занимает больше  одного
сегмента  кода.   Компилятор  Microsoft  Фортрана помещает код из
каждого "модуля" (исходного файла компилятора) в свой собственный
сегмент.   Поэтому  каждый  модуль  ограничен  64K,  поскольку он
должен помещаться в сегмент.  Все вызовы  подпрограмм  и  функций
требуют,  чтобы  компилятор использовал дальние адреса, поскольку
адрес кода  должен  включать  адрес  сегмента  (адрес  модуля)  и
смещение  (адрес  процедуры  или  функции  внутри  модуля).   Это
увеличивает размер программы и делает ее  менее  эффективной,  но
позволяет ей выходить за пределы 64K.

     Аналогично, программы с данными, превышающими 64K,  занимают
более  чем  один  сегмент данных.  Компилятор разделяет данные по
различным классам (например, глобальные неинициированные  данные,
константы  и  глобальные  инициированные  данные)  и распределяет
разные классы по разным сегментам.

     В случае  нескольких  сегментов  данных  некоторые  элементы
данных  помещаются  в  "умалчиваемый  сегмент  данных",  то есть,
сегмент  данных,  адресуемый  регистром  DS.   (Более   подробная
информация об этом сегменте данных имеется в разделе 3.8.3).  Для
обращения к этим элементам  компилятору  необходимо  генерировать
только  16-битовый  адрес  смещения,  поскольку он использует для
"указания" на этот сегмент регистр DS.  Однако, для  обращения  к
любым  элементам  данных  вне  умалчиваемого  сегмента  данных он
должен генерировать  полные  32-битовые  (дальние)  адреса.   Это
увеличивает  размер  и  делает  программы  менее эффективными, но
позволяет программе обращаться к большим количествам данных,  что
является обычным требованием для программ Фортрана.


     3.8.2.3 ГИГАНТСКИЕ АДРЕСА

     Еще одно осложнение может возникнуть, если  программа  имеет
очень   большие   элементы  данных.   Программа  может  содержать
отдельный  элемент  данных  (массив  или  общий  блок),   который


                               169



превышает  64K.   Обычно  компилятор вычисляет адреса элементов в
отдельном элементе данных, используя 16-битовые (ближние) адреса.
При  этом он считает, что все элементы данных лежат в одном и том
же  сегменте,  так  что  для  адресации  всех   элементов   может
использоваться  один  и  тот  же  базовый  адрес.  Если отдельный
элемент данных превышает 64K, то это предположение становится  не
верным.

     Для обращения к элементам внутри элемента данных  компилятор
должен   вычислять   адреса,   используя   32-битовую   (дальнюю)
арифметику.  В MSФортране отдельный элемент  данных,  превышающий
64K,  называется  "гигантским" элементом данных, а адрес элемента
является  "гигантским"  адресом.    Гигантский   адрес,   подобно
дальнему   адресу,   является   полным   32-битовым  адресом,  но
гигантский адрес имеет дополнительный смысл, заключающийся в том,
что  для обращения ко всем отдельным подэлементам элемента данных
требуется 32-битовые смещения.

     Только элементы данных могут иметь гигантские  адреса.   Код
для каждого модуля ограничен 64K или менее, так что он никогда не
превышает  одного  сегмента.    Гигантские   адреса   еще   менее
эффективны,  чем  дальние  адреса,  но  они  разрешают  трудности
обработки данных в программах с очень большими элементами данных.


     3.8.3 УМАЛЧИВАЕМЫЙ СЕГМЕНТ ДАННЫХ

     Даже в программах  с  несколькими  сегментами  данных  адрес
отдельного  сегмента данных может оставаться в DS в течение всего
выполнения  программы.   Этот  сегмент  называется  "умалчиваемым
сегментом  данных".   Элементы в этом сегменте могут адресоваться
ближними адресами.

     Локальные элементы данных (но не формальные  аргументы),  не
превосходящие  "порога  данных" (то есть, максимально допустимого
размера  для  отдельного  элемента  данных),  помещаются  в  этот
сегмент,  если  только  не  используется атрибут FAR или HUGE для
перемещения  элемента  за  пределы   сегмента.    (Порог   данных
устанавливается  с  помощью опции /Gt, кратко описанной в разделе
3.10.5.1).   Кроме  того,  умалчиваемый  сегмент  данных   всегда
содержит  некоторые  внутренние  данные,  независимо  от значения
порога данных.

     Каждая  программа  имеет  умалчиваемый  сегмент  данных.   В
программах  только  с одним сегментом данных умалчиваемый сегмент
данных является единственным  сегментом  данных.   Дополнительная
информация  о  содержимом  и использовании умалчиваемого сегмента
данных имеется в разделе 3.9.2.1.




                               170



     3.9 РАБОТА С МОДЕЛЯМИ ПАМЯТИ ФОРТРАНА

     В этом разделе определяются  характеристики  моделей  памяти
Фортрана  (средней,  большой  и  гигантской) и обсуждаются методы
работы с соблюдением предельных размеров для кода и  данных.   (В
разделе  3.10  дана  дополнительная  информация  о  выборе модели
памяти и ее настройке под требования программы).

     Кратко,   стандартные   модели   памяти   имеют    следующие
характеристики:

Модель        Характеристики
------        --------------
Большая       Весь  код  и  данные программы по-отдельности могут
(умолчание)   превышать   64K.   Каждый   модуль  определяет свой
              собственный   сегмент,    поэтому   каждый   модуль
              ограничен 64K. Компилятор создает столько сегментов
              кода   и   данных,   сколько   необходимо.  Однако,
              формальные    регулярные    аргументы     (массивы)
              ограничены 64K, если только аргумент не описан явно
              с помощью атрибута HUGE.

Средняя       Все  данные  программы  ограничены  64K.  Весь  код
              программы  может  превышать  64K.   Каждый   модуль
              определяет  свой  собственный  сегмент  и   поэтому
              ограничен 64K.

Гигантская    Эта  модель  имеет  такие  же характеристики, что и
              большая модель, но все формальные аргументы-массивы
              могут превышать 64К.

     Многие ограничения на размер кода и данных действуют на  все
три  модели.  Разница между большой и гигантской моделями памяти,
в  действительности,  заключается  в  том,  что  большая   модель
предполагает,  что  массивы меньше 64K, в то время как гигантская
модель  считает,  что  они  превосходят  64K.    Средняя   модель
отличается  от  большой модели только в обработке общих блоков, и
использует ближние адреса вместо дальних при передаче  аргументов
подпрограмм.

     Поскольку все три модели во  многих  отношениях  похожи,  то
последующее  обсуждение характеристик моделей памяти применимо ко
всем трем моделям, если не оговорено особо.


     3.9.1 ОПРЕДЕЛЕНИЕ МОДЕЛИ ПАМЯТИ

     Определяйте модель памяти  для  вашей  программы  с  помощью
следующих шагов:



                               171



     1.  При  выполнении  программы  SETUP  вы  можете   заказать
         построение библиотеки, которая поддерживает умалчиваемую
         (большую)  модель  памяти,  или  выбрать  другую  модель
         памяти.   В зависимости от вашего ответа SETUP выполняет
         необходимые  действия  по  внедрению  выбранной   модели
         памяти  в  создаваемую  библиотеку  времени  выполнения.
         Если вы хотите использовать  разные  модели  памяти  для
         различных программ, то создайте отдельную библиотеку для
         каждой модели памяти.

     2.  При компиляции программы с помощью команды FL вы  можете
         задать  в  командной  строке  опцию  модели памяти.  Эта
         опция разрешает  FL  связать  программу  с  библиотекой,
         которая  поддерживает  эту  модель  памяти.   Если вы не
         задаете модель памяти, то FL по  умолчанию  связывает  с
         библиотекой большой модели.

     Компилятор MSФортрана по умолчанию использует большую модель
памяти.    Большая  модель  может  размещать  программы,  которые
используют более 64K  полного  кода  и  данных.   Если  программа
использует несколько модулей, то каждый модуль может иметь до 64К
кода в одном сегменте.  Для программ, которые требуют  более  64K
данных,  компилятор  создает  столько  сегментов  данных, сколько
необходимо для программы.

     Большая модель памяти может размещать большинство  программ,
компилируемых  с  помощью  компилятора  MSФортрана.  Однако, если
программа не помещается в большой модели  памяти,  то  вы  должны
либо  перейти  на  гигантскую модель, либо использовать некоторые
методы, описанные в главе "Оптимизация  программ".   И  наоборот,
если  программа  выполняется  в  большой  модели,  то  вы  можете
попытаться улучшить ее  характеристики  и  уменьшить  ее  размер,
перейдя к средней модели памяти.

     Все  библиотеки  большой  модели  (например,   LLIBFORE.LIB,
LLIBFOR7.LIB  или LLIBFORA.LIB) работают с большой или гигантской
моделями.   Средняя  модель   требует   библиотек   MLIBFORE.LIB,
MLIBFOR7.LIB или MLIBFORA.LIB.


     3.9.2 МЕТОДЫ И ОГРАНИЧЕНИЯ ОБРАБОТКИ ДАННЫХ

     Три  модели  памяти  Фортрана  используют   разные   способы
размещения  данных,  что  приводит  к  различным  ограничениям на
размер  данных.   В  следующих  разделах   описаны   эти   методы
размещения данных и вытекающие из них ограничения.






                               172



     3.9.2.1 ОГРАНИЧЕНИЯ НА УМАЛЧИВАЕМЫЙ СЕГМЕНТ ДАННЫХ

     Хранение данных  в  умалчиваемом  сегменте  данных  улучшает
эффективность  программы.   Доступ  к  элементам  в  умалчиваемом
сегменте  данных  обычно   осуществляется   с   помощью   ближних
(16-битовых) адресов, поскольку программа требует только смещения
от адреса в регистре DS.  Однако, в большой и гигантской  моделях
для   передачи   аргументов   в   другие  процедуры  используются
32-битовые адреса, если только формальные аргументы не описаны  с
помощью атрибута NEAR.

     Умалчиваемый сегмент данных содержит следующее:

      o  Стек программы, который хранит  аргументы,  передаваемые
         подпрограммам,   и   данные,   описанные   в   операторе
         AUTOMATIC.  Стек обычно имеет размер 2K, хотя вы  можете
         его изменить.

      o  Плавающие и  символьные  константы,  включая  константы,
         сгенерированные компилятором и процедурами ввода-вывода.
         Эти константы могут отличаться по числу или значению  от
         констант, заданных в исходной программе.

      o  Данные, размещенные или используемые библиотекой времени
         выполнения,     включая     внутренние    форматы    для
         форматированного  ввода-вывода  в   программах   средней
         модели.

      o  Пространство  для  буферов  ввода-вывода  для   программ
         средней   модели   и   пространство   для  динамического
         размещения блоков управления файлами (FCB).  Всякий раз,
         когда пакет ввода-вывода связывается с программой, блоки
         FCB размещаются для терминала (консоли), для  внутренних
         файлов  и  для  любых дополнительных файлов, открываемых
         программой.

         Для   каждого   размещаемого   FCB   размещается   также
         соответствующий   буфер   ввода-вывода.    В  программах
         средней модели эти  буферы  размещаются  в  умалчиваемом
         сегменте  данных.   В  программах  большой модели буферы
         ввода-вывода  размещаются  вне  умалчиваемого   сегмента
         данных.   Если  вы  определяете  в  командной  строке FL
         переадресацию, то  компилятор  размещает  дополнительный
         блок FCB и буфер ввода-вывода.

      o  Массивы, не превосходящие порогового значения  данных  в
         большой  и  гигантской  моделях.  Пороговое значение это
         предельное  значение,  заданное  опцией   /Gt,   которое
         используется  компилятором  при  размещении данных.  Все
         массивы, превосходящие или имеющие тот же размер, что  и


                               173



         пороговое  значение,  хранятся в отдельных сегментах вне
         умалчиваемого  сегмента  данных  и  адресуются  дальними
         адресами.

      o  Информация о точках входа  и  выхода  подпрограмм,  если
         действует опция /4Yb (или метакоманда $DEBUG).

      o  Распределяемые  массивы,  если   не   доступно   никакое
         дальнее, динамически распределяемое пространство.

     В средней модели памяти умалчиваемый сегмент данных содержит
также все общие блоки, не описанные явно с помощью атрибутов HUGE
или FAR.

     Полное  пространство,  необходимое  для  перечисленных  выше
элементов,   включая   все   локальные   переменные   и  массивы,
размещаемые в умалчиваемом сегменте данных,  не  может  превышать
64K и должно оставаться в пределах умалчиваемого сегмента данных.
Если программа нарушает это ограничение, то вы можете предпринять
следующее:

      o  Переместить  некоторые  элементы   данных   за   пределы
         умалчиваемого сегмента данных с помощью атрибута FAR или
         HUGE.  Дополнительную информацию об этих атрибутах можно
         найти в разделе 3.10.2.

      o  Использовать опцию /Gt, описанную  в  разделе  3.10.5.1,
         для   перемещения  всех  элементов  данных,  превышающих
         заданный  размер,  за  пределы  умалчиваемого   сегмента
         данных.   Обратите внимание, что эта опция не работает с
         программами средней модели.

      o  Использовать опцию BLOCKSIZE в операторах OPEN  исходной
         программы  для  изменения  размера буферов ввода-вывода,
         размещаемых для открываемых  устройств.   По  умолчанию,
         каждое  устройство  размещает  буфер ввода-вывода в 1024
         байта, однако, опция BLOCKSIZE позволяет  задать  другой
         размер  буфера.   Заметьте,  что  это решение эффективно
         только в программах средней модели, поскольку эти буферы
         не  хранятся  в умалчиваемом сегменте данных в большой и
         гигантской моделях.

      o  Удалить опцию /4Yb  (или  метакоманду  $DEBUG)  из  всех
         отлаженных программ.

     Все  перечисленные  методы  помогут   уменьшить   количество
информации, хранящейся в умалчиваемом сегменте данных.  Если ваша
программа приближается к 64K, то  следование  этим  рекомендациям
может сохранить всю программу в пределах умалчиваемого сегмента.



                               174



     3.9.2.2  ОГРАНИЧЕНИЯ НА МАССИВЫ ФИКСИРОВАННОГО РАЗМЕРА,
              ПРЕВОСХОДЯЩИЕ 64K

     Массивы    фиксированного    размера,    превышающие    64K,
автоматически  размещаются  вне  умалчиваемого  сегмента данных в
стольких сегментах, сколько  необходимо.   Компилятор  генерирует
для  этих  массивов  гигантские  адреса, поскольку они пересекают
границы  сегментов.   Единственным   пределом   на   число   этих
гигантских массивов в программе является доступная память.

     Однако,  никакой отдельный скалярный объект, включая элемент
массива,  не  может  пересекать границу сегмента.  Компилятор, по
возможности, смещает начало массива в сегменте так, чтобы  такого
пересечения   не  произошло.   Это  не  может  быть  сделано  для
символьных и структурных массивов,  размер  которых  не  является
степенью  двух,  а  длина превосходит 128K.  Общие блоки также не
могут настраиваться, так как MSФортран не требует,  чтобы  разные
программные  модули  использовали одинаковые описания или порядок
переменных. Фиксируется ошибка, если описание массива или  общего
блока  пытается разместить скалярный элемент данных через границу
сегмента.

     ЗАМЕЧАНИЕ:  Массивы меньше 64K (65536 байт), но больше 65521
байт,  должны рассматриваться, как превышающие 64K, и описываться
с атрибутом HUGE (см.  раздел 3.10.2).  Даже если  такие  массивы
не  превышают  предела  64K,  они могут быть слишком большими для
сегмента, если сегмент не начинается с границы параграфа.


     3.9.2.3  ОГРАНИЧЕНИЯ НА МАССИВЫ ПЕРЕМЕННОГО РАЗМЕРА
              И ПРЕДПОЛАГАЕМОГО РАЗМЕРА

     Массивы переменного размера и предполагаемого размера  могут
появляться   в   Фортран-программе  как  формальные  аргументы  к
подпрограммам.   Размер  этих  массивов  определяется  во   время
выполнения  по  размеру  массива,  передаваемого  подпрограмме  в
качестве соответствующего фактического аргумента.

     Несмотря на то, что размер такого  массива  определяется  во
время  выполнения,  компилятор,  основываясь  на  соглашениях  об
адресации, должен во  время  компиляции  генерировать  ссылки  на
массив.   При этом компилятор считает, что, либо массив равен или
меньше 64K - в этом случае  он  может  генерировать  ближние  или
дальние  адреса,  в  зависимости  от того, где хранится массив, -
либо массив больше 64K, -  в  этом  случае  требуются  гигантские
адреса.

     В большой и средней моделях компилятор считает, что  массивы
переменного  и  предполагаемого  размеров равны или меньше 64K, и
для обращения к ним генерирует ближние или дальние адреса.   Если


                               175



во  время выполнения фактический размер массива превышает 64K, то
результаты программы будут непредсказуемы.

     Для  того,  чтобы  программа  правильно  обрабатывала  такие
массивы, превышающие 64K, у вас есть следующие возможности:

      o  При описании массива с формальным аргументом  вы  можете
         задать  атрибут HUGE.  Этот атрибут говорит компилятору,
         что фактический аргумент может (но не обязательно)  быть
         больше   64K,   и   компилятор   генерирует   для  этого
         конкретного массива гигантский адрес.

      o  Вы  можете   использовать   гигантскую   модель   памяти
         (описанную  в  разделе  3.10.1.2).   В гигантской модели
         компилятор  считает,  что  все  массивы  переменного   и
         предполагаемого  размера  больше  64K, и для обращения к
         ним  генерирует  гигантские   адреса.    Для   улучшения
         эффективности  программы  в  гигантской модели вы можете
         использовать атрибут NEAR или FAR с массивом переменного
         или предполагаемого размера, который всегда мдньше 64K.

     Обратите внимание, что оба упомянутых выше  метода  работают
во  всех  случаях,  независимо от того, превышает ли размер таких
массивов 64K.

     Формальные    аргументы-массивы    фиксированного    размера
рассматриваются как, если бы они были предполагаемого размера, за
исключением  того,  формальный   аргумент-массив   фиксированного
размера,  превышающий  64K, неявно считается как гигантский.  Все
предшествующие  замечания  о  массивах  предполагаемого   размера
справедливы  также  для  массивов фиксированного размера.  (Такая
трактовка  массивов  способствует  совместимости  с   предыдущими
версиями  Фортрана, которые не поддерживают массивы переменного и
предполагаемого  размера,  но  поддерживают  их  функционирование
благодаря игнорированию последней размерности массива).


     3.9.2.4 ОГРАНИЧЕНИЯ НА ОБЩИЕ БЛОКИ

     В большой и гигантской моделях памяти каждый  общий  блок  в
программе   размещается   вне  умалчиваемого  сегмента  данных  в
стольких  сегментах,  сколько  необходимо.    Если   общий   блок
превышает  64K, то компилятор генерирует гигантские адреса.  Если
общий блок равен или меньше 64K, то компилятор генерирует дальние
адреса.

     Некоторые ограничения действуют на переменные общего  блока,
превышающего  64K.   Отдельный  элемент  массива или переменная в
общем  блоке  могут  пересекать  границу  сегмента.    Компилятор
размещает  общие  блоки  так, что они всегда начинаются с границы


                               176



сегмента.  Это ограничение означает, что  граница  между  байтами
65536  и  65537  общего  блока  должна  располагаться между двумя
переменными или между двумя элементами массива.

     Если массив в общем  блоке  пересекает  границу  сегмента  и
передается   как   фактический   аргумент,   то   соответствующий
формальный аргумент должен быть описан с атрибутом HUGE.

     Если  вы  в  своей   программе   имеете   небольшие,   часто
используемые общие блоки, то можете извлечь выгоду, описывая их с
атрибутом NEAR.  Этот атрибут  заставляет  компилятор  разместить
общий блок в умалчиваемом сегменте данных, в котором к нему можно
обращаться с помощью более эффективных ближних адресов.   Но  это
имеет  смысл  только  в  том  случае,  если  у  вас  есть место в
умалчиваемом сегменте данных.

     В качестве альтернативы, если вы имеете место в умалчиваемом
сегменте  данных,  то  можете использовать среднюю модель памяти.
Средняя модель памяти размещает все общие  блоки  в  умалчиваемом
сегменте данных, за исключением следующего:

      o  Непомеченные общие блоки,  явно  описанные  с  атрибутом
         FAR.

      o  Поименованные общие блоки, превышающие 64K.


     3.9.2.5 ОГРАНИЧЕНИЯ НА АРГУМЕНТЫ, ПЕРЕДАВАЕМЫЕ ПОДПРОГРАММАМ

     Аргументы в Фортране  обычно  передаются  по  ссылке.   Если
вызывается подпрограмма, то компилятор помещает адреса аргументов
в стек программы.  Такой метод  передачи  аргументов  накладывает
некоторые ограничения на различные модели памяти:

      o  В большой и гигантской моделях компилятор  для  передачи
         аргументов подпрограммам использует дальние (32-битовые)
         адреса, даже если  аргументы  находятся  в  умалчиваемом
         сегменте данных.

      o  В  средней  модели  памяти   компилятор   для   передачи
         аргументов   подпрограммам  использует  ближние  адреса,
         исходя  из  предположения,  что  все  данные   программы
         располагаются в умалчиваемом сегменте данных.

     Следующие  методы  могут  помочь  вам  обойти  эти  стековые
ограничения:

      o  В  большой  и  гигантской   моделях,   если   формальные
         аргументы  описаны  в  операторе  INTERFACE  с атрибутом
         NEAR, то компилятор для передачи фактического  аргумента


                               177



         подпрограмме   использует  ближний  (16-битовый)  адрес.
         Поскольку ближние адреса более эффективны, чем  дальние,
         то  это улучшит характеристики программы.  Тем не менее,
         все  фактические  параметры,   передаваемые   формальным
         аргументам  с  атрибутом  NEAR,  должны  располагаться в
         умалчиваемом сегменте  данных,  иначе  могут  возникнуть
         непредсказуемые результаты.

      o  В  средней  модели  памяти,  если  вы  хотите   передать
         аргумент,  который  находится вне умалчиваемого сегмента
         данных (например, массив, описанный с атрибутом FAR, или
         любой  массив  фиксированного размера, превышающий 64K),
         то должны описать соответствующий формальный аргумент  с
         атрибутом FAR или HUGE.

      o  В MSФортране вы можете  также  передавать  аргументы  по
         значению.   Если  вы  описываете  аргумент  с  атрибутом
         VALUE,  то  тем  самым  определяете,   что   он   должен
         передаваться  по  значению,  а  не  по  ссылке.   Вместо
         размещения в стеке адреса аргумента, компилятор помещает
         в стек значение аргумента.

      o  Стек  обычно  является  частью  умалчиваемого   сегмента
         данных.   По  умолчанию  стек  занимает 2K, но вы можете
         изменить его размер с помощью опции /F в команде  FL,  с
         помощью  опции  /STACK  в  команде  LINK,  или  утилитой
         EXEMOD.   При  передаче  подпрограммам   аргументов   по
         значению,  убедитесь, что полный размер, необходимый для
         аргументов, не превышает доступного пространства  стека.
         Передача   по  значению  целых  массивов  может  вызвать
         проблемы.   Поскольку  массивы  могут  превышать  размер
         стека,  то передача массива по значению может привести к
         переполнению стека с непредсказуемыми результатами.


     3.9.2.6 СВОДКА РАЗМЕЩЕНИЯ ДАННЫХ

     В таблице 3.4 кратко изложены способы  размещения  данных  в
большой  модели  памяти.   Различия  между  большой, гигантской и
средней моделями даны в сносках к таблице.












                               178



Таблица 3.4  Размещение данных в больших моделях памяти
-----------------------------------------------------------------
Тип данных         Хранение          Тип адреса     Ограничения
-----------------------------------------------------------------
Локальные пере-    Умалчиваемый      Ближний (2)    Общий размер
менные и массивы   сегмент                          всех перемен-
фиксированного     данных                           ных и масси-
размера, не пре-                                    вов плюс стек
вышающие предела                                    и другие дан-
данных (1)                                          ные в умал-
                                                    чиваемом сег-
                                                    менте не
                                                    может превы-
                                                    шать 64K.

Массивы, не пре-   Отдельные сег-    Дальний        Доступная
вышающие 64K, но   менты вне умал-                  память
больше предела     чиваемого сег-
данных (1)         мента данных

Массивы, превы-    Столько сегмен-   Гигантский     Доступная
шающие 64К         тов, сколько                     память
                   необходимо, вне
                   умалчиваемого
                   сегмента данных

Общие блоки (3)    Столько сегмен-   Дальний, если  Доступная
                   тов, сколько      общий блок     память
                   необходимо, вне   равен 64K или
                   умалчиваемого     меньше; иначе
                   сегмента данных   гигантский
-----------------------------------------------------------------
(1) Предел  данных (пороговое значение) равен 32767 байт, если не
    задана  опция  /Gt,  или  256  байт,  если опция /Gt задана с
    пороговым значением.
(2) В  большой  и  гигантской  моделях  для  передачи фактических
    аргументов  подпрограммам  используются  дальние  адреса  (за
    исключением  формальных  аргументов,  описанных  с  атрибутом
    NEAR).  В  средних  моделях  используются  ближние адреса (за
    исключением  формальных  аргументов,  описанных  с атрибутами
    FAR или HUGE).
(3) В  средних  моделях  непомеченные  общие  блоки размещаются в
    умалчиваемом  сегменте  данных  и  ограничены  64K или меньше
    (если  специально  не  описаны  с  атрибутом  FAR  или HUGE).
    Поименованные   общие  блоки  размещаются  вне  умалчиваемого
    сегмента данных, если они больше 64K.

     Кроме   того,   для   большой   модели   памяти   компилятор
предполагает,  что  все  формальные  аргументы-массивы меньше или
равны 64K, если они специально не описаны с атрибутом HUGE.   Это


                               179



справедливо  также  для  средней  модели.   В  гигантской  модели
компилятор предполагает, что масивы переменного и предполагаемого
размеров  больше  64K, если они специально не описаны с атрибутом
NEAR или FAR.


     3.9.3 ОГРАНИЧЕНИЯ НА РАЗМЕР КОДА

     Компилятор MSФортрана помещает код из каждого модуля в  свой
собственный  сегмент.   Поскольку  максимальный размер кода равен
64K, то откомпилированный код в каждом модуле не может  превышать
64K.  Вы можете определить, как много кода содержит каждый модуль
программы, посмотрев листинг исходного файла или карты-файла.

     В следующих разделах описаны методы уменьшения размера  кода
программы и повышения ее эффективности.  (Описание других методов
имеется в главе "Оптимизация программ").


     3.9.3.1  СОЗДАНИЕ ПРОГРАММ, ПРЕВЫШАЮЩИХ 64K

     Если модуль превышает предельный  размер  кода  64K,  то  вы
должны  уменьшить  его  размер,  разбив на два или более исходных
файлов.   Эффективным  способом   является   разбиение   исходной
программы  на  секции  по  их  функциональности  и  их раздельная
компиляция.  Раздельная работа с секциями не влияет  на  конечный
размер  программы  (хотя  может увеличить полный размер объектных
файлов), но изменяет число используемых сегментов памяти.   Кроме
того,  фокусировка  каждой  части на конкретном аспекте программы
делает исходный код более легким для понимания и сопровождения.

     И наоборот, вы можете  объединить  код  из  двух  или  более
модулей  в один сегмент, используя опцию /NT (описанную в разделе
3.10.5.2).  Модули  с  идентичными  именами  текстовых  сегментов
загружаются  в  один  и тот же сегмент, при условии, что их общая
длина не превышает предела сегмента в 64К.


     3.9.3.2  ПОВЫШЕНИЕ ЭФФЕКТИВНОСТИ С ПОМОЩЬЮ АТРИБУТА NEAR

     Для ссылок  на  код  программы  Фортран  использует  дальние
(32-битовые)  адреса,  поскольку  ссылка  должна обеспечивать как
адрес сегмента, так и смещение  элемента  кода  внутри  сегмента.
Если    программа    очень    интенсивно   использует   некоторые
подпрограммы, то  вы  можете  улучшить  эффективность  программы,
используя атрибут NEAR.

     При использовании с подпрограммой атрибут  NEAR  определяет,
что  код  подпрограммы  размещается  в  том  же  сегменте,  что и
вызывающая  процедура.    Поскольку   адрес   сегмента   остается


                               180



постоянным,   то   компилятор   для   вызова  подпрограммы  может
генерировать ближний (16-битовый) адрес.

     Для того, чтобы использовать атрибут NEAR  с  подпрограммой,
вы должны убедиться, что подпрограмма действительно оказывается в
соответствующем  сегменте.   Вы  можете  сделать  это,   поместив
подпрограмму  в  один  исходный  файл  с  вызывающей  процедурой,
обеспечив тем самым компиляцию в один модуль.

     Если вы хотите  поместить  процедуры  в  отдельные  исходные
файлы,  то  можете  использовать  опцию  /NT,  чтобы задать имена
текстовых сегментов для обоих  модулей.   Если  вы  дадите  обоим
одинаковое имя текстового сегмента, то они будут загружены в один
и тот же сегмент.


     3.10 ВЫБОР И НАСТРОЙКА МОДЕЛИ ПАМЯТИ

     В этом разделе описаны методы  выбора  и  настройки  моделей
памяти.   Вы  можете  выбрать  одну  из  трех стандартных моделей
памяти Фортрана, задав в командной строке FL одну  из  опций  /A;
эти опции описаны ниже в разделе 3.10.1.

     Если вы используете стандартные модели памяти, то команда FL
выполняет  необходимую  библиотечную поддержку.  FL автоматически
связывает с библиотекой, соответствующей модели памяти,  заданной
в   командной  строке,  при  условии,  что  вы  уже  создали  эту
библиотеку во время выполнения программы SETUP.  Если не  указано
иначе, то FL использует для связывания библиотеку большой модели;
это является умолчанием и для библиотеки, создаваемой  программой
SETUP,  если  вы  во  время  установки  не выбрали модель памяти.
Большая и гигантская модели используют одну и ту  же  библиотеку;
средняя модель использует свою собственную библиотеку.

     Преимуществом   использования   стандартных   моделей    для
программы  является простота.  Для стандартных моделей управление
памятью   определяется   опциями   компилятора   и   не   требует
использования  расширенных  ключевых  слов.   Это  важно, если вы
планируете переносить свою программу в другие системы,  особенно,
в  системы,  которые  не используют сегментированную архитектуру.
Обратите внимание, что пороговая опция  (/Gt),  опция  именования
текстового  сегмента  (/NT)  и  опция  именования сегмента данных
(/ND) также являются мобильными способами управления размещением.

     Недостатком   использования   стандартных   моделей   памяти
является  только  то,  что  они не создают самый эффективный код.
Например,  если  вы  имеете  программу  большой  модели  с  одним
массивом предполагаемого размера, который может превышать 64K, то
будет выгодно описать  один  большой  массив  с  атрибутом  HUGE.
Переключение на гигантскую модель заставит компилятор считать все


                               181



массивы переменного и предполагаемого размера гигантскими.

     В  разделах  3.10.1  -  3.10.3  описаны  способы   изменения
размещения  для  одного  или  более  элементов без изменения всей
модели памяти.  Методы,  описанные  в  этих  разделах,  дают  вам
больший  контроль  над  структурой  и характеристиками программы.
Однако,  для  понимания   результатов   использования   опций   и
атрибутов,   описанных   в   этих   разделах,   и   надежного  их
использования вам необходимо основательное знакомство с  моделями
памяти Фортрана и архитектурой 8086.


     3.10.1 ИСПОЛЬЗОВАНИЕ СТАНДАРТНЫХ МОДЕЛЕЙ ПАМЯТИ

     Опция /AL, /AH или /AM выбирает модель  памяти.   Вы  можете
использовать  в  командной  строке  FL  только  одну опцию модели
памяти.  Опция действует на все исходные файлы в командной строке
и не влияет на заданные в ней объектные файлы.

Опции     Выбираемая модель
-----     -----------------
/AL       Большая модель (умолчание; соответствует умалчиваемой
          библиотеке, генерируемой SETUP)

/AH       Гигантская модель

/AM       Средняя модель

     Если вы компилируете отдельные исходные  файлы  программы  в
разное  время,  то  должны  задавать для всех одну и ту же модель
памяти.

     Следующее обсуждение предполагает стандартные соглашения  об
именах  библиотек  DOS.   Если  вы используете двухрежимные опции
командной строки  OS/2  -  /Lp,  /Lr  или  /Lc,  -  то  действуют
соглашения об именах, соответствующие OS/2.


     3.10.1.1 БОЛЬШАЯ МОДЕЛЬ (/AL)

     Опция  /AL  предписывает  компилятору  использовать  большую
модель  памяти.   Большая  модель памяти является умолчанием, так
что вам не нужно явно задавать эту опцию.  Опция  большой  модели
разрешает   компилятору   создавать  столько  сегментов,  сколько
необходимо для кода и данных.

     Умолчанием для программ  большой  модели  является  то,  что
доступ к элементам кода и данных осуществляется с помощью дальних
адресов.  Вы можете изменить умолчание с помощью  атрибутов  NEAR
или HUGE для данных и атрибута NEAR для кода.


                               182



     Опция  /AL  приводит  к  тому,  что  в  каждый   создаваемый
объектный  файл  помещается  имя  стандартной  библиотеки большой
модели Фортрана - LLIBFORE.LIB, LLIBFOR7.LIB или LLIBFORA.LIB,  в
зависимости  от  опции  /FP, заданной в командной строке FL.  Это
позволяет   линкеру    автоматически    использовать    требуемую
библиотеку,  при  условии,  что  библиотека  существует (то есть,
построена с помощью SETUP).


     3.10.1.2 ГИГАНТСКАЯ МОДЕЛЬ (/AH)

     Опция /AH предписывает компилятору  использовать  гигантскую
модель памяти.

     Гигантская  модель  отличается  от  большой  модели   только
трактовкой  массивов  переменного  и предполагаемого размеров.  В
гигантской модели компилятор считает, что  такие  массивы  больше
64K и для обращения к ним генерирует гигантские адреса; в больших
моделях компилятор предполагает, что такие  массивы  меньше  64K,
если только они явно не описаны с атрибутом HUGE.

     Эти  гигантские  адреса  делают  гигантские   модели   менее
эффективными,  чем  большие  модели.   Однако,  гигантская модель
полезна,  если  вы  хотите,  чтобы  все  или  почти  все  массивы
переменной   и  предполагаемой  длины  в  программе  обрабатывали
массивы, превышающие 64K.

     При использовании гигантской модели вы  можете  использовать
атрибут  NEAR  или  FAR для любого формального аргумента-массива,
фактический размер которого  всегда  меньше  64K.   Этот  атрибут
предписывает  компилятору  генерировать  для  массива ближние или
дальние адреса, которые более эффективны, чем гигантские адреса.

     В  качестве  альтернативы  гигантской   модели   вы   можете
использовать  большую  модель и применять атрибут HUGE для любого
массива  переменного  или  предполагаемого  размера,  фактический
размер которого превышает 64K.

     Для большой и гигантской моделей используется одна и  та  же
библиотека,  так  что  опция  /AH  помещает  в каждый создаваемый
объектный файл  имя  соответствующей  библиотеки  большой  модели
Фортрана (то есть, LLIBFORE.LIB, LLIBFOR7.LIB или LLIBFORA.LIB).


     3.10.1.3 СРЕДНЯЯ МОДЕЛЬ (/AM)

     Опция  /AM  предписывает  компилятору  использовать  среднюю
модель памяти.

     Средняя  модель  отличается  от  большой   модели   в   двух


                               183



отношениях:   по  разному  размещаются  общие  блоки и по разному
передаются аргументы подпрограммам.

     В  средних  моделях  непомеченные  общие  блоки,   явно   не
описанные  с атрибутом FAR или HUGE, и поименованные общие блоки,
не превышающие 64K, помещаются  в  умалчиваемый  сегмент  данных.
Этот  метод размещения позволяет компилятору генерировать ближние
адреса  для  обращения  к  этим  общим  блокам.   В   результате,
программы  средней  модели обычно более эффективны с точки зрения
скорости и  пространства,  чем  программы  большой  и  гигантской
моделей.    Общие   блоки,   превышающие   64K,  размещаются  вне
умалчиваемого сегмента данных и должны  адресоваться  гигантскими
адресами.

     Соглашение о передаче  аргументов,  используемое  в  средней
модели,  также  меньше  и  быстрее,  чем  в  большой и гигантской
моделях.   В  средней  модели  компилятор  передает   фактические
аргументы подпрограммам, используя ближние адреса (вместо дальних
адресов,  испльзуемых  в  большой  и  гигантской  моделях).   Это
возможно,  поскольку  компилятор  предполагает,  что  все  данные
располагаются в умалчиваемом сегменте данных.  Если вы в  средней
модели    хотите   передать   в   подпрограмму   аргумент   извне
умалчиваемого сегмента данных, то должны описать  соответствующий
формальный аргумент в подпрограмме с атрибутом FAR или HUGE.

     Даже если вы не можете использовать для подпрограммы среднюю
модель,  вы можете заставить компилятор использовать для передачи
аргументов более эффективные ближние адреса, описывая  формальные
аргументы  с атрибутом NEAR.  Однако, вы должны быть уверены, что
фактические   аргументы,    передаваемые    ближним    формальным
аргументам, располагаются в умалчиваемом сегменте данных.

     ЗАМЕЧАНИЕ:  В средней модели не  разрешается  ввод  и  вывод
дальних  и гигантских элементов.  Тем не менее, для выполнения их
ввода-вывода вы  можете  копировать  эти  элементы  во  временную
область памяти в умалчиваемом сегменте данных.

     Размер умалчиваемого сегмента данных не может превышать  64K
и   содержит,   кроме  общих  блоков,  стек  и  переменные.   Это
ограничивает сверху практический размер общих блоков  пределом  в
64K.

     На практике только немногие программы Фортрана встречаются с
этим  ограничением.   Тем не менее, вы все же можете использовать
среднюю  модель,  задавая  в  программе  атрибуты  FAR  и   HUGE.
Например,  если  программа содержит большие, нечасто используемые
общие блоки, то вы можете использовать атрибут FAR или  HUGE  для
перемещения этих блоков за пределы умалчиваемого сегмента данных.
Меньшие по размерам  общие  блоки,  к  которым  обращаются  более
часто, могут оставаться в умалчиваемом сегменте данных.


                               184



     Вы  можете  использовать  атрибуты  FAR  или  HUGE   и   для
перемещения  за  пределы  умалчиваемого  сегмента  данных  других
больших элементов данных,  например,  массивы.   Это  увеличивает
пространство для общих блоков в сегменте.

     В качестве альтернативы использованию средней модели  памяти
вы можете использовать атрибут NEAR с конкретными общими блоками,
чтобы поместить их в умалчиваемый сегмент  данных.   Это  улучшит
эффективность программы, если вы имеете один или более небольших,
интенсивно используемых, общих блоков.

     Имя   соответствующей   библиотеки    средней    модели    -
MLIBFORE.LIB,  MLIBFOR7.LIB  или  MLIBFORA.LIB,  в зависимости от
опции /FP, заданной в командной строке FL, - помещается в  каждый
создаваемый   объектный   файл,   при   условии,  что  библиотека
существует (то есть, построена при выполнении SETUP).


     3.10.2 АТРИБУТЫ NEAR, FAR И HUGE

     Атрибуты NEAR, FAR и HUGE это ключевые слова, используемые в
Фортран-программе   для   замещения   соглашений   об  адресации,
действующих по умолчанию.  В этом разделе описано  действие  этих
атрибутов  на  элементы  кода  и  данных  в  трех  моделях памяти
Фортрана.

     Атрибуты NEAR, FAR и HUGE дают больше  гибкости,  чем  выбор
одной   из  стандартных  моделей  памяти.   Например,  вы  можете
избежать перехода от большой к  гигантской  модели  памяти,  если
используете   атрибут   HUGE  для  всех  массивов  переменного  и
предполагаемого размера, которые могут превышать 64K.   С  другой
стороны, даже если программа требует гигантской модели, вы можете
улучшить  ее  эффективность,   идентифицируя   маленькие,   часто
используемые  элементы, которые могли бы подходить для размещения
в умалчиваемом сегменте данных.

     Атрибут FAR полезен также для программ, которые имеют больше
данных,  чем может находиться в умалчиваемом сегменте данных.  Вы
можете описать менее часто используемые элементы с атрибутом FAR,
чтобы  переместить  их  за пределы умалчиваемого сегмента данных,
оставляя  место  для  более  интенсивно  используемых  элементов.
Кроме того, вы можете использовать опцию /Gt, описанную в разделе
3.10.5.1, для перемещения некоторых элементов данных  за  пределы
умалчиваемого сегмента данных.

     Однако, имейте  в  виду,  что  атрибуты  NEAR,  FAR  и  HUGE
являются  расширениями для языка Фортран.  Они имеют смысл только
для процессоров с сегментированной архитектурой, таких как  8086.
Если  переносимый  код  имеет высокую мобильность, не используйте
эти атрибуты.  Опции стандартных моделей памяти, вместе с  опцией


                               185



/Gt,  позволяют  мобильно  менять  модель  памяти,  поскольку они
задаются во время компиляции и не влияют на исходный код.

     Обсуждение моделей памяти в предшествующих разделах содержит
методы использования атрибутов NEAR, FAR и HUGE с каждой моделью.
Таблицы 3.5 и 3.6 суммируют действие каждого атрибута на элементы
в каждой из трех стандартных моделей памяти.

Таблица 3.5  Действие атрибута NEAR
-----------------------------------------------------------------
             Большая            Гигантская        Средняя
Элемент      модель памяти      модель памяти     модель памяти
-----------------------------------------------------------------
Переменные   Не действует для   То же, что для    Не действует
и массивы    элементов меньше   большой модели
фиксиро-     порогового зна-
ванной       чения. Массивы
длины        больше порогово-
             го значения, но
             меньшие 64K, по-
             мещаются в умал-
             чиваемый сегмент
             данных. (1)

Формальные   Фактические ар-    То же, что для    Не действует
аргументы    гументы переда-    большой модели
             ются по ближним
             адресам и должны
             быть в умалчива-
             емом сегменте
             данных.

Общие        Помещаются в       То же, что для    Не действует
блоки        умалчиваемый       большой модели
             сегмент данных;
             ближние адреса.

Подпрог-     Ближние вызовы     Ближние вызовы    Ближние вызовы
раммы

Массивы      Фактические ар-    То же, что для    Не действует
перемен-     гументы переда-    большой модели
ного и       ются по ближним
предпола-    адресам и должны
гаемого      быть в умалчи-
размера      ваемом сегменте
             данных.
-----------------------------------------------------------------
(1) Умалчиваемое пороговое значение равно 32767 байт, если опция
    /Gt не задана, или 256 байт, если опция /Gt задана без


                               186



    порогового значения.

Таблица 3.6  Действие атрибутов FAR и HUGE
-----------------------------------------------------------------
             Большая            Гигантская        Средняя
Элемент      модель памяти      модель памяти     модель памяти
-----------------------------------------------------------------
Переменные   Если переменная    То же, что для    То же, что для
и массивы    или массив меньше  большой модели    большой модели
фиксирован-  64K, то они пере-
ной длины    мещаются за пре-
             делы умалчиваемо-
             го сегмента дан-
             ных и адресуются
             дальними адресами.
             Если массив больше
             64K, то атрибут
             FAR или HUGE не
             действует и гене-
             рируются гигант-
             ские адреса.

Формальные   FAR не действует.  Если использу-    Фактические ар-
аргументы    Если HUGE приме-   ется FAR, то ге-  гументы переда-
             няется для масси-  нерируются даль-  ются по дальним
             ва, то генериру-   ние адреса, а не  или гигантским
             ются гигантские    гигантские. HUGE  адресам.
             адреса.            не действует.

Общие        Не действует       Не действует      Общие блоки пе-
блоки                                             ремещаются за
                                                  пределы умалчи-
                                                  ваемого сегмен-
                                                  та данных. Ге-
                                                  нерируются даль-
                                                  ние адреса, ес-
                                                  ли блок равен
                                                  или меньше 64K,
                                                  иначе генери-
                                                  руются гигант-
                                                  ские адреса.

Подпро-      Не действует       Не действует      Не действует
граммы (1)
-----------------------------------------------------------------







                               187



Таблица 3.6  Действие атрибутов FAR и HUGE
-----------------------------------------------------------------
             Большая            Гигантская        Средняя
Элемент      модель памяти      модель памяти     модель памяти
-----------------------------------------------------------------
Массивы      FAR не действует.  Если использует-  То же, что для
переменного  Генерируются ги-   ся FAR, то гене-  большой модели
и предпола-  гантские адреса    рируются дальние
гаемого      с атрибутом HUGE.  адреса, а не ги-
размера и                       гантские. HUGE
динамичес-                      не действует.
кие массивы
-----------------------------------------------------------------
(1) Атрибут HUGE не может применяться к подпрограммам.


     3.10.3 МЕТАКОМАНДЫ $LARGE И $NOTLARGE

     Метакоманды $LARGE и $NOTLARGE связаны  с  атрибутами  NEAR,
FAR и HUGE, хотя их смысл немного отличается.  Использование этих
метакоманд больше не рекомендуется; используйте атрибуты.

     ЗАМЕЧАНИЕ:   Термин  "большой"  (large)  может  привести   к
путанице,  поскольку  он используется как для метакоманды $LARGE,
так и для большой модели памяти.  Метакоманда $LARGE не связана с
большой моделью памяти; размер, определяемый метакомандой $LARGE,
соответствует гигантской модели памяти (для формальных аргументов
подпрограмм)  или  атрибуту  HUGE  (для  массивов  фиксированного
размера).   Метакоманды  $LARGE   и   $NOTLARGE   оставлены   для
совместимости с предыдущими версиями Фортрана.

     Массивы  фиксированного  размера,   описанные   метакомандой
$LARGE,  обрабатываются  точно  так  же, как массивы, описанные с
атрибутом HUGE:  массивы помещаются  вне  умалчиваемого  сегмента
данных  и  доступ к ним должен выполняться по дальним адресам для
массивов 64K или меньше, или по гигантским адресам для  массивов,
превышающих  64K.   В  гигантской модели памяти доступ к массивам
фиксированного размера может выполняться по ближним адресам, если
они  меньше  сегмента  и меньше заданного порогового значения.  В
средней и большой моделях памяти  описание  массива  метакомандой
$NOTLARGE  (явно  или  по  умолчанию)  не  влияет  на  размещение
массива.   Это  справедливо  также  для  массивов  фиксированного
размера в гигантской модели.


     3.10.4  ИСПОЛЬЗОВАНИЕ БИБЛИОТЕЧНЫХ ПРОЦЕДУР С
             РАЗЛИЧНЫМИ МОДЕЛЯМИ ПАМЯТИ

     Стандартные  библиотеки,  построенные  SETUP,  соответствуют
трем    моделям   памяти.    Библиотеки   накладывают   следующие


                               188



ограничения на программы Фортрана:

      o  Массивы, содержащие спецификаторы формата, не могут быть
         описаны  с  атрибутом  HUGE, заданы в метакоманде $LARGE
         или занимать более  чем  один  сегмент  в  любой  модели
         памяти.

      o  Гигантские   массивы   не   могут   использоваться   как
         внутренние файлы в любой модели памяти.

      o  В программах средней модели все элементы, вовлекаемые  в
         операции  ввода-вывода,  должны  быть  близкими, включая
         элементы в списках ввода-вывода, спецификации формата  и
         внутренние файлы.

      o  В  программах  средней  модели   дальние   спецификаторы
         формата являются недействительными.


     3.10.5 ОПЦИИ КОМПИЛЯТОРА, ВЛИЯЮЩИЕ НА ИСПОЛЬЗОВАНИЕ ПАМЯТИ

     Некоторые опции командной строки FL  -  /Gt,  /NT  и  /ND  -
предписывают   компилятору   изменить   способ,  по  которому  он
распределяет память.  Ниже они кратко обсуждаются.


     3.10.5.1 ОПЦИЯ ПОРОГОВОГО ЗНАЧЕНИЯ ДЛЯ ДАННЫХ (/Gt)

     Опция  /Gt  устанавливает  пороговое  значение  для  данных.
"Пороговое   значение"   (или   граница  данных)  это  отсекающее
значение, которое компилятор использует при размещении данных.  В
большой  и  гигантской  моделях  каждый  массив  или  переменная,
превышающие или равные по  размеру  пороговому  значению,  но  не
превосходящие   64K,   хранятся   в  новом  сегменте  данных  вне
умалчиваемого сегмента данных и обращение к  ним  выполняется  по
дальним адресам.

     Уменьшение  порогового  значения  полезно,  если  вы  хотите
переместить  данные  за пределы умалчиваемого сегмента данных без
описания их с атрибутом FAR.  Увеличение порогового значения дает
возможность  хранить  массивы  длиннее  32767  байт (умалчиваемое
значение) в умалчиваемом сегменте данных, при условии, что в  нем
есть  место.   Вы  можете  также  выполнять  это,  описывая такие
массивы с атрибутом NEAR.


     3.10.5.2 ОПЦИЯ ИМЕНОВАНИЯ СЕГМЕНТОВ (/NT)

     Опция /NT позволяет вам замещать умалчиваемые соглашения  об
именовании,  используемые  компилятором  Фортрана,  и давать свое


                               189



собственное имя текстовым сегментам.

     "Текст"  это  просто  другой  термин  для  "кода",   поэтому
текстовый сегмент это сегмент кода.  Сегменты с одинаковым именем
загружаются  в  один  и  тот  же  физический  сегмент  в  памяти.
Например,  вы  можете  использовать  опцию /NT и дать двум разным
модулям одинаковое имя текстового сегмента,  что  гарантирует  их
загрузку  в  один  сегмент в памяти.  Это полезно, если вы хотите
использовать атрибут NEAR с подпрограммой.

     Во всех трех моделях памяти Фортрана компилятор помещает код
из  каждого  модуля  в отдельный сегмент со своим именем, которое
образуется из основного имени модуля вместе с окончанием "_TEXT".
Дополнительная  информация об ограничениях на размер кода имеется
в разделе 3.9.3 "Ограничения на размер кода".


     3.10.5.3 ОПЦИЯ ИМЕНОВАНИЯ ДАННЫХ (/ND)

     Опция /ND позволяет вам замещать умалчиваемые соглашения  об
именовании,  используемые  компилятором  Фортрана,  и задать свое
собственное имя для сегмента данных.  Умалчиваемый сегмент данных
называется  "_DATA".   Компилятор  помещает  данные, хранимые вне
умалчиваемого сегмента данных, в отдельные сегменты с уникальными
именами.    Элементами   данных  являются:   гигантские  массивы;
массивы, превышающие пороговое значение;  элементы,  описанные  с
атрибутом  FAR  или  HUGE;  и  общие блоки в большой и гигантской
моделях.

     Опция /ND помещает данные  из  модуля  в  сегмент  данных  с
уникальным  именем.   Когда  выполнение переходит к этому модулю,
компилятор загружает в  регистр  DS  базовый  адрес  именованного
сегмента  данных;  когда  выполнение оставляет модуль, компилятор
восстанавливает в DS  предыдущее  значение  (обычно  DGROUP).   В
результате,  во  время выполнения в этом модуле, компилятор может
использовать ближние адреса для обращения к данным, находящимся в
именованном   сегменте.    Этот   метод,  в  частности,  улучшает
характеристики процедур, которые часто обращаются к данным.














                               190
