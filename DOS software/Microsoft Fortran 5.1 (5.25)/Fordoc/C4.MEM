






                               ГЛАВА 4

                    РАЗНОЯЗЫКОВОЕ ПРОГРАММИРОВАНИЕ

     Microsoft Фортран поддерживает вызов процедур, написанных на
Microsoft  Си  и  Паскале.   Кроме  того,  если главная программа
написана на Microsoft QuickBASIC 4.0 или выше (или на компиляторе
Microsoft  BASIC  6.0  или  выше),  то  процедура  Фортрана может
вызывать  процедуру  Бейсика.   В  этой  главе  описаны  элементы
разноязыкового  программирования:   как  языки  различаются и как
преодолеть эти различия.

     Если  вы  понимаете  основные  принципы  выполнения   вызова
разноязыковых  процедур,  то  можете  сразу  перейти к детальному
обсуждению синтаксиса в разделах 4.2  -  4.4.   В  этих  разделах
описаны способы вызова из Фортрана процедур, написанных на других
языках высокого уровня и на языке ассемблера.


     4.1 ВЫПОЛНЕНИЕ ВЫЗОВА РАЗНОЯЗЫКОВЫХ ПРОЦЕДУР

     Разноязыковое   программирование   всегда   включает   вызов
функции,  процедуры или подпрограммы.  Например, основному модулю
Фортрана  может  понадобиться   выполнение   конкретной   задачи,
запрограммированной  на  другом  языке.   Вместо  написания новой
процедуры  на  Фортране   вы   можете   предпочесть   вызов   уже
существующей функции, написанной, скажем, на Си.

     Вызов   разноязыковых   процедур,   написанных   на   языках
Microsoft,   неизбежно   включает   несколько   модулей.   Вместо
компиляции всех ваших  исходных  модулей  одним  компилятором  вы
используете  разные  компиляторы.   В  упомянутом  выше случае вы
можете скомпилировать исходный файл с главным модулем  с  помощью
компилятора Фортрана, второй исходный файл (написанный на Си) - с
помощью компилятора Си,  а  затем  связать  оба  объектных  файла
вместе.

     Рисунок 4.1 на упомянутом  выше  примере  иллюстрирует,  как
работает синтаксис вызова разноязыковых процедур.









                               191



              Программа на Фортране        Программа на Си
            +------------------------+   +----------------------+
            | INTERFACE TO SUBROUTINE|   |                      |
         +--|   PRN [C]()            |   |                      |
Влияет   |  | END                    |   |                      |
на вы-   |  | .                 +------->| void prn (){         |
полнение |  | .                 |    |   | .                    |
вызова   |  | .                 |    |   | .                    |
         +->| CALL Prn() -------+    |   | .                    |
            | .          <---------------| }                    |
            | .                      |   |                      |
            | .                      |   |                      |
            | END                    |   |                      |
            +------------------------+   +----------------------+

Рисунок 4.1  Разноязыковый вызов

     На этом рисунке видно, что вызов Си из Фортрана - CALL Prn()
-  похож  на  вызов  подпрограммы  Фортрана.  Однако, имеется два
различия  между  разноязыковым  вызовом  и  вызовом  между  двумя
модулями Фортрана:

      o  Подпрограмма Prn в действительности реализована на Си  с
         использованием стандартного синтаксиса Си.

      o  Фортран  должен  использовать  оператор  INTERFACE   для
         создания   совместимости   с   Си.   Оператор  INTERFACE
         является примером  оператора  разноязыкового  интерфейса
         (это   оператор   интерфейса   Фортрана).   Каждый  язык
         обладает своей собственной формой интерфейса.

     Несмотря  на  синтаксические  различия,  все   функции   Си,
процедуры  Паскаля,  Бейсика,  макроассемблера  Microsoft  MASM и
подпрограммы Фортрана являются похожими.  Принципиальным отличием
является  то,  что некоторые виды процедур возвращают значение, а
другие не возвращают.  Вы можете чередовать  оба  типа  процедур.
Отметьте, что в этой главе термин "процедура" (routine) относится
к любой функции, процедуре или подпрограмме, которая  может  быть
вызвана из другого модуля.

     Ниже в таблице  4.1  показано  соответствие  между  вызовами
процедур в различных языках.










                               192



Таблица 4.1  Языковые эквиваленты для вызовов процедур
-----------------------------------------------------------------
                    Возвращаемое          Без возвращаемого
Язык                значение              значения
-----------------------------------------------------------------
FORTRAN             Функция               Подпрограмма
C                   Функция               (Void)функция
Pascal              Функция               Процедура
BASIC               Процедура-функция     Подпрограмма
Macro Assembler     Процедура             Процедура
-----------------------------------------------------------------

     Например,  модуль   Бейсика   может   вызвать   подпрограмму
Фортрана.   Для  того,  чтобы  вызвать  функцию Фортрана, Бейсику
нужно осуществить вызов FUNCTION, иначе вызов будет выполнен,  но
возвращаемое  значение  будет утеряно.  Это адаптирует вызывающую
программу к соглашениям вызываемой процедуры.

     Обратите внимание, что Фортран  не  может  вызывать  функции
Бейсика  DEF FN или подпрограммы GOSUB, поскольку они не являются
независимыми от  других  программ  или  процедур,  то  есть,  они
содержатся в основном модуле программы Бейсика.


     4.1.1  НЕОБХОДИМОСТЬ СОГЛАШЕНИЯ ОБ ИМЕНАХ

     Термин "соглашение об именах" (naming convention)  относится
к способу изменения компилятором имени процедуры перед помещением
ее в объектный файл.

     Для выполнения вызовов разноязыковых процедур  очень  важно,
чтобы  вы  соблюдали  соответствующее соглашение об именах.  Если
имя вызываемой процедуры хранится по разному в  каждом  объектном
файле,  то  линкер  будет  не  в  состоянии  найти соответствие и
сообщит об ошибке.

     Объектные файлы помимо машинного кода содержат  также  имена
всех процедур и переменных, которые должны быть доступны открыто.
Линкер должен быть в состоянии сравнить имя вызываемой  процедуры
в  одном модуле с именем процедуры, определенной в другом модуле,
и установить соответствие.  Имена хранятся в формате  ASCII.   Вы
можете  точно  увидеть,  как  они  хранятся,  если воспользуетесь
утилитой DEBUG для просмотра дампа объектного файла.

     Фортран, Паскаль и  Бейсик  используют  примерно  одинаковые
соглашения  об именах.  Они транслируют каждую букву в заглавную.
Символы описания типа Бейсика (%, &, !, #, $) опускаются.

     Однако,  каждый  язык  распознает  разное  число   символов.
Microsoft  FORTRAN  разспознает первые 31 символов в каждом имени


                               193



(или 6, если вы используете метакоманду $TRUNCATE), Си  -  первые
31,  Паскаль - первые 8, а Бейсик - первые 40.  Если имя длиннее,
чем  число  распознаваемых  языком  символов,  то  дополнительные
символы  отбрасываются.   По  этой  причине,  каждый  раз,  когда
Фортран-программа, использующая метакоманду  $TRUNCATE,  вызывает
процедуру  из другого языка с именем, большим чем 6 символов, она
должна использовать оператор ALIAS.

     Си использует совершенно другое соглашение.   Компилятор  Си
не  транслирует  никакие  буквы  в заглавные, но вставляет символ
подчеркивания (_) перед именем каждой процедуры.

     Различия в соглашениях об именах учитываются  автоматически,
если     вы    используете    ключевые    слова    разноязыкового
программирования и следуете двум правилам:

     1.  Если   вы   используете   метакоманду   $TRUNCATE,    то
         поддерживайте  имена  всех вызываемых Фортраном процедур
         длиной до 6 символов или меньше.

     2.  Не  используйте   опцию   линкера   /NOIGNORE   (которая
         заставляет  линкер различать Prn и prn).  Для модулей Си
         это означает,  что  вы  должны  быть  внимательны  и  не
         полагаться  на  различие  между  прописными  и строчными
         буквами.

         Драйвер  CL  и  Microsoft  Quick  C   используют   опцию
         /NOIGNORE  во  время связывания (редактирования связей).
         Для того, чтобы разрешить возникающие при этом проблемы,
         либо  связывайте  раздельно с помощью утилиты LINK, либо
         используйте в модулях Си только строчные буквы.

     На рисунке 4.2 дан пример создания разноязыковой  программы,
который   показывает,   как  соглашения  об  именах  участвуют  в
процессе.

     Обратите  внимание,  что   компилятор   Фортрана   вставляет
предшествующий  символ подчеркивания перед Prn при внесении имени
в объектный файл, поскольку атрибут  C  предписывает  компилятору
Фортрана  использовать соглашение об именах Си.  При этом Фортран
также  преобразует  все  буквы   в   строчные.    Заметьте,   что
преобразование  букв  в строчные не входит в соглашение об именах
Си,  но  согласуется  со  стилем   программирования   большинства
программ Си.








                               194



+-- INTERFACE влияет на то,
|   как Фортран выполняет вызов
|
|   MAINPROG.FOR (исходный файл)     PRN.C (исходный файл)
|   +--------------------------+    +----------------------+
|   | INTERFACE TO             | +->| _prn(){              |
|   | SUBROUTINE Prn CDECL()   | |  | .                    |
|   | .                        | |  | .                    |
|   | .                        | |  | .                    |
|   | .                        | |  | }                    |
+-->| CALL Prn  -----------------+  |                      |
    | .                        |    |                      |
    | .                        |    |                      |
    | .                        |    |                      |
    | END                      |    |                      |
    +--------------------------+    +----------------------+
                  |                            |
             Компилятор                   Компилятор
              Фортрана                        Си
                  |                            |
                  v                            v
    MAINPROG.OBJ(объектный файл)     PRN.OBJ(объектный файл)
    +--------------------------+    +----------------------+
    |                          | +->| _prn:                |
    |                          | |  |                      |
    | CALL _prn  ----------------+  |                      |
    |                          |    |                      |
    |                          |    |                      |
    +--------------------------+    +----------------------+
                  |                            |
                  +--------------+-------------+
                                 |               +----------+
                               LINK  <-----------|Библиотеки|
                                 |               +----------+
                                 v
                       +-------------------+ 
    Строка CALL _prn   |xxxx: call yyyy    | \
    обращается к       |                   |  \
    адресу _prn        |                   |   машинные адреса
                       |                   |  /
                       |yyyy:              | /
                       +-------------------+
                            MAINPROG.EXE

Рисунок 4.2  Соглашения об именах


     4.1.2 НЕОБХОДИМОСТЬ СОГЛАШЕНИЯ О ВЫЗОВАХ

     Термин "соглашение о вызовах" (calling convention) относится


                               195



к  способу,  каким  язык  реализует  вызов.   Выбор  соглашения о
вызовах  влияет  на   фактические   машинные   команды,   которые
компилятор  генерирует  для  выполнения вызова функции, процедуры
или подпрограммы (и возврата обратно).

     Соглашение о вызовах это протокол нижнего  уровня.   Один  и
тот  же  протокол  для  вызывающей и вызываемой процедур является
решающим.   В   противном   случае   процессор   может   получить
противоречивые команды, приводящие к сбою системы.

     Использование    соглашения    о    вызовах    влияет     на
программирование двумя путями:

     1.  Вызывающая процедура использует соглашение о вызовах для
         определения  порядка  передачи  аргументов  (параметров)
         другой процедуре.   Это  соглашение  обычно  может  быть
         задано в разноязыковом интерфейсе.

     2.  Вызываемая процедура использует соглашение о вызовах для
         определения  порядка  приема параметров, которые были ей
         переданы.  В большинстве языков,  включая  Фортран,  это
         соглашение  определяется  заголовком процедуры.  Бейсик,
         однако, всегда использует  свое  собственное  соглашение
         для приема параметров.

     Другими словами, каждый вызов процедуры использует некоторое
соглашение  о вызовах и каждый заголовок процедуры определяет или
предполагает некоторое  соглашение  о  вызовах.   Два  соглашения
должны  быть  совместимыми.  В каждом языке, кроме Бейсика, можно
изменить любое соглашение о вызовах.  Как  правило,  проще  всего
принять   соглашение  вызываемой  процедуры.   Например,  функция
Фортрана  может  использовать  свое  собственное  соглашение  для
вызова  другой  функции  Фортрана  и  соглашение  Си  для  вызова
Си-функции.

     Фортран,  Паскаль  и  Бейсик  используют  одно   и   то   же
стандартное  соглашение  о  вызовах,  а  Си использует совершенно
другое соглашение.  Языки Microsoft  Бейсик,  Фортран  и  Паскаль
помещают параметры в стек в том порядке, в каком они появляются в
исходном  коде.   Например,  оператор  Фортрана  CALL   Calc(A,B)
помещает  аргумент  A  в  стек  перед загрузкой аргумента B.  Эти
соглашения подразумевают, что стек  восстанавливается  вызываемой
процедурой перед возвратом управления вызывающей процедуре.  Стек
восстанавливается удалением параметров.

     Соглашение  о  вызовах  Си  загружает  параметры  в  стек  в
порядке,   обратном   порядку   их  появления  в  исходном  коде.
Например, вызов  Си-функции  calc(a,b);  помещает  b  в  стек  до
загрузки  a.   В  противоположность другим языкам высокого уровня
соглашение о вызовах Си подразумевает, что  вызывающая  процедура


                               196



всегда  восстанавливает  стек  сразу  после  возврата  управления
вызываемой процедурой.

     Соглашения  Фортрана,  Паскаля  и  Бейсика  создают  немного
меньший объектный код.  Однако, соглашение Си позволяет выполнять
вызов с переменным числом параметров.  Поскольку первый  параметр
всегда  является последним загруженным, то он всегда находится на
верхушке стека, поэтому он имеет один и тот же адрес относительно
указателя  кадра,  независимо от количества фактически переданных
параметров.  Вам нет необходимости знать обо  всех  изменениях  в
соглашениях  о  вызовах  для  успешной  реализации разноязыкового
программирования,  но  необходимо  помнить,  что  такие  различия
существуют.


     4.1.3 МЕТОДЫ ПЕРЕДАЧИ ПАРАМЕТРОВ

     В  разделе  4.1.2  описан  общий  протокол   (соглашение   о
вызовах),  который  две  процедуры  используют  для  связи друг с
другом.   В  этом  разделе  описано,   как   в   действительности
происходит обмен элементом данных (параметром).

     Если  ваши  процедуры  не  согласуются  в  методе   передачи
параметров, то вызываемая процедура будет получать плохие данные.
Возможно также, что программа вызовет системную ошибку.

     Компиляторы  Microsoft  поддерживают  три  метода   передачи
параметров:

Метод         Описание
-----         --------
По ближней    Передает ближний адрес (смещение) переменной.
ссылке
              Этот метод дает вызываемой процедуре прямой доступ
              к самой переменной. Любое изменение, которое
              процедура делает с параметром, будет отражаться на
              вызывающей процедуре.

По дальней    Передает дальний (сегментированный) адрес
ссылке        переменной.

              Этот метод похож на передачу по ближней ссылке,
              только передается более длинный адрес. Этот метод
              медленнее, чем передача по ближней ссылке, но он
              необходим, если вы передаете данные, которые
              находятся вне умалчиваемого сегмента данных. Он не
              используется в Бейсике или Паскале, если только вы
              специально не запросили дальнюю память.

По значению   Передает только значение переменной, а не адрес.


                               197



              В этом методе вызываемая процедура знает значение
              параметра, но не имеет доступа к исходной
              переменной. Изменения в значении параметра не
              влияют на значение параметра в вызывающей
              процедуре.

     Тот  факт,  что   существуют   различные   методы   передачи
параметров,    имеет    два    следствия    для    разноязыкового
программирования:

      o  Вам  необходимо   удостовериться,   что   вызываемая   и
         вызывающая  процедуры  используют  одинаковый  метод для
         передачи каждого параметра (аргумента).   В  большинстве
         случаев   вам   нужно   проверить   умолчания   передачи
         параметров,  используемые  каждым   языком,   и   внести
         возможные  изменения.   Каждый язык имеет ключевые слова
         или языковые средства, которые позволяют изменить методы
         передачи параметров.

      o  Вы  можете  по  желанию  использовать  конкретный  метод
         передачи   параметров   вместо  использования  умолчаний
         каждого языка из-за характеристик вашей задачи.

     В таблице 4.2 перечислены умолчания передачи параметров  для
каждого   языка.    Каждый   язык  имеет  методы  замещения  этих
умолчаний.

Таблица 4.2  Умолчания передачи параметров
-----------------------------------------------------------------
          По ближней        По дальней
Язык      ссылке            ссылке            По значению
-----------------------------------------------------------------
FORTRAN   Все (1)           Все (1,2)         ---
C         Ближние массивы   Дальние массивы   Немассивы
Pascal    VAR,CONST         VARS,CONSTS       Другие параметры
BASIC     Все в Бейсике     Все               ---
-----------------------------------------------------------------
(1) В зависимости от модели памяти.
(2) Если на процедуру Фортрана действует атрибут PASCAL или C, то
    умолчанием становится передача по значению.


     4.1.4  ПРОБЛЕМЫ КОМПИЛЯЦИИ И РЕДАКТИРОВАНИЯ СВЯЗЕЙ

     После того, как вы написали исходные файлы и  разрешили  все
вопросы  соглашений  об  именах  и  процедур передачи параметров,
поднятые в  разделах  4.1.1  -  4.1.3,  вы  готовы  компилировать
отдельные  модули  и  затем  связать  их вместе.  Для того, чтобы
успешно это сделать, необходимо, чтобы разные модули использовали
совместимые  модели  памяти,  то есть, они должны быть согласны в


                               198



том, где хранится  информация.   Этим  модулям  необходимо  также
знать,  к  каким  библиотекам обращаться для того, чтобы избежать
неразрешенных внешних ссылок и повторных определений процедур.


     4.1.4.1  ИСПОЛЬЗОВАНИЕ СОВМЕСТИМЫХ МОДЕЛЕЙ ПАМЯТИ

     В языках Microsoft FORTRAN,  Pascal  и  BASIC  не  требуется
никаких специальных опций для компиляции исходных файлов, которые
являются частью разноязыковой программы.

     Однако, в случае Microsoft C, вам необходимо знать,  что  не
все  модели  памяти будут совместимы с другими языками.  Фортран,
Паскаль и Бейсик  используют  только  дальние  (сегментированные)
адреса.   Всегда  компилируйте  модули  Си в средней, большой или
гигантской моделях, поскольку эти модели также используют дальние
адреса.  Компиляция в маленькой или компактной моделях приведет к
краху разноязыковой программы, как только будет сделан  вызов  к-
или  из  Си.   Эта  проблема  может  быть  предотвращена, если вы
примените ключевое слово FAR  к  определению  функции  Си,  чтобы
указать, что функция использует дальний вызов и возврат.

     Различие в размерах адресов данных может быть  преодолено  с
помощью  опций  компиляции или в исходном коде.  Ваш выбор модели
памяти влияет на умалчиваемый размер указателя данных в  Фортране
и Си, хотя это умолчание может быть изменено в Фортране с помощью
атрибутов NEAR или FAR, или в Си с помощью ключевых слов near или
far.   Модели  памяти  Фортрана и Си влияют также на расположение
объектов данных  в  умалчиваемом  сегменте  данных;  если  объект
данных  расположен  не  в  умалчиваемом сегменте данных, то он не
может быть передан по ближней ссылке.


     4.1.4.2 СПЕЦИФИКАЦИЯ БИБЛИОТЕК

     Во многих случаях  связывание  модулей,  скомпилированных  с
разных  языков,  может быть легко выполнено.  Если вы используете
линкер с библиотеками Фортрана,  вам  может  понадобиться  задать
опцию  /NOD (no-default libraries - не-умалчиваемые библиотеки) и
задать все нужные вам библиотеки прямо в командной  строке  LINK.
Вы  можете также задать эти библиотеки в автоматически вызываемом
файле (или в командном файле).

     Если ваша программа использует и Фортран, и Си,  то  задайте
библиотеку  сначала для самого нового из двух языковых продуктов.
Если вы используете C 4.0 с Фортраном 4.0 или  выше,  то  задайте
сначала  библиотеку  Фортрана.  Если вы используете C 5.1 и выше,
то задайте сначала библиотеку Си.  Кроме того, убедитесь, что  вы
выбрали совместимую с Си библиотеку, когда устанавливали Фортран.



                               199



     Если вы в  командной  строке  LINK  перечисляете  библиотеки
Бейсика, то эти библиотеки должны предшествовать всем другим, как
в следующем примере:

     LINK /NOD mod1 mod2,,,GRAFX+LLIBCE+LLIBFORE

     Здесь  два  объектных  модуля  mod1  и  mod2  связываются  с
библиотеками  большой  модели  C 5.1 и Фортрана 5.0.  Кроме того,
подключается дополнительная библиотека GRAFX.


     4.2 ВЫЗОВ ИЗ ДРУГИХ ЯЗЫКОВ ВЫСОКОГО УРОВНЯ

     Помимо упомянутых  выше  проблем  компиляции  и  связывания,
вашей   программе  также  будет  необходимо  следовать  некоторым
внутренним соглашениям при вызове процедур, написанных на  другом
языке.   Сюда входит создание интерфейса для вызываемой процедуры
и  использование  ключевых  слов,   соответствующих   конкретному
вызываемому языку.

     Информация о передаче данных между языками находится в главе
5.


     4.2.1 ОПЕРАТОР INTERFACE

     Для  того,  чтобы  из  функции  Фортрана  вызвать  процедуру
другого  языка,  напишите сначала интерфейс к процедуре с помощью
оператора INTERFACE.  Этот оператор дает возможность использовать
специальные  ключевые слова (атрибуты), которые влияют на способ,
каким Фортран выполняет вызовы.  Эти ключевые слова позволяют вам
настраивать  соглашения  об именах, соглашения о вызовах и методы
передачи  параметров  таким  образом,  чтобы  вы  могли   сделать
процедуры из других языков совместимыми с Фортраном.

     Ниже перечислены основные направления  создания  интерфейсов
для процедур из других языков:

     1.  Напишите  оператор  INTERFACE  для   каждой   процедуры,
         которую вы вызываете.

     2.  Напишите интерфейс с FUNCTION, если процедура возвращает
         значение, или с SUBROUTINE, если процедура не возвращает
         значения.   Оператор  INTERFACE  должен   предшествовать
         любым вызовам процедуры.

     3.  Примените атрибут C к процедуре, если она написана на Си
         (если только модуль Си не скомпилирован с опцией /Gc или
         не модифицирован ключевым словом fortran или pascal).



                               200



         Атрибут C заставляет процедуру следовать соглашениям  об
         именах  и  вызовах  Си.   Он также изменяет умалчиваемый
         метод передачи параметров на передачу  по  значению  для
         всех параметров.  Для применения атрибута C напишите [C]
         сразу после имени процедуры.

     4.  Если процедура  вызывается  из  Паскаля,  то  вы  можете
         применить  к  процедуре  атрибут  PASCAL.   Это ключевое
         слово не изменяет соглашений о вызовах  или  именах,  но
         заставляет все параметры передаваться по значению.

         Для применения атрибута PASCAL напишите  [PASCAL]  сразу
         после имени процедуры.

     5.  Если действует  $TRUNCATE  и  имя  процедуры  длиннее  6
         символов,  то  используйте атрибут ALIAS.  Использование
         этого атрибута описано ниже в разделе 4.2.3.

     6.  Настройте  способ  передачи   параметров,   применяя   к
         описаниям   параметров   атрибуты  NEAR,  FAR,  VALUE  и
         REFERENCE.

         Атрибут REFERENCE может быть полезен, поскольку ключевые
         слова  C  и  PASCAL  автоматически изменяют умалчиваемый
         метод передачи параметров на передачу по значению.   Для
         любого  данного параметра, REFERENCE возвращает метод на
         передачу по ссылке.  (По умолчанию, Фортран передает  по
         дальней  ссылке,  если  только вы не используете среднюю
         модель памяти,  доступную  в  Фортране  версии  4.0  или
         позднее).

     7.  Для применения атрибута к описанию  параметра  поместите
         атрибут   в   квадратные   скобки   среди  любых  других
         атрибутов,  которые  модифицируют  этот  же  объект,   и
         поместите  атрибут и скобки сразу после параметра.  (См.
         пример ниже).

     8.  Как   только   соответствующий   интерфейс   установлен,
         вызывайте  процедуру  точно  так  же,  как вы вызвали бы
         функцию или процедуру Фортрана.

ПРИМЕРЫ

     В примерах ниже  для  переменных  N,  I  и  J  существенными
являются их типы и атрибуты.

     В первом примере подпрограмма  TEST  объявлена  с  атрибутом
PASCAL:

      INTERFACE TO SUBROUTINE TEST [PASCAL] (N)


                               201



      INTEGER*2 N [NEAR, REFERENCE]
      END

     Подпрограмма принимает один  аргумент  N,  который  содержит
атрибуты  NEAR  и  REFERENCE.   Поэтому  N  передается по ближней
ссылке.

     Второй пример описывает Си-функцию CFUN, которая  возвращает
значение типа REAL*8.

      INTERFACE TO REAL*8 FUNCTION CFUN [C] (I,J)
      REAL*8 I [REFERENCE]
      REAL*8 J
      END

     Аргумент I  передается  по  дальней  ссылке  из-за  атрибута
REFERENCE;  аргумент  J  передается  по  значению из-за того, что
атрибут C изменяет умолчание.


     4.2.2  АЛЬТЕРНАТИВНЫЙ ИНТЕРФЕЙС К СИ

     Шаг 2 в предыдущем разделе предполагает изменение  поведения
Фортрана  с атрибутом C при вызове процедуры Си.  В свою очередь,
поскольку  ключевые  слова   pascal   и   fortran   функционально
эквивалентны,  то  вы  можете  изменить  поведение  Си,  применяя
какое-либо ключевое слово к заголовку определения  функции.   Или
же   можете   компилировать  модуль  Си  с  опцией  /Gc,  которая
определяет, что все функции Си, вызовы и общие символы используют
соглашения Фортрана/Паскаля/Бейсика.

     Например,  следующая  функция   Си   использует   соглашения
Фортрана/Паскаля/Бейсика для приема целого параметра:

      int fortran fun1(n)
      int n;


     4.2.3  АТРИБУТ ALIAS

     Атрибут ALIAS позволяет в программе обращаться  к  процедуре
по  одному  имени, в то время как объектный код использует другое
имя.  Атрибут особенно полезен, когда вызываемая процедура  имеет
зашифрованное имя.

     Атрибут  ALIAS   использует   синтаксис   ALIAS:'aliasname'.
Обратите внимание, что aliasname это имя, которое Фортран будет в
действительности помещать  в  объектный  код  всякий  раз,  когда
вызывается   описываемая  процедура.   Если  вы  используете  это
средство, то aliasname это  в  точности  то,  что  Фортран  будет


                               202



помещать  в  объектный  код,  поэтому,  если  вы привязываетесь к
процедуре Си, то убедитесь, что  поставили  символ  подчеркивания
перед именем.

     Средство ALIAS  необходимо,  если  используется  метакоманда
$TRUNCATE  и  имя  процедуры  превышает  6  символов.   Без ALIAS
Фортран поместил бы в объектный файл только первые 6 символов,  в
то  время  как  другой язык поместил бы в другой объектный файл 8
или более  символов  (в  случае  Бейсика  до  40).   Эта  разница
помешала  бы линкеру найти соответствие.  Без $TRUNCATE Microsoft
Фортран будет принимать до 31 символов.

     В  примере  ниже  используется  ALIAS,  поскольку   PRINTNUM
длиннее,  чем  6  символов.   Заметьте, что предшествующий символ
подчеркивания должен использоваться только  в  том  случае,  если
подключается  процедура,  которая использует соглашение об именах
Си.

$TRUNCATE
      INTERFACE TO PRINTNUM [C, ALIAS:'_printnum'] (N)
      INTEGER*2 N
      END


     4.2.4  ВЫЗОВ СИ И ПАСКАЛЯ ИЗ ФОРТРАНА

     Написание в Фортране интерфейсов  к  Си  достаточно  просто.
Вызов  Паскаля  из  Фортрана  также  несложен,  поскольку атрибут
PASCAL заставляет  Фортран  использовать  умолчание  Паскаля  для
передачи  данных  по  значению.   В этом разделе на двух примерах
разноязыковых программ (Фортран-Си)  показано,  как  использовать
шаги,  описанные  в  разделе 4.2.1.  Каждый пример сопровождается
кратким комментарием.


     4.2.4.1  ВЫЗОВ СИ ИЗ ФОРТРАНА - БЕЗ ВОЗВРАЩАЕМОГО ЗНАЧЕНИЯ

     Пример ниже  показывает  главный  модуль  Фортрана,  который
вызывает   Си-функцию   maxparam.    Эта  функция  не  возвращает
значение, но меньший из двух параметров  делает  равным  большему
аргументу.

C     FORTRAN SOURCE FILE - CALLS C FUNCTION, NO RETURN
C     VALUE
C
      INTERFACE TO SUBROUTINE MAXPARAM [C] (I,J)
      INTEGER*2 I [NEAR, REFERENCE]
      INTEGER*2 J [NEAR, REFERENCE]
      END
C


                               203



C     C ATTRIBUTE DIRECTS FORTRAN TO USE C CONVENTIONS
C     EACH PARAMETER PASSED BY NEAR REFERENCE
C
      INTEGER*2 I,J
      I = 5
      J = 7
      WRITE (*,*) 'I = ',I,' J = ', J
      CALL MAXPARAM(I,J)
      WRITE (*,*) 'I = ',I,' J = ', J
      END

/* C source file */
/* Compile in MEDIUM or LARGE memory model */
/* Maxparam declared VOID because no return value */

void maxparam(p1, p2)
int near *p1; /* Integer params received by near ref. */
int near *p2; /* NEAR keyword not needed in MEDIUM model */
{
        if (*p1 > *p2)
                *p2 = *p1;
        else
                *p1 = *p2;
}

     Оба модуля помещают _maxparam (соответствующий соглашению об
именах  Си)  в  объектный  файл.  Атрибут C в операторе INTERFACE
заставляет функцию MAXPARAM следовать соглашению  о  вызовах  Си,
которое   загружает   параметры  в  стек  в  обратном  порядке  и
определяет другие различия нижнего уровня.

     Поскольку функция maxparam должна менять значение одного  из
параметров,   то   оба  передаются  по  ссылке.   Ближняя  ссылка
реализована в Фортране с помощью атрибутов NEAR и REFERENCE, а  в
Си  с  помощью  близких указателей.  Атрибут REFERENCE в Фортране
необходим, поскольку ключевое слово C изменяет умалчиваемый метод
передачи параметров на передачу по значению.

     Дальняя ссылка могла  бы  быть  задана  удалением  ключевого
слова NEAR из описаний параметров Фортрана.  В этом случае модуль
Си должен был бы использовать дальние указатели.


     4.2.4.2  ВЫЗОВ СИ ИЗ ФОРТРАНА - ВЫЗОВ ФУНКЦИИ

     Пример ниже показывает главный модуль  Фортрана,  вызывающий
Си-функцию fact.  Эта функция возвращает факториал целого числа.

C     FORTRAN SOURCE FILE - CALLS C FUNCTION
C


                               204



      INTERFACE TO INTEGER*2 FUNCTION FACT [C] (N)
      INTEGER*2 N
      END
C
C     C ATTRIBUTE DIRECTS FORTRAN TO USE C CONVENTIONS
C     PARAMETER PASSED BY VALUE, WHICH IS DEFAULT WHEN
C     C ATTRIBUTE IS IN USE
C
      INTEGER*2 FACT
      INTEGER*2 I,J
      I = 3
      J = 4
      WRITE (*,*) 'The factorial of I   is ',FACT(I)
      WRITE (*,*) 'The factorial of J   is ',FACT(I)
      WRITE (*,*) 'The factorial of I+J is ',FACT(I+J)
      END

/* C source file */
/* Compile in MEDIUM or LARGE model */
/* Factorial function, returning integer */

int fact(n)
int n; /* Integer received by value, the C default */
{
     int    result = 1;

     while  (n)
            result *= n--; /* Parameter n modified here */
     return (result);
}

     Атрибут C в операторе INTERFACE заставляет FACT вызываться в
соответствии с соглашением об именах Си (как _fact).  Кроме того,
этот атрибут приводит  к  тому,  что  FACT  будет  вызываться  по
соглашению  о  вызовах  Си,  которое загружает параметры в стек в
обратном порядке и определяет другие различия нижнего уровня.

     Функция Си выше должна принимать параметр  по  значению.   В
противном  случае  функция  будет  разрушать значение параметра в
вызывающем модуле.  Передача по  значению  является  умалчиваемым
методом  для Си; она является умалчиваемым методом и для Фортрана
всякий раз, когда используется атрибут C.


     4.2.4.3  ВЫЗОВ ПАСКАЛЯ ИЗ ФОРТРАНА - ВЫЗОВ ПРОЦЕДУРЫ

     Пример ниже показывает главный модуль  Фортрана,  вызывающий
процедуру  Паскаля  Maxparam.   Эта  процедура  меньший  из  двух
параметров делает равным большему аргументу.



                               205



C     FORTRAN SOURCE FILE - CALLS PASCAL PROCEDURE
C
      INTERFACE TO SUBROUTINE MAXPARAMETER
     + [ALIAS:'MAXPARAM'] (I,J)
      INTEGER*2 I [NEAR]
      INTEGER*2 J [NEAR]
      END
C
C     ALIAS NECESSARY BECAUSE 'MAXPARAMETER' LONGER
C     THAN 8 CHARS.
C     EACH PARAMETER PASSED BY NEAR REFERENCE
C
      INTEGER*2 I,J
      I = 5
      J = 7
      WRITE (*,*) 'I = ',I,' J = ', J
      CALL MAXPARAMETER(I,J)
      WRITE (*,*) 'I = ',I,' J = ', J
      END

{ Pascal source code - Maxparam procedure. }

module Psub;
 procedure Maxparam(var a:integer; var b:integer);

{ Two integer parameters are receives by near reference. }
{ Near reference is specifies with the NEAR keyword. }

 begin
   if a > b then
       b := a
   else
       a := b
 end;
end.

     По умолчанию, Фортран  помещает  в  объектный  файл  все  12
символов  MAXPARAMETER,  тогда  как  Паскаль - только 8.  Атрибут
ALIAS разрешает этот конфликт:  оба модуля помещают  в  объектный
файл  MAXPARAM.   Фортран  и  Паскаль  используют  одно  и  то же
соглашение для вызова.

     Поскольку процедура Maxparam может изменить значение  одного
из  параметров,  то  оба  должны передаваться по ссылке.  Ближняя
ссылка была реализована в Фортране с помощью атрибута NEAR,  а  в
Паскале  с  помощью ключевого слова VAR.  Атрибут PASCAL здесь не
используется,  поскольку  по  значению  не  передается  ни   один
параметр.

     Дальняя ссылка  могла  бы  быть  задана  удалением  NEAR  из


                               206



описаний  параметров  Фортрана и использованием VARS вместо VAR в
модуле Паскаля.


     4.2.4.4  ВЫЗОВ ПАСКАЛЯ ИЗ ФОРТРАНА - ВЫЗОВ ФУНКЦИИ

     Пример ниже показывает главный модуль  Фортрана,  вызывающий
функцию  Паскаля  Fact.   Эта функция возвращает факториал целого
значения.

C     FORTRAN SOURCE FILE - CALLS PASCAL FUNCTION
C
      INTERFACE TO INTEGER*2 FUNCTION FACT [PASCAL] (N)
      INTEGER*2 N
      END
C
C     PARAMETER PASSED BY VALUE, WHICH IS DEFAULT WHEN
C     PASCAL ATTRIBUTE IS IN USE
C
      INTEGER*2 FACT
      INTEGER*2 I,J
      I = 3
      J = 4
      WRITE (*,*) 'The factorial of I   is ',FACT(I)
      WRITE (*,*) 'The factorial of J   is ',FACT(J)
      WRITE (*,*) 'The factorial of I+J is ',FACT(I+J)
      END

{ Pascal source code - factorial function. }

module Pfun;
 function Fact (n : integer) : integer;

{ Integer parameters received by value, the Pascal default. }

 begin
    Fact := 1;
    while n > 0 do
        begin
            Fact := Fact * n;
            n := n - 1;        { Parameter n modified here. }
        end;
 end;
end.

     Фортран  и  Паскаль  используют  одинаковые  соглашения   об
именах.   Оператор  ALIAS  не  нужен,  поскольку  имя  функции не
превышает предела  Паскаля  в  8  символов.   Фортран  и  Паскаль
используют одинаковое соглашение о вызовах.



                               207



     Функция Паскаля выше должна принять параметр по значению.  В
противном   случае,   функция   разрушит   значение  параметра  в
вызывающем модуле.  Передача по значению является умолчанием  для
Паскаля; она является умолчанием и для Фортрана всякий раз, когда
используется атрибут PASCAL.


   4.2.5  ФУНКЦИИ СИ, ДОСТУПНЫЕ С БИБЛИОТЕКАМИ
          ВРЕМЕНИ ВЫПОЛНЕНИЯ ФОРТРАНА

     Библиотеки  времени  выполнения  Фортрана   MLIBFORx.LIB   и
LLIBFORx.LIB  включают  процедуру system и подмножество процедуры
spawnlp (а также другие  процедуры),  первоначально  имевшиеся  в
библиотеке Си.  Программы Фортрана имеют доступ к этим процедурам
в библиотеках времени выполнения Фортрана; однако, эти  процедуры
могут   составить  проблему  совместимости  с  будущими  версиями
Microsoft  C.   В  разделах  4.2.5.1  -  4.2.5.2  показано,   как
обратиться  к  этим  процедурам Си и обсуждаются будущие проблемы
совместимости.    (Демонстрационная    программа    DEMOEXEC.FOR,
включенная в состав компилятора Microsoft FORTRAN, также содержит
примеры вызова этих процедур Си).


     4.2.5.1  ДОСТУП К ФУНКЦИЯМ SYSTEM И SPAWNLP

     Функция system имеет следующее описание в Си:

      int system (string)
      char *string;

     Функция system передает заданную строку  Си  (оканчивающуюся
нулевым   символом)   интерпретатору  команд  DOS  (COMMAND.COM),
который интерпретирует и выполняет строку, как команду DOS.   Это
позволяет   выполнять  команды  DOS  (такие  как  DIR  или  DEL),
командные файлы и программы.

     Следующий фрагмент программы показывает,  как  из  программы
Фортрана  обратиться  к  функции  system для вывода на экран всех
файлов из текущего каталога с расширением .FOR.

      INTEGER*2 SYSTEM
C     RETURN TYPE MUST BE DECLARED;
C     NOTICE THE C LITERAL STRING '...'C
      I = SYSTEM ('DIR *.FOR'C)

     Оператор INTERFACE,  необходимый  для  обращения  к  system,
показан  ниже.   Атрибут  C  задан  после  имени функции.  Строка
аргумента  включает  атрибут  REFERENCE,  чтобы   показать,   что
аргумент передается по ссылке.



                               208



      INTERFACE TO INTEGER*2 FUNCTION SYSTEM [C]
     + (STRING[REFERENCE])
      CHARACTER*1 STRING
      END

     Функция spawnlp имеет следующее описание в Си:

int spawnlp (mode,path,arg0,arg1,...,argn)
   int mode;    /* spawn mode */
   char *path;  /* pathname of program to execute */
   char *arg0;  /* should be the same as path */
   char *arg1,...,*argn;    /* command line arguments */
   /* argn must be NULL */

     Эта функция создает и выполняет новый  порожденный  процесс.
Для  загрузки  и  выполнения порожденного процесса должно иметься
достаточно памяти.  Аргумент mode определяет, какая форма spawnlp
выполняется.   Для  версии  функции spawnlp в библиотеках времени
выполнения Фортрана это значение должно быть 0, что  предписывает
spawnlp   приостановить   родительскую   программу   и  выполнить
порожденную  (дочернюю)  программу.   После  выполнения  дочерней
программы  родительская  программа  возобновляет  выполнение.   В
случае ошибки spawnlp возвращает -1.   Если  порожденный  процесс
выполняется успешно, то возвращаемое значение равно коду возврата
порожденного процесса.

     Аргумент path определяет файл,  который  должен  выполняться
как  порожденный  процесс.  Path может определять полное имя пути
из корневого каталога, частичное имя пути  из  текущего  рабочего
каталога,  или имя файла.  Если аргумент path не имеет расширения
имени файла или оканчивается точкой  (.),  то  spawnlp  добавляет
сначала расширение .COM и ищет файл.  Если spawnlp не может найти
файл, то добавляет расширение .EXE и пытается снова  найти  файл.
Кроме  того,  процедура  spawnlp  ищет  файл  во  всех каталогах,
указанных  в  переменной  окружения  PATH  с  помощью   этой   же
процедуры.

     Оператор INTERFACE, необходимый для обращения к  spawnlp  из
программы  Фортрана,  показан  ниже.   После имени функции должен
находиться атрибут C.  Атрибут VARYING  показывает,  что  функции
может передаваться переменное число аргументов.

      INTERFACE TO INTEGER*2 FUNCTION SPAWNLP
     + [C,VARYING] (MODE)
      INTEGER*2 MODE
      END

     Если вы используете метакоманды $STRICT или $TRUNCATE, то  в
операторе  INTERFACE  должны  использовать  имя из 6 символов или
меньше, и использовать атрибут ALIAS для того, чтобы связать  имя


                               209



SPAWN Фортрана с идентификатором spawnlp Си.

     Следующий фрагмент программы показывает, как вызвать функцию
spawnlp из программы Фортрана:

C     (THE RETURN TYPE MUST BE DECLARED)
      INTEGER*2 SPAWNLP
      .
      .
      .
C      EXECUTE AS A CHILD PROCESS
      I = SPAWNLP(0, LOC('EXEMOD'C), LOC('EXEMOD'C), c
     + LOC('DEMOEXEC.EXE'C), INT4(0))

     В этом примере обратите внимание,  что  метод,  используемый
для передачи строк в spawnlp, отличается от метода, используемого
для  передачи  строк  в  system.   Это  происходит  потому,   что
строковые  аргументы к spawnlp не описаны в операторе INTERFACE и
по умолчанию передаются по  значению.   Функция  spawnlp  ожидает
адреса  строк,  а  не  действительные  символы, поэтому программа
Фортрана использует для передачи адреса внутреннюю  функцию  LOC.
(Вспомните,  что  функции  с  атрибутом  C  передают аргументы по
значению).  Последний аргумент к процедуре  spawnlp  должен  быть
нулевым  указателем  Си (целое 0), поэтому программа Фортрана для
передачи  этого  указателя  по   значению   должна   использовать
внутренюю  функцию  INT2(0)  или INT4(0) (в зависимости от модели
памяти).


     4.2.5.2  БИБЛИОТЕКИ ФОРТРАНА И БУДУЩИЕ ВЕРСИИ Microsoft C

     Если вы планируете смешивать  модули  Microsoft  Фортрана  с
модулями,  компилируемыми с использованием Microsoft C, то должны
использовать утилиту  SETUP  для  подготовки  новых  копий  ваших
библиотек  времени  выполнения  Фортрана.  Во время создания этих
копий сообщите SETUP, что вы хотите копии для связи с Си.   SETUP
удалит  процедуры  из  этих  копий.  Позднее, когда вы связываете
модули   Фортрана   с   модулями   Си,   вы   должны   подключить
соответствующую  библиотеку  времени  выполнения  Си  для  модели
памяти, которую вы  используете.   Такая  связь  будет  учитывать
неразрешенные   ссылки   из  MLIBFORx.LIB  и  LLIBFORx.LIB.   Для
программ, которые не включают модули Си, вы сможете  использовать
свои первоначальные копии MLIBFORx.LIB и LLIBFORx.LIB.


     4.2.6  ВЫЗОВ БЕЙСИКА ИЗ ФОРТРАНА

     Обращение из программ  Фортрана  к  программам  Бейсика  (MS
QuickBASIC  4.0  или  позже  или Microsoft BASIC Compiler 6.0 или
позже)  прямо  не  поддерживается.    Процедура   Бейсика   может


                               210



выполняться только в том случае, когда главная программа остается
в Бейсике, поскольку процедура Бейсика требует окружения, которое
должно  инициироваться способом, уникальным для Бейсика.  Никакой
другой язык не может выполнить эту специальную инициацию.

     Программа  может  стартовать  в  Бейсике,  вызвать   функцию
Фортрана,  которая  выполняет  основную работу программы, а затем
вызвать  подпрограммы  Бейсика  и  процедуры   функции,   которые
необходимы.  Рисунок 4.3 показывает, как это можно сделать.

            Код Бейсика               Код Фортрана
          +------------------+      +------------------+
Запуск -->| .                |  +-->| SUBROUTINE FSUB  |
Бейсика   | .                |  |   | .                |
          | .                |  |   | .                |
Оконч.    | CALL Fsub  ---------+   | .                |
Бейсика-->| END              |   +--| CALL BTEST       |
          |                  |   |  | .                |
          | SUB Btest STATIC |<--+  | .                |
          | .                |      | .                |
          | .                |      | RETURN           |
          | .                |      | END              |
          | END SUB          |      |                  |
          +------------------+      +------------------+

Рис. 4.3  Вызов Бейсика из Фортрана

     Ниже приведены рекомендуемые правила для вызова  Бейсика  из
Фортрана:

     1.  Стартовать  в  главном  модуле   Бейсика.    Вам   может
         понадобиться  использовать  QuickBASIC  версии  4.0  или
         выше, и  использовать  оператор  DECLARE  для  написания
         интерфейса     к     основной     процедуре    Фортрана.
         (Дополнительная  информация  имеется  в  разделе   5.1.1
         "Аргументы Бейсика").

     2.  Написать  в  Фортране  интерфейс  для  каждой  процедуры
         Бейсика,  которую  вы  планируете  вызывать.   Поскольку
         Бейсик и  Фортран  используют  одинаковое  соглашение  о
         вызовах,   то  для  создания  совместимости  Фортрана  и
         Бейсика не требуется никаких специальных ключевых слов.

     3.  Убедитесь, что все данные передаются по ближней  ссылке.
         Бейсик  может  передавать  данные  самыми разнообразными
         способами, но не способен принять данные иначе,  чем  по
         ближней ссылке.

         Программа, использующая  ближние  ссылки,  предполагает,
         что  данные  находятся  в  умалчиваемом сегменте данных.


                               211



         Если вы хотите передать данные, которые находятся  не  в
         умалчиваемом  сегменте  данных  (это  возможно  только с
         программами  большой  модели),  то  сначала   скопируйте
         данные  в  переменную,  которая находится в умалчиваемом
         сегменте данных.

     Пример ниже показывает программу Бейсика,  которая  вызывает
подпрограмму  Фортрана.   Подпрограмма  Фортрана  затем  вызывает
функцию Бейсика, которая возвращает удвоенное  число,  переданное
ей, и подпрограмму Бейсика, которая печатает два числа.

' BASIC source
'
DEFINT A-Z
DECLARE SUB Fprog ()
CALL Fprog
END
'
FUNCTION Dbl(N) STATIC
    Dbl = N*2
END FUNCTION
'
SUB Printnum(A,B) STATIC
    PRINT "The first number is ";A
    PRINT "The second number is ";B
END SUB


C     FORTRAN subroutine
C     Calls a BASIC function that receives one integer,
C     and a BASIC subprogram that takes two integers.
C
      INTERFACE TO INTEGER*2 FUNCTION DBL (N)
      INTEGER*2 N [NEAR]
      END
C
      INTERFACE TO SUBROUTINE PRINTNUM(N1, N2)
      INTEGER*2 N1 [NEAR]
      INTEGER*2 N2 [NEAR]
      END
C
C     Parameters must be declared NEAR in the parameter
C     declarations; BASIC receives ONLY 2-byte pointers
C
      SUBROUTINE FPROG
      INTEGER*2 DBL
      INTEGER*2 A, B
      A = 5
      B = 6
      WRITE (*, *) 'Doubling 5 equals ', DBL(A)


                               212



      CALL PRINTNUM(A, B)
      END

     Обратите внимание, что в этом примере в процедурах  Фортрана
используется  атрибут  NEAR,  поэтому в Бейсик будут передаваться
ближние адреса вместо дальних.


     4.3  ИСПОЛЬЗОВАНИЕ ПРОЦЕДУР ЯЗЫКА АССЕМБЛЕРА

     У вас может появиться желание написать  процедуры  на  языке
ассемблера,  если  возникнет  критическая  ситуация  со скоростью
выполнения отдельных частей программы.  С помощью макроассемблера
Microsoft  MASM  вы  можете написать ассемблерные модули, которые
сможете связать с модулями, созданными  с  помощью  Фортрана.   В
этом  разделе  описаны  рекомендуемые методы программирования для
написания процедур ассемблера, совместимых с MSФортраном, а также
даны некоторые примеры.

     Написание ассемблерных  процедур  для  MSФортрана  несложно,
если  вы используете упрощенные сегментные директивы, имеющиеся в
макроассемблере   MASM   версии   5.0.    Вообще,    эта    глава
подразумевает, что вы имеете MASM 5.0.

     Программа  Фортрана  может  вызывать  внешние   ассемблерные
процедуры,   используя   оператор  INTERFACE.   Однако,  оператор
INTERFACE не является  строго  необходимым,  если  только  вы  не
предполагаете изменить одно из умолчаний Фортрана.  Тем не менее,
вам могут быть полезными следующие рекомендации:

     1.  Объявляйте процедуры, вызываемые из Фортрана, как FAR.

     2.  Соблюдайте следующее соглашение об именах Фортрана:

         1.  На  выходе  процедура  должна  восстановить   в   SP
             значение,  которое  он имел перед тем, как аргументы
             были  помещены  в  стек.   Это  должно   завершаться
             командой  RET  size,  где size равно полному размеру
             всех параметров.

         2.  Аргументы помещаются в стек в том порядке,  в  каком
             они  появляются  в  исходном  коде Фортрана.  Первый
             параметр должен быть наивысшим в  памяти  (поскольку
             он  является  также  первым параметром, помещаемым в
             стек, а стек растет вниз).

         3.  По  умолчанию,  параметры  Фортрана  передаются   по
             ссылке  как  дальние  адреса,  если  модуль Фортрана
             компилировался  в  большой  или  гигантской  моделях
             памяти,  и  как ближние адреса, если модуль Фортрана


                               213



             компилировался в средней модели.  Версии Фортрана до
             4.0 всегда имеют большую модель.

     3.  Соблюдайте соглашение об именах Фортрана.

         Фортран  распознает  только  первые  6  символов  любого
         имени, если задана метакоманда $TRUNCATE, в то время как
         ассемблер   распознает   31.    По   умолчанию   Фортран
         распознает 31 символов.

     В следующем примере Фортран вызывает ассемблерную процедуру,
которая  вычисляет "A * 2**B", где A и B являются первым и вторым
параметрами, соответственно.  Это выполняется сдвигом A влево  на
B бит.

     Пример показывает, как Фортран  может  вызвать  ассемблерную
процедуру:

       INTERFACE TO INTEGER*2 POWER2(A,B)
       INTEGER*2 A,B
       END
C
       INTEGER*2 A,B
       A = 3
       B = 5
       WRITE (*,*) '3 times 2 to the power of 5 is ',
      + POWER2(A,B)
       END

     Для того, чтобы понять, как написать  процедуру  ассемблера,
рассмотрим,  как  параметры  помещаются  в  стек, что показано на
рисунке 4.4.
                                        Старшие адреса
                     - +--------------+
                       | Arg1 segment |       BP+12
                     A |              |
                       | Arg1 offset  |<-- BP+10
                     - +--------------+
(Стек растет вниз      | Arg2 segment |       BP+8
с каждой загрузкой   B |              |
или вызовом)           | Arg2 offset  |<-- BP+6
------------------   - +--------------+
         |             |    Адрес     |       BP+4
         V             |   возврата   |
                       |   (4 байта)  |       BP+2
                       +--------------+
                       |   Saved BP   |<-- BP
                       +--------------+
                                        Младшие адреса
Рис.4.4  Кадр стека Фортрана


                               214



     Рисунок 4.4 предполагает большую модель Фортрана.   Если  вы
компилируете модуль Фортрана в средней модели, то каждый аргумент
будет передаваться как двухбайтовый, а не четырехбайтовый  адрес.
Адрес  возврата  имеет  четыре  байта длины, поскольку процедуры,
вызываемые из Фортрана, всегда должны быть как FAR.

     Arg1  (параметр  1)  находится  выше  в  памяти,  чем  Arg2,
поскольку  Фортран загружает аргументы (параметры) в том порядке,
в каком они появляются.

     Ассемблерная  процедура  может   быть   написана   следующим
образом:

.MODEL LARGE
.CODE
        PUBLIC  Power2
Power2  PROC
        push    bp              ; Entry sequence - save old
        mov     bp,sp           ; Set stack frame pointer

        les     bx,[bp+10]      ; Load Arg1 into
        mov     ax,es:[bx]      ;   AX
        les     bx,[bp+6]       ; Load Arg2 into
        mov     cx,es:[bx]      ;   CX
        shl     ax,cl           ; AX = AX * (2 to power of )
                                ; Leave return value in AX

        pop     bp              ; Exit sequence - restore 
        ret     8               ; Return and restore 8 bytes
Power2  ENDP
        END

     В этом примере каждый аргумент должен загружаться с  помощью
четырехбайтового  адреса,  который  помещается в стек.  Процедура
загружает четырехбайтовые адреса с помощью команды  les,  которая
загружает  операнд-приемник  (в  данном  случае  BX) из операнда-
источника, а также загружает  ES  объектом,  находящимся  на  два
байта выше в памяти.  Таким образом, команда

        les     bx,[bp+10]

загружает  BX  значением,  находящимся  по  адресу  BP+10  (адрес
смещения),  а  ES - значением, находящимся по адресу BP+12 (адрес
сегмента), что необходимо для установки следующей команды.

     На выходе стек восстанавливается командой  ret  8,  так  как
полный  размер  параметров,  загруженных  в  стек,  равен  восьми
байтам.




                               215



     4.4  ВЫЗОВ ФОРТРАНА ИЗ ДРУГИХ ЯЗЫКОВ

     Другие компилируемые языки Microsoft - C, Pascal и  BASIC  -
поддерживают вызовы компилируемых подпрограмм и функций Фортрана.
Если вы имеете набор регулярно используемых процедур  Фортрана  и
программируете также на этих языках, то можете сэкономить время и
энергию, вызывая эти процедуры Фортрана, а не  транслируя  их  на
другие языки.

     Обратите внимание, что, в отличие от Паскаля и  Си,  Фортран
не  имеет  общих  переменных.   Общими  являются  только функции,
подпрограммы и общие  блоки;  отдельные  переменные  Фортрана  не
могут  быть  объявлены  общими.   Поэтому,  если вы хотите, чтобы
процедура, написанная на другом языке, обращалась непосредственно
к  переменной  Фортрана,  то  эта  переменная должна находиться в
общем блоке Фортрана.  Например, вы можете  описать  в  процедуре
Фортрана  общий  блок,  после чего обращаться к нему из программы
Си, описав внешнюю структуру этого же вида.

     Каждый язык имеет свои собственные  соглашения  и  процедуры
для  обращения  к  MSФортрану.   Они  описаны  в  соответствующих
руководствах   по   этим   языкам,   в   разделах,    посвященных
разноязыковому программированию.





























                               216
