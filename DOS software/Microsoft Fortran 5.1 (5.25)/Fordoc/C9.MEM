








                               ГЛАВА 9

                        ГРАФИЧЕСКИЕ ПРИМИТИВЫ

     Графика может сделать выводимые данные более  понимаемыми  и
информативными.   В этой главе описаны все строительные элементы,
необходимые  для   создания   широкого   разнообразия   рисунков.
Предполагается,  что вы прочли обзор, данный в главе 8.  Обратите
внимание,  что  графическая  библиотека   OS/2   GRTEXTP.LIB   не
поддерживает  процедур  для  работы со шрифтами.  В конце главы 8
приведен список процедур OS/2, доступных в DOS.

     Графические  процедуры  DOS,  поставляемые  с   компилятором
MSФортрана,  рисуют  точки,  линии,  меняют цвета, а также рисуют
такие фигуры, как окружности, прямоугольники и  дуги.   В  первом
разделе   определены   некоторые  основные  графические  термины,
перечислены этапы использования  графики  высокого  разрешения  и
приведены   примеры   программ,  показывающие,  как  использовать
основные процедуры.  В других разделах подробно  описаны  системы
координат и использование окон.


     9.1  РАБОТА С ГРАФИЧЕСКИМИ РЕЖИМАМИ

     Перед тем как ваша  программа  начнет  рисовать  графические
элементы,  вам  необходимо  задать  тип  используемого  монитора,
нужное разрешение экрана и палитру - цветную  или  черно-белую  -
короче,   задать  режим  отображения  графики.   В  этом  разделе
показано, как определить соответствующий графический  режим,  как
сделать   его   активным   и  как  написать  простую  графическую
программу.

     В  этой  главе   часто   используются   следующие   термины.
Убедитесь, что вы с ними знакомы:

      -  "Начало" (точка 0,0) это верхний левый  угол  экрана,  с
         которого  начинаются  оси  x  и y.  В некоторых системах
         координат начало можно перемещать.

      -  Ось   x   представляет    горизонтальное    направление.
         Максимальное  число  горизонтальных  пикселов (элементов
         изoбражения) меняется от 320 до  720  в  зависимости  от
         используемой    графической    платы    и   действующего
         графического режима.


                               267



      -  Вертикальное направление представляется осью  y.   Число
         вертикальных пикселов меняется от 200 до 480.

      -  Каждый графический  режим  имеет  цветовую  палитру.   В
         зависимости   от   графической  платы,  установленной  в
         компьютере,   и   действующего   графического    режима,
         разрешается  использовать  2, 4, 8, 16 или 256 "цветовых
         индексов" (чисел, связанных с конкретным цветом экрана).

      -  Режимы  CGA  используют  четыре  фиксированных  палитры,
         содержащих   предопределенные   цвета,   которые  нельзя
         изменить.  Режимы  EGA,  MCGA  и  VGA  дают  возможность
         изменять  любой из цветовых индексов, позволяя тем самым
         определять значение цвета для нужной вам смеси цветов.

      -  Индекс цвета всегда имеет тип INTEGER*2.  Значение цвета
         всегда  имеет  тип  INTEGER*4.   При  вызове графических
         процедур с цветовыми параметрами помните о разнице между
         индексами   цветов  и  значениями  цветов  (см.   раздел
         9.2.1.2 "Смешение цветов").

     Для того, чтобы подготовить систему к  отображению  графики,
вам необходимо:

     1.  Вызвать процедуру getvideoconfig  для  определения  типа
         установленного    видеоадаптера   (см.    раздел   9.1.1
         "Проверка текущего видеорежима").

     2.  С  помощью  процедуры  setvideomode  установить   нужный
         графический   режим  для  адаптера  (см.   раздел  9.1.2
         "Установка видеорежима").

     3.  Рисовать   графику   (см.    раздел   9.1.3   "Написание
         графической программы").

     По  завершении  рисования  перед  выходом  из  программы  не
забудьте вернуть монитор в текстовый режим.

     ПРЕДУПРЕЖДЕНИЕ:  При редактировании связей всегда необходимо
явно указать графическую библиотеку.


     9.1.1  ПРОВЕРКА ТЕКУЩЕГО ВИДЕОРЕЖИМА

     Для того чтобы избежать проблем, связанных с совместимостью,
перед    установкой   видеорежима   следует   вызвать   процедуру
getvideoconfig.  Информация  о  текущей  системе  возвращается  в
структуре   videoconfig,   определенной   в   файле  FGRAPH.FD  и
приведенной в нижеследующем примере.



                               268



     Структура  videoconfig  определена  ниже.   Вам   необходимо
понимать  смысл  и  назначение  полей  этой  структуры, поскольку
некоторые графические процедуры принимают  эти  поля  в  качестве
аргументов.

STRUCTURE/videoconfig/
  INTEGER*2 numxpixels          ! число пикселов по оси x
  INTEGER*2 numypixels          ! число пикселов по оси y
  INTEGER*2 numtextcols         ! число имеющихся столбцов текста
  INTEGER*2 numtextrows         ! число имеющихся строк текста
  INTEGER*2 numcolors           ! число индексов цветов
  INTEGER*2 bitsperpixel        ! число бит на пиксел
  INTEGER*2 numvideopages       ! число имеющихся видеостраниц
  INTEGER*2 mode                ! текущий видеорежим
  INTEGER*2 adapter             ! активный адаптер
  INTEGER*2 monitor             ! активный монитор
  INTEGER*2 memory              ! видеопамять адаптера в Кбайтах
END STRUCTURE

     Поля структуры videoconfig инициируются при вызове процедуры
getvideoconfig.


     9.1.2  УСТАНОВКА ВИДЕОРЕЖИМА

     После  того,  как  вы  узнали   текущую   видеоконфигурацию,
необходимо  дать  команду  графическому  адаптеру переключиться с
текстового  режима  на  графический.   Для   этого   используется
процедура   setvideomode.    Эта   процедура   передаст  адаптеру
константу,  которая  говорит,  какой  режим   использовать   (см.
таблицу 9.1).

     Имена  видеорежимов  в   виде   символических   констант   с
соответствующими значениями определены в include-файле FGRAPH.FD.
Размерности экрана для каждого  режима  указаны  в  пикселах  для
графических  режимов и в столбцах для текстовых режимов.  Столбец
"Тип режима/адаптер" показывает предполагаемую среду.

     ЗАМЕЧАНИЕ:  При использовании адаптера  Hercules  необходимо
перед выводом графики выполнить программу MSHERC.COM.

     Если setvideomode  возвращает  0,  то  аппаратная  среда  не
поддерживает  выбранный режим.  Вы можете продолжить выбор других
видеорежимов, пока процедура не вернет ненулевое  значение.   Для
выбора   режима   с   наивысшим   доступным   разрешением,  можно
осуществлять вызовы setvideomode, переходя  от  высшего  к  более
низкому  разрешению.   Для этого лучше всего подходит конструкция
SELECT CASE.  Если аппаратная  конфигурация  не  поддерживает  ни
одного  из  выбранных  режимов,  то  программа  не может выводить
графику.


                               269



     В таблице 9.1 приведены имена различных видеорежимов.

Таблица 9.1:  Видеорежимы для текста и графики
-----------------------------------------------------------------
Константа         Видеорежим                   Тип режима/адаптер
-----------------------------------------------------------------
$DEFAULTMODE      Возврат к исходному режиму   Оба/все

$TEXTBW40         40 столбцов текста,          Текст/CGA
                  16 оттенков серого

$TEXTC40          40 столбцов текста,          Текст/CGA
                  16/8 цветов

$TEXTBW80         80 столбцов текста,          Текст/CGA
                  16 оттенков серого

$TEXTC80          80 столбцов текста,          Текст/CGA
                  16/8 цветов

$MRES4COLOR       320x200, 4 цвета             Графика/CGA

$MRESNOCOLOR      320x200, 4 серого            Графика/CGA

$HRESBW           640x200, черно-белый(BW)     Графика/CGA

$TEXTMONO         80 столбцов текста, BW       Текст/MDA

$HERCMONO         720x348, BW для HGC          Графика/HGC

$MRES16COLOR      320x200, 16 цветов           Графика/EGA

$HRES16COLOR      640x200, 16 цветов           Графика/EGA

$ERESNOCOLOR      640x350, BW                  Графика/EGA

$ERESCOLOR        640x350, 4 или 16 цветов     Графика/EGA

$VRES2COLOR       640x480, BW                  Графика/VGA/MCGA

$VRES16COLOR      640x480, 16 цветов           Графика/VGA

$MRES256COLOR     320x200, 256 цветов          Графика/VGA/MCGA

$ORESCOLOR        640x400, 1 из 16 цветов      Графика/Olivetti
-----------------------------------------------------------------






                               270



Таблица 9.1:  Видеорежимы для текста и графики
-----------------------------------------------------------------
Константа         Видеорежим                   Тип режима/адаптер
-----------------------------------------------------------------
$MAXCOLORMODE(1)  См.таблицы R.5 и R.6 о       Графика/CGA
                  максимальных цветах

$MAXRESMODE (1)   См.таблицы R.5 и R.6 о       Графика/CGA
                  максимальном разрешении
-----------------------------------------------------------------
(1) Таблицы R.5 и R.6 находятся в главе 11, в разделе о
    графических процедурах, ниже setvideomode.


     9.1.3  НАПИСАНИЕ ГРАФИЧЕСКОЙ ПРОГРАММЫ (SINE)

     Подобно  многим  другим  программам,  графические  программы
прекрасно  работают  в  модульном виде.  Использование дискретных
процедур  облегчает  отладку,   благодаря   выделению   отдельных
функциональных  компонент  программы.   Основные  этапы написания
графической программы показаны в следующем примере.

     Программа   SINE   создает   синусоиду.    Ее   подпрограммы
используют многие общие графические процедуры.  Главная программа
(см.ниже) имеет модульную  структуру  и  вызывает  пять  функций,
которые   выполняют   действительные  графические  команды.   Все
функции определены далее в этой главе.

CC  SINE.FOR - Illustrates basic graphics commands.

      INCLUDE 'FGRAPH.FI'

      CALL graphicsmode()
      CALL drawlines()
      CALL sinewave()
      CALL drawshapes()
      CALL endprogram()
      END

C     Definitions of subroutines go here
.
.
.


     9.1.3.1  АКТИВИЗАЦИЯ ГРАФИЧЕСКОГО РЕЖИМА

     Перед тем, как программа сможет выводить графику, вам  нужно
задать   графический  режим  и  вызвать  процедуру  setvideomode,
которая настраивает видеоадаптер на  соответствующий  графический


                               271



режим.

     Программа   SINE   включает   графический   режим    вызовом
подпрограммы  graphicsmode,  которая выбирает наивысшее возможное
разрешение для текущего видеоадаптера (такого как CGA или VGA).

      SUBROUTINE graphicsmode() 

      INCLUDE  'FGRAPH.FD'

      INTEGER*2            dummy, maxx, maxy
      RECORD /videoconfig/ myscreen
      COMMON               maxx, maxy

C
C     Find graphics mode.
C
      CALL getvideoconfig( myscreen )
      SELECT CASE( myscreen.adapter )
         CASE( $CGA )
            dummy = setvideomode( $HRESBW )
         CASE( $OCGA )
            dummy = setvideomode( $ORESCOLOR )
         CASE( $EGA, $OEGA )
            IF( myscreen.monitor .EQ. $MONO ) THEN
                dummy = setvideomode( $ERESNOCOLOR )
            ELSE
                dummy = setvideomode( $ERESCOLOR )
            END IF
         CASE( $VGA, $OVGA, $MCGA )
            dummy = setvideomode( $VRES2COLOR )
         CASE( $HGC )
            dummy = setvideomode ( $HERCMONO )
         CASE DEFAULT
            dummy = 0
      END SELECT

      IF( dummy .EQ. 0 ) STOP 'Error:  cannot set graphics mode'

C
C     Determine the minimum and maximum dimensions.
C
      CALL getvideoconfig( myscreen )
      maxx = myscreen.numxpixels - 1
      maxy = myscreen.numypixels - 1
      END

     Подпрограмм сначала вызывает getvideoconfig  и  передает  ей
адрес  myscreen  структуры  videoconfig.  В структуре videoconfig
элемент  с  именем  adapter  будет  содержать  тип  используемого


                               272



адаптера.  Используя эту информацию и блок SELECT CASE, программа
устанавливает соответствующий графический режим.

     Для того, чтобы определить разрешение выбранного  программой
видеорежима,  вам  надо  передать процедуре getvideoconfig эту же
структуру videoconfig:

      CALL getvideoconfig( myscreen )
      maxx = myscreen.numxpixels - 1
      maxy = myscreen.numypixels - 1

     Если ваш компьютер использует  плату  EGA,  то  подпрограмма
graphicsmode      устанавливает      видеорежим     $ERESNOCOLOR.
Горизонтальный размер экрана 640 пикселов, а вертикальный  -  350
пикселов.   Два  оператора  присваивания  передают  эти значения,
уменьшенные  на  1,  переменным  maxx  и  maxy.    Горизонтальное
разрешение  равно  640,  но  пикселы  нумеруются  от  0  до  639.
Поэтому, переменная maxx - наивысший доступный  номер  пиксела  -
должна быть на 1 меньше полного числа пикселов:

      myscreen.numxpixels - 1

     Две  небольшие  функции   осуществляют   преобразование   из
воображаемого  экрана  1000x1000  пикселов  в  любой  действующий
видеорежим.  Программа считает, что воображаемый экран  имеет  по
1000  пикселов  в каждом направлении.  Для того, чтобы нарисовать
точки на экране, функции newx  и  newy  вычисляют  физические  (в
пикселах) координаты каждой точки следующим образом:

CC  NEWX - Эта функция находит новые x-координаты.

      INTEGER*2 FUNCTION newx( xcoord )

      INTEGER*2 xcoord, maxx, maxy
      REAL*4    tempx
      COMMON    maxx, maxy

      tempx = maxx / 1000.0
      tempx = xcoord * tempx + 0.5
      newx  = tempx 
      END

CC  NEWY - Эта функция находит новые y-координаты.

      INTEGER*2 FUNCTION newy( ycoord )

      INTEGER*2 ycoord, maxx, maxy
      REAL*4    tempy
      COMMON    maxx, maxy



                               273



      tempy = maxy / 1000.0
      tempy = ycoord * tempy + 0.5
      newy  = tempy
      END


     9.1.3.2  РИСОВАНИЕ ЛИНИЙ НА ЭКРАНЕ

     Затем программа SINE  вызывает  подпрограмму  drawlines.   В
соответствии  со  своим  именем эта подпрограмма рисует на экране
несколько линий.  В частности, на экране рисуются  прямоугольник,
отображающий внешние габариты экрана, и три горизонтальные линии,
делящие его на четыре части.

CC  DRAWLINES - Эта подпрограмма рисует прямоугольник и
CC              несколько линий.

      SUBROUTINE drawlines()

      INCLUDE  'FGRAPH.FD'

      EXTERNAL         newx,newy
      INTEGER*2        dummy, newx, newy, maxx, maxy
      RECORD /xycoord/ xy
      COMMON           maxx, maxy

C
C     Рисование прямоугольника.
C
      dummy = rectangle( $GBORDER, 0, 0, maxx, maxy )
      CALL setvieworg( 0, newy( INT2( 500 ) ), xy )
C
C     Рисование линий.
C
      CALL    moveto( 0, 0, xy )
      dummy = lineto( newx( INT2( 1000 ) ), 0 )
      CALL    setlinestyle( #AA3C )
      CALL    moveto( 0, newy( INT2( -250 ) ), xy )
      dummy = lineto( newx( INT2( 1000 ) ), newy( INT2( -250 ) ) )
      CALL    setlinestyle( #8888 )
      CALL    moveto( 0, newy( INT2( 250 ) ), xy )
      dummy = lineto( newx( INT2( 1000 ) ), newy( INT2( 250 ) ) )
      END

     Первым аргументом к  подпрограмме,  рисующей  прямоугольник,
является "флаг заполнения", который может быть равен $GBORDER или
$GFILLINTERIOR.  В данном случае используется $GBORDER  (рисуются
только  границы  с текущим типом линий).  В случае $GFILLINTERIOR
рисуется сплошной прямоугольник  (заполненный  текущим  цветом  и
рисунком   заполнения).    Выбор   цвета   и  рисунка  заполнения


                               274



обсуждается далее в этой главе (см. таблицы 9.1-9.3).

     Вторым и третьим  аргументами  являются  x-  и  y-координаты
верхнего   левого  угла  прямоугольника.   Четвертым  и  пятым  -
координаты противоположного (нижнего  правого)  угла.   Поскольку
координатами  двух  углов  являются (0,0) и (maxx,maxy), то вызов
rectangle "обрамляет" экран:

      dummy = rectangle( $GBORDER, 0, 0, maxx, maxy )

     Создавайте пунктирные линии с помощью setlinestyle.

     Процедура setlinestyle изменяет тип  линий  от  сплошного  к
пунктирному.    Последовательность   из   16  бит  описывает  для
процедуры рисунок линии.  "1" представляет сплошную часть  линии,
а  "0"  -  пустую.   Таким образом, для компьютера сплошная линия
описывается как 1111 1111  1111  1111.   Пунктирная  линия  может
выглядеть как 1111 1111 0000 0000 (длинный пунктир) или 1111 0000
1111 0000  (короткий  пунктир).   Вы  можете  использовать  любую
комбинацию  из  1  и  0.   16-битовое  двоичное  число может быть
представлено и в шестнадцатиричном, и в десятичном виде.  Ниже, в
примере,   шестнадцатиричная   константа  #AA3C  равна  двоичному
значению 1010 1010 0011 1100.  С  тем  же  успехом  вы  могли  бы
использовать в качестве аргумента десятичное значение 43580.

     Для того чтобы рисовать линии, установите сначала тип линий.
Затем  с  помощью  процедуры  moveto  установите  начальную точку
рисования и с помощью lineto проведите линию в точку с  заданными
координатами.  В программе SINE используется, например, следующий
фрагмент:

      CALL    setlinestyle( #AA3C )
      CALL    moveto( 0, newy( INT2( -250 ) ), xy )
      dummy = lineto( newx( INT2( 1000 ) ),
     +                newy( INT2( -250 ) ) )

     Процедура  moveto  позиционирует   воображаемый   пиксельный
курсор в нужное место на экране, а процедура lineto рисует линию.
Отрицательное значение  -250  может  показаться  недействительной
координатой  экрана,  но  заметьте,  что программа ранее вызывала
setvieworg и изменила координатную систему  окна  просмотра  так,
что координата y может меняться от -500 в верхней части экрана до
+500 в нижней части.   Возможно,  это  противоречит  интуитивному
представлению,   но  показывает  способность  процедуры  изменять
координаты окна просмотра на любые  размерности  или  ориентацию.
(В   разделе  9.3.2.1  окна  просмотра  (viewports)  и  процедура
setvieworg описаны более подробно).





                               275



     9.1.3.3  РИСОВАНИЕ СИНУСОИДЫ

     После рисования осей и внешней рамки программа  SINE  готова
рисовать  синусоиду.  Подпрограмма sinewave вычисляет позиции x и
y для двух циклов синусоиды и рисует их на экране:

CC  SINEWAVE - Эта подпрограмма вычисляет и рисует синусоиду.

      SUBROUTINE sinewave()

      INCLUDE  'FGRAPH.FD'

      INTEGER*2        dummy, newx, newy, locx, locy, i
      DOUBLE PRECISION rad, PI
      EXTERNAL         newx, newy

      PARAMETER        ( PI = 3.14159 )

C
C     Вычисляет каждую позицию и отображает ее на экране.
C
      DO i = 0, 999, 3
         rad   = -SIN( PI * i / 250.0 )
         locx  = newx( i )
         locy  = newy( INT2( rad * 250.0 ) )
         dummy = setpixel( locx, locy )
      END DO
      END

     Процедура setpixel принимает два параметра  locx  и  locy  и
рисует пиксел в этой позиции.


     9.1.3.4  ДОБАВЛЕНИЕ ФОРМ

     После   рисования   синусоиды   программа   SINE    вызывает
подпрограмму  drawshapes  для  того, чтобы поместить на экран два
прямоугольника и два эллипса.   Флаг  заполнения  меняется  между
$GBORDER и $GFILLINTERIOR.

CC  DRAWSHAPES - Эта подпрограмма рисует два прямоугольника
CC               и два эллипса.

      SUBROUTINE drawshapes()

      INCLUDE  'FGRAPH.FD'

      EXTERNAL  newx, newy
      INTEGER*2 dummy, newx, newy



                               276



C
C     Создание рисунков (масок) заполнения.
C
      INTEGER*1 diagmask(8),  linemask(8) 
      DATA diagmask / #93, #C9, #64, #B2, #59, #2C, #96, #4B /
      DATA linemask / #FF, #00, #7F, #FE, #00, #00, #00, #CC /
C 
C     Рисование прямоугольников.
C
      CALL setlinestyle( #FFFF )
      CALL setfillmask( diagmask )
      dummy = rectangle( $GBORDER,
     +                  newx( INT2( 50  ) ), newy(INT2(-325) ),
     +                  newx( INT2( 200 ) ), newy(INT2(-425) ) )
      dummy = rectangle( $GFILLINTERIOR,
     +                  newx( INT2( 550 ) ), newy(INT2(-325) ),
     +                  newx( INT2( 700 ) ), newy(INT2(-425) ) )
C
C     Рисование эллипсов.
C
      CALL setfillmask( linemask )
      dummy = ellipse( $GBORDER,
     +                newx( INT2( 50  ) ), newy( INT2( 325 ) ),
     +                newx( INT2( 200 ) ), newy( INT2( 425 ) ) )
      dummy = ellipse( $GFILLINTERIOR,
     +                newx( INT2( 550 ) ), newy( INT2( 325 ) ),
     +                newx( INT2( 700 ) ), newy( INT2( 425 ) ) )

      END

     Обратите  внимание,   что   setlinestyle   переустанавливает
рисунок  линий  на  сплошной.   Если  эту  процедуру опустить, то
первый прямоугольник будет нарисован пунктирами, а  не  сплошными
линиями.

     Процедура  ellipse  рисует  эллипс,   используя   такие   же
параметры, как и процедура rectangle, т.е.  флаг заполнения и два
угла ограничивающего прямоугольника.

     Флаг  $GFILLINTERIOR  заполняет   форму   текущим   рисунком
заполнения.   Для  того, чтобы создать рисунок, вам надо передать
процедуре setfillmask адрес восьмибайтового  массива  беззнаковых
байт.   После  этого diagmask инициируется рисунком, показанным в
таблице 9.1.








                               277



Таблица 9.1  Рисунки заполнения
-------------------------------------------------------
             Битовая картина        Значение в diagmask
-------------------------------------------------------
Номер бита   7 6 5 4 3 2 1 0
-------------------------------------------------------
             1 0 0 1 0 0 1 1        diagmask(0) = #93
             1 1 0 0 1 0 0 1        diagmask(1) = #C9
             0 1 1 0 0 1 0 0        diagmask(2) = #64
             1 0 1 1 0 0 1 0        diagmask(3) = #B2
             0 1 0 1 1 0 0 1        diagmask(4) = #59
             0 0 1 0 1 1 0 0        diagmask(5) = #2C
             1 0 0 1 0 1 1 0        diagmask(6) = #96
             0 1 0 0 1 0 1 1        diagmask(7) = #4B
-------------------------------------------------------


     9.1.3.5  ВЫХОД ИЗ ГРАФИЧЕСКОГО РЕЖИМА

     Последняя подпрограмма,  вызываемая  программой  SINE,  ждет
нажатия  клавиши  ENTER, после чего устанавливает экран обратно в
нормальный режим:

CC  ENDPROGRAM - Эта подпрограмма ждет нажатия клавиши ENTER и
CC  перед выходом устанавливает экран в первоначальный режим.

      SUBROUTINE endprogram()

      INCLUDE  'FGRAPH.FD'
      INTEGER*2  dummy

      READ (*,*)                       ! ждет нажатия ENTER
      dummy = setvideomode( $DEFAULTMODE )
      END

     Обратите внимание, что возврат экрана в первоначальный режим
является   важным  шагом  в  любой  графической  программе.   Это
позволит предотвратить любые возможные  неприятности  для  других
программ, использующих графику на этом же экране.


     9.2  ИСПОЛЬЗОВАНИЕ ЦВЕТА

     Графическая  библиотека  MSФортрана   поддерживает   цветную
графику  CGA,  EGA  и  VGA.   Цвет  может  сделать  вашу  графику
разнообразной и эффектной, но  он  должен  соответствовать  вашей
задаче.

     Цветная   графика   может   быть   лучше   черно-белой,   но
использование   цвета   требует   компромисса.   Если  вам  нужно


                               278



максимальное   количество   цветов,   то   для   этого   придется
пожертвовать  разрешением  -  вы  будете иметь разрешение 320x200
пикселов.  Например,  программа COLOR (см. раздел 9.2.1.5) всегда
выбирает наивысшее возможное разрешение и при этом всегда создает
экран с разрешением только на 320X200 пикселов.


     9.2.1  ЦВЕТНЫЕ ГРАФИЧЕСКИЕ РЕЖИМЫ

     Графическая   библиотека    MSФортрана    имеет    отдельные
графические  режимы  для  всех  адаптеров  CGA, EGA и VGA.  Кроме
того, аппаратные средства с высшим разрешением могут поддерживать
режимы  с  низшим разрешением.  То есть, адаптеры EGA и VGA могут
поддерживать режимы CGA, а адаптер VGA может  поддерживать  также
режимы   EGA.   Все  аппаратные  средства,  которые  поддерживают
цветные  графические  режимы,  поддерживают   также   черно-белые
режимы.


     9.2.1.1  ЦВЕТНЫЕ ГРАФИЧЕСКИЕ РЕЖИМЫ CGA

     Цветные  графические  режимы  $MRES4COLOR   и   $MRESNOCOLOR
отображают  четыре  цвета, выбираемые из четырех предопределенных
цветовых палитр.  Они выводят эти цвета на заднем  фоне,  который
может  иметь один из 16 доступных цветов.  В адаптере CGA палитра
передних цветов предопределена и не может быть  изменена.   Номер
каждой палитры является целым числом, как показано в таблице 9.2.

Таблица 9.2.  Доступные цвета CGA
------------------------------------------------------------
                           Индексы цветов
Номер        -----------------------------------------------
палитры      1                 2                3
------------------------------------------------------------
0            зеленый           красный          коричневый
1            голубой           фиолетовый       светло-серый
2            светло-серый      ярко-красный     желтый
3            светло-голубой    малиновый        белый
------------------------------------------------------------

     На  черно-белых  мониторах  графический  режим  $MRESNOCOLOR
создает палитру, содержащую различные оттенки серого.  На цветных
дисплеях в этом режиме доступны только две палитры  цветов.   Для
выбора   одной   из   них   вы   можете   использовать  процедуру
selectpalette.  В таблице 9.3 показаны цветовые индексы и палитры
режима $MRESNOCOLOR.






                               279



Таблица 9.3.  Цвета CGA: Режим $MRESNOCOLOR.
------------------------------------------------------------
                           Индексы цветов
Номер        -----------------------------------------------
палитры      1                 2                3
------------------------------------------------------------
0            голубой           красный          светло-серый
1            светло-голубой    ярко-красный     белый
------------------------------------------------------------

     Процедура  selectpalette  работает  только  с   графическими
режимами  $MRES4COLOR  и  $MRESNOCOLOR.   Для изменения палитры в
других графических режимах пользуйтесь функциями  remappalette  и
remapallpalette.

     Показанная   ниже   программа    устанавливает    видеорежим
$MRES4COLOR  и  затем  в цикле работает с различными комбинациями
цветов и палитр.  Она работает на компьютерах с платами CGA, EGA,
MCGA или VGA и с цветным монитором.

CC  CGA.FOR - демонстрирует цвета CGA.

      INCLUDE  'FGRAPH.FI'
      INCLUDE  'FGRAPH.FD'

      INTEGER*2 dummy2, i, j, k
      INTEGER*4 dummy4
      INTEGER*4 bkcolor(8) /
     +          $BLACK, $BLUE   , $GREEN, $CYAN,
     +          $RED  , $MAGENTA, $BROWN, $WHITE /

      CHARACTER*7  bkcolorname(8) /
     +             'BLACK', 'BLUE'   , 'GREEN', 'CYAN',
     +             'RED'  , 'MAGENTA', 'BROWN', 'WHITE' /

      RECORD / rccoord / curpos

      IF( setvideomode( $MRES4COLOR ) .EQ. 0 )
     +    STOP 'Error:  cannot set CGA graphics mode'
 
      DO i = 0, 3
         dummy2 = selectpalette( i )
         DO k = 1, 8
            dummy4 = setbkcolor( bkcolor(k) )
            DO j = 0, 3
               CALL settextposition( 1, 1, curpos )
               WRITE (*, 9000) bkcolorname(k), i, j
               dummy2 = setcolor( INT4( j ) )
               dummy2 = rectangle( $GFILLINTERIOR,
     +                             160, 100, 320, 200 )


                               280



               READ (*,*)     ! ждет нажатия клавиши ENTER
            END DO
         END DO
      END DO
      dummy2 = setvideomode( $DEFAULTMODE )

 9000 FORMAT( ' background color: ', A / ' palette:', I3 /
     +        ' color:  ', I3 / )

      END


     9.2.1.2  СМЕШИВАНИЕ ЦВЕТОВ

     В начале этой главы мы упоминали о разнице  между  индексами
цветов и значениями цветов.  Представьте себе аналогию:  художник
имеет 64 тюбика краски и палитру, на  которой  может  поместиться
только  16  цветов.   Картина,  созданная  в этих условиях, может
содержать  только  16  цветов  (выбранных  из   64).    Один   из
графических  режимов  EGA  ($ERESCOLOR)  такой  же:   16 индексов
цветов, выбранных из 64 значений цветов.  Индексы  цветов  иногда
называют "атрибутами цвета" или "значениями пикселов", а значения
цветов иногда называют "действительными цветами".

     VGA допускает широчайшую  гамму  цветов:   262  144  (256K).
Палитра   VGA,   в  зависимости  от  графического  режима,  может
содержать 2, 16 или 256 индексов  цветов.   При  выборе  значения
цвета вы задаете уровень интенсивности в диапазоне от 0 до 63 для
каждого из значений красного, зеленого и синего цветов.   Длинное
целое  число,  которое определяет значение цвета, содержит четыре
байта (32 бита):

MSB                             LSB
zzzzzzzz zzBBBBBB zzGGGGGG zzRRRRRR

где z означает нуль, а B, G и R представляют битовые значения для
интенсивностей синего, зеленого и красного цветов.  Самый старший
байт (MSB) должен содержать только  нули.   Два  старших  бита  в
остальных  трех  байтах  также  должны  быть нулевыми.  Для того,
чтобы получить ярко-красный (розовый), оставим весь красный  цвет
и добавим немного зеленого и синего:

00000000 00100000 00100000 00111111

     В шестнадцатиричном обозначении это число  равно  #0020203F.
Вы могли бы также использовать функцию

RGB (r,g,b) = (#3f3f3f.AND.(ISHFT(b,16).OR.ISHFT(g,8).OR.r))

где r, g и b ранее описаны как целые.


                               281



     Вы  можете  передавать  этому  макросу  десятичные  значения
(более  обычные  и  понятные  для  большинства).   Помните, что 1
(двоичное 00000001) представляет наименьшую интенсивность  цвета,
а    63    (двоичное    00111111)    соответствует   максимальной
интенсивности.   Для   того,   чтобы   получить   чистый   желтый
(100-процентный  красный плюс 100-процентный зеленый) и присвоить
его переменной y1, используется строка:

      y1 = RGB( 63, 63, 0)

     Для получения белого включаются все цвета:

      RGB( 63, 63, 63)

     Для черного, наоборот, все цвета убираются:

      RGB( 0, 0, 0)

     Смешивание цветов в режимах EGA такое  же,  как  в  VGA,  за
исключением  того,  что здесь меньше интенсивностей для красного,
зеленого и синего  компонентов.   В  режимах,  которые  имеют  64
цвета,  значения R,G и B занимают только два бита и поэтому могут
изменяться от 0 до 3.  Целое число, которое определяет цвет  RGB,
выглядит следующим образом:

MSB                             LSB
zzzzzzzz zzBB???? zzGG???? zzRR????

     Биты, помеченные z, должны быть нулями, а  биты,  помеченные
знаком  вопроса,  могут  иметь  любое значение (хотя для удобства
чтения  лучше  использовать  нули).   Для  формирования   чистого
красного    цвета    используется   шестнадцатиричная   константа
#00000030.   Для  голубого  (синий  плюс  зеленый)  -  #00303000.
Оператор функции RGB, определенный выше, легко модифицируется для
мониторов EGA:

      EGARGB (r,g,b) = ( #303030 .AND.1 ( ISHFT( b,20 )
     + .OR.ISHFT( g,12 ).OR.ISHFT( r,4 ) ) )

     Значения, передаваемые этой  функции,  должны  изменяться  в
диапазоне  от  0  до 3, а не от 0 до 63.  Например, для получения
чистого красного следует писать

      r1 = EGARGB( 0, 0, 3)


     9.2.1.3  ЦВЕТНЫЕ ГРАФИЧЕСКИЕ РЕЖИМЫ EGA

     Видеорежимы $MRES16COLOR, $HRES16COLOR или $ERESCOLOR  лучше
всего  отображают  цветную  графику  с адаптером EGA.  Режимы CGA


                               282



также поддерживаются на адаптере EGA, но с меньшим разрешением  и
меньшими цветовыми возможностями.

     Для присваивания цветовому  индексу  нового  значения  цвета
используется  функция  remappalette.   Например, при первом вводе
графического режима EGA индекс  цвета  1  равен  синему  значению
цвета.   Чтобы  присвоить  индексу  цвета  1 чистый красный цвет,
можно использовать следующую строку:

      dummy4 = remappalette( 1, #000030 )

     Можно  использовать  также  символическую  константу   $RED,
которая определена в файле FGRAPH.FI:

      dummy4 = remappalette( 1, $RED )

     После вызова этой  процедуры  все  объекты,  нарисованные  с
цветовым индексом 1, немедленно станут из голубых красными.

     Для графики EGA первое значение это целое в диапазоне  0-15,
а второе значение это INTEGER*4, определенное как смесь красного,
зеленого и синего.

     Процедура  remapallpalette  изменяет  все   индексы   цветов
одновременно.   Вы  передаете  ей массив индексов цветов.  Первое
значение цвета в списке  становится  новым  цветом,  связанным  с
индексом  цвета 0, второе становится связанным с индексом цвета 1
и т.д.

     Аргумент,  передаваемый  процедурам,  которые  устанавливают
цвета  (например,  setcolor),  это  индекс  для  цвета  в текущей
палитре.  В обычной текстовой палитре индекс 1 относится к синему
цвету.   Если  палитра  меняется,  то  номер  индекса цвета также
меняется.  В результате цвет, создаваемый данным индексом,  также
меняется.   Если вы создаете изображение в одной палитре, а затем
меняете ее, то индексы  цветов  будут  относиться  уже  к  другим
цветам  и все изображение изменит цвет.  Число имеющихся индексов
цветов  зависит   от   числа   цветов,   поддерживаемых   текущим
видеорежимом.

     Процедуры remappalette и remapallpalette  работают  во  всех
режимах, но только с платами EGA, MCGA или VGA.  Эти процедуры не
срабатывают и возвращают -1, если вы попытаетесь изменить палитру
без необходимых аппаратных средств.

     Следующая   программа   рисует   прямоугольник   с   красным
заполнением.   В  EGA-палитре,  действующей  по умолчанию, индекс
цвета 4 является красным.  В  программе  EGA  этот  индекс  цвета
меняется на $BLUE.



                               283



CC  EGA.FOR - демонстрирует использование палитр EGA.

      INCLUDE  'FGRAPH.FI'
      INCLUDE  'FGRAPH.FD'

      INTEGER*2        dummy2
      INTEGER*4        dummy4
      RECORD /xycoord/ xy

      dummy2 = setvideomode( $ERESCOLOR )
      dummy2 = setcolor( 4 )
      dummy2 = rectangle( $GFILLINTERIOR, 50, 50, 200, 200 )
C
C     Выводит сообщение в обычной палитре.
C
      CALL settextposition( 1, 1, xy )
      CALL outtext( 'Normal palette   ' )
      CALL outtext( 'Press ENTER to continue' )
      READ (*,*)          ! ждет нажатия клавиши ENTER
      dummy4 = remappalette( 4, $BLUE )
C
C     Выводит сообщение в новой палитре.
C
      CALL settextposition( 1, 1, xy )
      CALL outtext( 'Remapped palette ' )
      CALL outtext( 'Press ENTER to continue' )
      READ (*,*)
      dummy4 = remappalette( 4, $RED )
C
C     Выводит сообщение в первоначальной палитре.
C
      CALL settextposition( 1, 1, xy )
      CALL outtext( 'Restored palette ' )
      CALL outtext( 'Press ENTER to clear the screen' )
      READ (*,*)
C
C     Возврат в первоначальный видеорежим.
C
      CALL clearscreen( $GCLEARSCREEN )
      dummy2 = setvideomode( $DEFAULTMODE )
      END


     9.2.1.4  ЦВЕТНЫЕ ГРАФИЧЕСКИЕ РЕЖИМЫ VGA

     Плата VGA  добавляет  в  ваш  репертуар  графические  режимы
$VRES2COLOR,   $VRES16COLOR   и  $MRES256COLOR.   С  этой  платой
доступны режимы EGA и CGA.

     Цветные графические режимы VGA работают со значениями цветов


                               284



в   диапазоне   262144  (256K).   Графический  режим  $VRES2COLOR
отображает 2 цвета, графический режим $VRES16COLOR - 16 цветов, а
графический  режим $MRES256COLOR - 256 цветов из доступных цветов
VGA.

     Процедура  remappalette  меняет  индекс  цвета  на  заданное
значение  цвета.  Следующая функция переотображает индекс цвета 1
на значение цвета, заданное символической константой $RED.  После
выполнения этого оператора все, что было нарисовано синим, станет
красным:

dummy4 = remappalette( 1, $RED ) ! присваивает индекс цвета 1
                                 ! красному в VGA

     Процедура remapallpalette изменяет один или  более  индексов
цветов   одновременно.    Аргумент  процедуры  является  массивом
цветовых индексов, который  определяет  переотображение.   Первый
номер  цвета  в  списке  становится  новым  цветом,  связанным  с
индексом цвета 0, второй - с индексом цвета 1 и т.д.

     Символические константы  (имена)  для  умалчиваемых  номеров
цветов  составлены так, что переопределение цветов VGA совместимо
с  существующим  в  EGA.   Имена  самоописательны:   номера   для
черного,    светложелтого    и   красного   цветов   представлены
символическими константами $BLACK, $LIGHTYELLOW и $RED.

     Все  режимы  VGA  работают  с  любым  монитором   VGA.    На
совместимых  монохромных мониторах цвета отображаются как оттенки
серого цвета.

     Программа HORIZON иллюстрирует цветовые эффекты при  наличии
полного диапазона в 256 цветов платы VGA:

CC  HORIZON.FOR - иллюстрирует графику VGA с циклом
CC                по 256 цветам.

      INCLUDE  'FGRAPH.FI'
      INCLUDE  'FGRAPH.FD'

      INTEGER*2   MYRED, MYBLU, MYWHT, STEP
      PARAMETER ( MYRED = #000003FF )
      PARAMETER ( MYBLU = #003F0000 )
      PARAMETER ( MYWHT = #003F3F3F )
      PARAMETER ( STEP  = 21 )

      INTEGER*2        dummy, i, j
      INTEGER*4        rainbow(0:511), col, ngray
      RECORD /rccoord/ curpos
      RECORD /xycoord/ xy



                               285



C
C     Проверка наличия адаптера с 256 цветами.
C
      IF( setvideomode( $MRES256COLOR ) .EQ. 0 )
     +    STOP 'This program requires a VGA card.' 
C
C     Создание цветов.
C
      DO col = 0, 63
         ngray = (col .OR. ISHFT( col,8 )) .OR. ISHFT( col,16 )
         rainbow(col)             = MYBLU .AND. ngray
         rainbow(col + 256)       = rainbow(col)
         rainbow(col + 64)        = MYBLU .OR. ngray
         rainbow(col + 64 + 256)  = rainbow(col + 64)
         rainbow(col + 128)       = MYRED .OR.
     +                            ( MYWHT .AND. .NOT. ngray )
         rainbow(col + 128 + 256) = rainbow( 64 + 128)
         rainbow(col + 192)       = MYRED .AND. .NOT. ngray
         rainbow(col + 192 + 256) = rainbow(col + 192)
      END DO
      CALL setvieworg( 160, 85, xy )
C
C     Рисование различных форм на экране.
C
      DO i = 0, 254
         dummy = setcolor( INT4( 255 - i ) )
         CALL    moveto(  i, i - 255, xy )
         dummy = lineto( -i, 255 - i )
         CALL    moveto( -i, i - 255, xy )
         dummy = lineto(  i, 255 - i )
         dummy = ellipse( $GBORDER, -i, -i / 2, i, i / 2 )
      END DO
C
C     Цикл по цветам.
C
      i = 0
      DO j = 1, 256
         dummy = remapallpalette( rainbow(i) )
         i     = MOD( i + STEP, 256 )
      END DO

      dummy = settextcolor( 15 )
      CALL settextposition( 25, 1, curpos )
      CALL outtext( 'Press ENTER to exit' )
      READ (*,*)
      dummy = setvideomode( $DEFAULTMODE ) 
      END





                               286



     9.2.1.5  ПРОГРАММЫ ЦВЕТНОЙ ГРАФИКИ (COLOR и GRAPHIC)

     Программа   COLOR   устанавливает   режим   с   максимальным
количеством цветов, возможным для имеющихся аппаратных средств:

CC  COLOR.FOR - устанавливает режим со средним разрешением
CC              и максимальным количеством цветов.

      INCLUDE  'FGRAPH.FI'
      INCLUDE  'FGRAPH.FD'

      INTEGER*2            dummy
      RECORD /videoconfig/ vc

C
C     Устанавливает режим с максимальным количеством цветов.
C
      IF( setvideomode( $MAXCOLORMODE ) .EQ. 0 )
     +    STOP 'Error:  no color graphics capability'
      CALL getvideoconfig( vc )

      WRITE (*, 9000) vc.numcolors, vc.numxpixels, vc.numypixels
      READ (*,*)       ! ждет нажатия клавиши ENTER
      CALL clearscreen( $GCLEARSCREEN )
      dummy = setvideomode( $DEFAULTMODE )

 9000 FORMAT(' available colors: ', I5/ ' horizontal pixels:',I5/
     +       ' vertical pixels:  ', I5 )

      END

     Процедура clearscreen, используемая здесь, очищает  экран  в
любом   видеорежиме.   Для  того,  чтобы  увидеть  все  возможные
видеорежимы, выполните показанную ниже программу GRAPHIC.

CC  GRAPHIC.FOR - отображает все графические режимы

      INCLUDE  'FGRAPH.FI'
      INCLUDE  'FGRAPH.FD'

      INTEGER*2 key
      EXTERNAL  printmenu
      EXTERNAL  showmode

      CALL printmenu( key )
      DO WHILE( key .NE. 0 )
         CALL showmode( key )
      END DO
      END



                               287



      SUBROUTINE printmenu( key )

      INCLUDE  'FGRAPH.FD'

      INTEGER*2  dummy, key

      key = -1
      DO WHILE( (key .LT. 0)  .OR.  (key .GT. 12) )
         dummy = setvideomode( $DEFAULTMODE )
         WRITE (*, 9000)
         READ (*,*) key
      END DO

 9000 FORMAT( ' Please ENTER a graphics mode.' /
     +        ' (To exit, ENTER 0.)' /// '  0 Exit'  /
     +        '  1 MRES4COLOR'   / '  2 MRESNOCOLOR' / 
     +        '  3 HRESBW'       / '  4 HERCMONO'    / 
     +        '  5 MRES16COLOR'  / '  6 HRES16COLOR' / 
     +        '  7 ERESNOCOLOR'  / '  8 ERESCOLOR'   / 
     +        '  9 VRES2COLOR'   / ' 10 VRES16COLOR' / 
     +        ' 11 MRES256COLOR' / ' 12 ORESCOLOR'   / )

      END


      SUBROUTINE showmode( which )

      INCLUDE  'FGRAPH.FD'

      INTEGER*2 which, dummy, i, height, width
      INTEGER*2 modes(12) /
     +         $MRES4COLOR , $MRESNOCOLOR , $HRESBW     ,
     +         $HERCMONO   , $MRES16COLOR , $HRES16COLOR, 
     +         $ERESNOCOLOR, $ERESCOLOR   , $VRES2COLOR , 
     +         $VRES16COLOR, $MRES256COLOR, $ORESCOLOR  /

      RECORD /videoconfig/ screen

      IF( setvideomode( modes(which) ) .NE. 0 ) THEN
         CALL getvideoconfig( screen )
         width  = screen.numxpixels / screen.numcolors
         height = screen.numypixels / 2
         DO i = 0, screen.numcolors - 1
            dummy = setcolor( INT4( i ) )
            dummy = rectangle( $GFILLINTERIOR, i * width, 0,
     +                       ( i + 1 ) * width, height )
         END DO
      ELSE
         WRITE (*, 9000)
      END IF


                               288



      READ (*,*)       ! ждет нажатия клавиши ENTER
      dummy = setvideomode( $DEFAULTMODE )
      CALL printmenu( which )

 9000 FORMAT ( ' Video mode is not available.' /
     +         ' Please press ENTER.   ' \ )

      END


     9.2.2  ИСПОЛЬЗОВАНИЕ ЦВЕТНЫХ ТЕКСТОВЫХ ВИДЕОРЕЖИМОВ

     В дисплеях CGA, EGA и  VGA  имеется  два  цветных  текстовых
режима $TEXTC40 и $TEXTC80.  Эти режимы отображают устойчивый или
мигающий текст любого из 16 цветов на любом из 8 цветов фона.

     В текстовом видеорежиме каждый отображаемый  символ  требует
двух   байт   видеопамяти.    Первый   байт  содержит  ASCII-код,
представляющий символ, а второй байт -  атрибут  отображения.   В
цветных  текстовых  режимах  CGA  байт атрибута определяет цвет и
мигание символа.  Доступны 16 цветов:  цвета CGA и действующие по
умолчанию значения цветов EGA и VGA.  Поскольку палитра EGA и VGA
может быть переопределена, то эти значения могут  соответствовать
любому   набору  из  16  цветов  с  соответствующим  отображением
палитры.


     9.2.2.1  ИСПОЛЬЗОВАНИЕ ЦВЕТОВ ТЕКСТА

     Для определения цветов переднего и  заднего  плана  текущего
текстового   режима   используются   процедуры   gettextcolor   и
getbkcolor.  Значения от 0  по  15  представляют  обычные  цвета.
Значения  от  16  по  31 представляют эти же цвета, но с мигающим
текстом.   Для  установки  цветов  переднего  и   заднего   плана
используются процедуры settextcolor и setbkcolor.  Обе используют
один аргумент, определяющий значение цвета для текста, выводимого
процедурой  outtext.  Индексы цветов текстовых режимов определены
в таблице 9.4.














                               289



Таблица 9.4:  Цвета текста
-----------------------------------------------------------------
Номер   Цвет                    Номер   Цвет
-----------------------------------------------------------------
0       черный (black)          8       темно-серый
1       синий (blue)            9       светло-синий
2       зеленый (green)         10      светло-зеленый
3       голубой (cyan)          11      светло-голубой
4       красный (red)           12      светло-красный
5       фиолетовый (magenta)    13      светло-фиолетовый
6       коричневый (brown)      14      светло-коричневый
7       белый (white)           15      светло-белый
-----------------------------------------------------------------

     Процедура  settextposition  используется   для   перемещения
курсора  в  заданные  столбец и строку экрана.  Процедура outtext
печатает текст на экране.


     9.2.2.2  ПРОГРАММА ВЫВОДА ЦВЕТНОГО ТЕКСТА (COLTEXT)

     Следующая программа выводит на экран схему, показывающую все
возможные комбинации цветов текста и фона.

CC  COLTEXT.FOR - выводит цветной текст с различными цветными
CC                или монохромными аттрибутами.

      INCLUDE  'FGRAPH.FI'
      INCLUDE  'FGRAPH.FD'

      INTEGER*2          dummy2, blink, fgd
      INTEGER*4          dummy4, bgd
      CHARACTER*2        str
      RECORD / rccoord / curpos

      CALL clearscreen( $GCLEARSCREEN )
      CALL outtext( 'Text color/monochrome attributes:' )
 
      DO  blink = 0, 16, 16
         DO bgd = 0, 7
            dummy4 = setbkcolor( bgd )
            CALL settextposition( INT2( bgd ) +
     +           (( blink / 16 ) * 9) + 3, 1, curpos ) 
            dummy2 = settextcolor( 15 )
            WRITE (str, '(I2)') bgd
            CALL outtext( 'Back:' // str // '  Fore:' )
C
C           Цикл по 16 цветам текста.
C
            DO fgd = 0, 15


                               290



               dummy2 = settextcolor( fgd + blink )
               WRITE (str, '(I2)') fgd + blink
               CALL outtext( '  ' // str )
            END DO
         END DO
      END DO

      CALL settextposition( 25, 1, curpos )
      CALL outtext( 'Press ENTER to exit' )
      READ (*,*)
      dummy2 = setvideomode( $DEFAULTMODE )
      END


     9.3  СИСТЕМЫ КООРДИНАТ

     В главе 8 "Графическая библиотека MSФортрана"  были  введены
основные  понятия о различных координатных системах, используемых
в графической библиотеке MSФортрана.   Каждая  система  выполняет
определенную задачу и использует координаты, соответствующие этой
задаче.  Текстовые координаты работают со строками  и  столбцами;
физические координаты служат для абсолютных ссылок и как исходная
точка для создания произвольных  мировых  и  экранных  координат.
Графическая  библиотека  MSФортрана предлагает несколько процедур
для преобразования в различные координатные системы.


     9.3.1  ТЕКСТОВЫЕ КООРДИНАТЫ

     Для того, чтобы программа могла  выводить  слово  на  экран,
необходима  система  координат, которая описывает для компилятора
местоположение выводимого текста  на  экране.   Текстовые  режимы
разделяют экран на строки и столбцы (см. рисунок 9.2).

+---------------------------------------------------------------+
|                                                               |
|        +---------------------------------------------+        |
|        |X Строка 1                       Строка 1   X|        |
|        |  Столбец 1                      Столбец 80  |        |
|        |                                             |        |
|        |                                             |        |
|        |                                             |        |
|        |                                             |        |
|        |                                             |        |
|        |  Строка 25                                  |        |
|        |X Столбец 1                                 X|        |
|        +---------------------------------------------+        |
|                                                               |
+---------------------------------------------------------------+
Рисунок 9.2  Текстовые координаты экрана


                               291



     Помните о следующих соглашениях текстовых режимов:

      -  Нумерация начинается с 1.  80-столбцовый экран  содержит
         столбцы 1-80.

      -  Строка всегда указывается перед столбцом.

     Если экран поддерживает текстовый видеорежим с 25 строками и
80  столбцами (как на рис.9.2), то строки нумеруются с 1 по 25, а
столбцы - с 1 по 80.  Процедуры позиционирования текста, например
settextposition,   используют   строки   и   столбцы  в  качестве
координат.


     9.3.2  ГРАФИЧЕСКИЕ КООРДИНАТЫ

     Как  сказано в главе  8 "Графическая библиотека MSФортрана",
существуют  три системы координат для описания положения пикселов
на экране:   физические  координаты,  координаты  окна  просмотра
(viewport) и мировые координаты окна (window).  Системы координат
идентифицируют положение пикселов на экране.  Все они  используют
следующие соглашения:

      -  Нумерация начинается с 0.  Если имеется 640 пикселов, то
         они нумеруются с 0 по 639.

      -  Координата x указывается перед координатой y.

     В разделах 9.3.2.1-9.3.2.3 подробно описаны все координатные
системы.


     9.3.2.1  ФИЗИЧЕСКИЕ КООРДИНАТЫ

     Предположим, что вы написали  программу,  которая  переводит
экран  в графический VGA-режим $VRES16COLOR.  Это даст вам экран,
содержащий  640  горизонтальных  пикселов  и   480   вертикальных
пикселов.   Каждый  отдельный  пиксел определяется его положением
относительно осей x и y, как показано ниже на рисунке 9.3.













                               292



+---------------------------------------------------------------+
|     (0,0)                                         (639,0)     |
|     +---------------------------------------------------+     |
|     |* Начало ------------  x  ---------------------->  |     |
|     | |                                                 |     |
|     | |                                                 |     |
|     | |                                                 |     |
|     | y                                                 |     |
|     |                                                   |     |
|     | |                                                 |     |
|     | |                                                 |     |
|     | V                                                 |     |
|     |*                                                 *|     |
|     +---------------------------------------------------+     |
|     (0,479)                                                   |
+---------------------------------------------------------------+
Рисунок 9.3  Физические координаты экрана

     Верхний левый угол  является  "началом".   Координатами  x,y
начала всегда являются (0,0).

     Физические    координаты    определяют     каждый     пиксел
непосредственно  и  поэтому  являются  целыми  (то есть, экран не
может отображать доли пиксела).  Если вы  используете  переменные
для адресации пикселов, то описывайте их как целые.

     При  первом  вводе  графического  режима,   окно   просмотра
(viewport) или область рисования эквивалентна физическому экрану.
Процедура setvieworg изменяет положение  начала  окна  просмотра.
Вы  передаете ей два целых числа, которые представляют физические
x- и y-координаты экрана для нового начала.  Например,  следующая
строка перемещает начало в точку физического экрана (50,100):

      CALL setvieworg(50, 100)

     Результат показан ниже на рисунке 9.4.
















                               293



+---------------------------------------------------------------+
|     (-50,-100)                                 (589,-100)     |
|     +---------------------------------------------------+     |
|     |*    |---------------  x  ---------------------->  |     |
|     |     |                                             |     |
|     |                                                   |     |
|     |- - -+- - - - - - - - - - - - - - - - - - - - - - -|     |
|     | |    (0,0)                                        |     |
|     | y   |                                             |     |
|     | |                                                 |     |
|     | |   |                                             |     |
|     | |                                                 |     |
|     | V   |                                             |     |
|     |*                                                  |     |
|     +---------------------------------------------------+     |
|     (-50,379)                                                 |
+---------------------------------------------------------------+
Рисунок 9.4  Координаты, измененные setvieworg

     Номера пикселов не  изменились,  но  изменились  координаты,
используемые  для  адресации точек.  Ось x теперь простирается от
-50 до +589, а не от 0 до 639.  Ось y теперь охватывает  значения
от  -100  до +379.  Если вы используете адаптер, отличный от VGA,
то числа меняются, но результат остается тем же.

     Новое начало влияет на все  графические  процедуры,  которые
используют  координаты  окна просмотра, включая процедуры moveto,
lineto,  rectangle,  ellipse,  arc  и  pie.   Например,  если  вы
вызываете  процедуру  rectangle  после  перемещения  начала  окна
просмотра и передаете ей  значения  (0,0)  и  (40,40),  то  левый
верхний угол рисуемого прямоугольника будет смещен на 50 пикселов
от левого края экрана и на 100 пикселов от верхнего края, то есть
не будет располагаться в верхнем левом углу экрана.

     Процедура   setcliprgn   создает   на    экране    невидимую
прямоугольную  область,  которая  называется "область отсечения".
Вы  можете  рисовать  внутри  области   отсечения,   но   попытка
нарисовать  вне  этой  области  потерпит  неудачу  (то  есть, вне
области отсечения ничего рисоваться не будет).

     Умалчиваемая область отсечения  (действующая  по  умолчанию)
занимает  весь  экран.   Графическая  библиотека  игнорирует  все
попытки рисовать вне экрана.

     Изменяйте  область  отсечения   обращением   к   setcliprgn.
Предположим,   например,   что  вы  ввели  графический  CGA-режим
$MRES4COLOR, который имеет разрешение экрана 320 на 200 пикселов.
Если  вы  нарисуете  диагональную  линию  из  точки (0,0) в точку
(319,199), т.е.  из левого верхнего  угла  в  правый  нижний,  то
экран будет выглядеть следующим образом (рис 9.5):


                               294



+---------------------------------------------------------------+
|                                                               |
|      0                                                319     |
|     +---------------------------------------------------+     |
|     |                                                   |     |
|     |                                                   |     |
|     |                                                   |     |
|     |                                                   |     |
|     |                                                   |     |
|     |                                                   |     |
|     |                                                   |     |
|     |                                                   |     |
|     |                                                   |     |
|     |                                                   |     |
|     |                                                   |     |
|     +---------------------------------------------------+     |
|     199                                                       |
|                                                               |
+---------------------------------------------------------------+
Рисунок 9.5  Линия, нарисованная через весь экран

     Предположим, что вы ввели область отсечения

      CALL setcliprgn(10, 10, 309, 189)

     С этой областью отсечения та же команда lineto  нарисует  на
экране  линию,  показанную  на  рисунке  9.6.   Пунктирная  линия
обозначает внешние границы области отсечения и в действительности
на экране не рисуется.

+---------------------------------------------------------------+
|                                                               |
|     0                   |Область отсечения            319     |
|     +-------------------|-------------------------------+     |
|     |                   V                               |     |
|     |   + - - - - - - - - - - - - - - - - - - - - - +   |     |
|     |                                                   |     |
|     |   |                                           |   |     |
|     |                                                   |     |
|     |   |                                           |   |     |
|     |                                                   |     |
|     |   |                                           |   |     |
|     |                                                   |     |
|     |   + - - - - - - - - - - - - - - - - - - - - - +   |     |
|     |                                                   |     |
|     +---------------------------------------------------+     |
|     199                                                       |
|                                                               |
+---------------------------------------------------------------+
Рисунок 9.6  Линия, нарисованная в области отсечения


                               295



     9.3.2.2  КООРДИНАТЫ ОКНА ПРОСМОТРА

     Окно просмотра (viewport) это область на экране,  где  вы  в
действительности рисуете.  Координаты окна просмотра представляют
пикселы  в  текущем  окне   просмотра.    Процедура   setviewport
устанавливает   границы  окна  просмотра  на  физическом  экране.
Стандартное окно просмотра имеет две отличительных особенности:

      -  Начало окна просмотра это верхний левый угол.

      -  Действующая по умолчанию область отсечения  совпадает  с
         внешними границами окна просмотра.

     Процедура  setviewport  имеет  такой   же   результат,   как
процедуры setvieworg и setcliprgn совместно.

     На рисунке  9.5  область  отсечения  позволяет  использовать
lineto  для  рисования  линии,  которая соединяет противоположные
углы  прямоугольника.   На  рисунке  9.6  использована   эта   же
процедура lineto, но меньшая область отсечения препятствует линии
соединить эти углы.

     Обратите внимание, что, если вы желаете использовать окно  в
мировых  координатах  (window),  то  должны  сначала  задать окно
просмотра.   Пример   программы   REALG.FOR   в   разделе   9.3.3
показывает,  как  создать  несколько  множеств мировых координат,
каждое с отдельным окном просмотра на одном экране.


     9.3.2.3  МИРОВЫЕ КООРДИНАТЫ

     Функции, которые  адресуются  к  координатам  на  физическом
экране, и внутри окна просмотра, требуют целых значений.  Однако,
во  многих  приложениях  вам  может   понадобиться   использовать
плавающие   значения.    Процедура   setwindow  дает  возможность
масштабировать экран практически к любому размеру.   Кроме  того,
функции,  работающие  с  окном  в  мировых  координатах,  требуют
значений с двойной точностью.

     Окно  в  мировых  координатах  (window)  "отображается"   на
текущее   окно  просмотра.   Графика,  рисуемая  в  окне  мировых
координат, рисуется в области экрана, определяемой текущим  окном
просмотра.

     Например, вам надо создать  график  по  12  месяцам  средней
венерианской  температуры  в диапазоне от -50 до +450.  Это можно
сделать,  определив  в  программе  следующее   окно   в   мировых
координатах:

      dummy = setwindow(.TRUE., 1.0, -50.0, 12.0, 450.0)


                               296



     Первый аргумент это флаг  инвертирования,  который  помещает
наименьшее  значение  y  в  нижний  левый  угол.   Далее  следуют
минимальные и максимальные x- и y-координаты; точка  помечает  их
как  плавающие  значения.   Новая  организация экрана показана на
рисунке 9.7.

+---------------------------------------------------------------+
|                                                               |
|     (1.0,450.0)                              (12.0,450.0)     |
|     +---------------------------------------------------+     |
|     |* - - - - - - - - - - - - x - - - - - - - - - - >  |     |
|     |  |                                                |     |
|     |  |                                                |     |
|     |  |                                                |     |
|     |  |                                                |     |
|     |  y                                                |     |
|     |  |                                                |     |
|     |  |                                                |     |
|     |  |                                                |     |
|     |  |                                                |     |
|     |* V                                                |     |
|     +---------------------------------------------------+     |
|     (1.0,-50.0)                              (12.0,-50.0)     |
|                                                               |
+---------------------------------------------------------------+
Рисунок 9.7  Мировые координаты окна

     Обратите внимание, что январь и декабрь рисуются в  левом  и
правом  углах  экрана.   В  приложениях,  подобных этому, было бы
лучше нумеровать ось x от 0.0 до 13.0, чтобы обеспечить некоторое
дополнительное пространство.

     Если вы  после  этого  рисуете  точку  с  помощью  процедуры
setpixel_w  или  линию  с помощью процедуры lineto_w, то значения
автоматически масштабируются в заданное окно.

     Для  того  чтобы  использовать  мировые  координаты  окна  с
плавающими значениями, выполняйте следующие шаги:

     1.  Введите графический режим с помощью setvideomode.

     2.  Используйте setviewport для создания области  просмотра.
         Этот  шаг  необязателен, если вы планируете использовать
         весь экран.

     3.  С помощью процедуры setwindow создайте окно с плавающими
         координатами, передавая флаг инвертирования типа LOGICAL
         и четыре x-  и  y-координаты  типа  DOUBLE  PRECISION  с
         минимальными и максимальными значениями.



                               297



     4.  Нарисуйте графические изображения с помощью  rectangle_w
         и аналогичных процедур.  Не путайте rectangle (процедуру
         окна просмотра) с rectangle_w (процедурой для  рисования
         прямоугольников  в окне мировых координат).  Все функции
         для окна в  мировых  координатах  оканчиваются  символом
         подчеркивания (_) и буквой "w".

     Графика с  вещественными  координатами  дает  вам  гибкость.
Например,  вы  можете  использовать  оси  с  небольшим диапазоном
(151.25-151.45) или с очень большим диапазоном (-50000.-+80000.),
в  зависимости  от  типа  данных,  которые  необходимо отобразить
графически.  Кроме того,  изменяя  мировые  координаты  окна,  вы
можете создавать эффекты увеличения и уменьшения фигур.


     9.3.3  ПРОГРАММА С ВЕЩЕСТВЕННЫМИ КООРДИНАТАМИ (REALG)

     В данной программе показаны способы  использования  функций,
работающих с окном в мировых вещественных координатах.

CC  REALG.FOR - иллюстрирует графику с вещественными координатами.

      INCLUDE  'FGRAPH.FI'
      INCLUDE  'FGRAPH.FD'

      LOGICAL  fourcolors
      EXTERNAL fourcolors

      IF( fourcolors() ) THEN
         CALL threegraphs()
      ELSE
         WRITE (*,*) ' This program requires a CGA, EGA, or',
     +               ' VGA graphics card.'
      END IF
      END 

C     Дополнительные функции, определенные ниже.
.
.
.

     Главная программа  очень  короткая.   Она  вызывает  функцию
fourcolors   (определенную   ниже),   которая   пытается   ввести
графический режим, по крайней мере, с четырьмя цветами.  Если  ее
вызов  успешен, то вызывается функция threegraphs, которая рисует
три графика.

     Обратите внимание, что подпрограмма gridshape  (определенная
ниже),  которая рисует графики, использует одни и те же данные во
всех случаях.  Однако, программа использует три различных окна  в


                               298



мировых  вещественных  координатах.  Два окна просмотра в верхней
половине имеют одинаковый размер  в  физических  координатах,  но
отображают  окна  разных  размеров в мировых координатах.  Каждое
окно  в  мировых  координатах  использует  разные  минимальное  и
максимальное  значения.  Во всех трех случаях размер ячейки сетки
равен  2  единицам.   В  верхнем  левом  углу  окно   в   мировых
координатах  имеет размер 4 единицы; в верхнем правом - 6 единиц,
что делает график на экране меньше.

     Окно просмотра является также областью отсечения.  В двух из
трех графиков одна из линий выходит за пределы окна просмотра, но
не переходит в другие окна просмотра, поскольку определение  окна
просмотра создает область отсечения.

     Наконец, отметьте, что график  в  нижней  части  инвертирует
данные по отношению к двум верхним графикам.


     9.3.3.1  ПРОВЕРКА АДАПТЕРА

     Первым шагом в любой  графической  программе  является  ввод
графического  режима.   В  программе REALG.FOR этот шаг выполняет
функция fourcolors:

CC  FOURCOLORS - функция вводит графический режим для REALG.FOR

      LOGICAL FUNCTION fourcolors()

      INCLUDE  'FGRAPH.FD'

      INTEGER*2            dummy
      RECORD /videoconfig/ screen
      COMMON               screen
 
C
C     Устанавливает максимальное число доступных цветов.
C
      CALL getvideoconfig( screen )
      SELECT CASE( screen.adapter )
         CASE( $CGA, $OCGA )
            dummy = setvideomode( $MRES4COLOR )
         CASE( $EGA, $OEGA )
            dummy = setvideomode( $ERESCOLOR )
         CASE( $VGA, $OVGA )
            dummy = setvideomode( $VRES16COLOR )
         CASE DEFAULT
            dummy = 0
      END SELECT

      CALL getvideoconfig( screen )


                               299



      fourcolors = .TRUE.
      IF( dummy .EQ. 0 ) fourcolors = .FALSE.
      END

     Процедура getvideoconfig передает  информацию  об  экране  в
videoconfig-структуру    screen.     Элемент   screen.adapter   в
конструкции  SELECT  CASE  включает  соответствующий  графический
режим.  Режимы, содержащие букву "O", являются режимами Olivetti.

     Функция  fourcolors  возвращает   .TRUE.,   если   компьютер
поддерживает  цветную графику.  В противном случае она возвращает
.FALSE.,  что  заставляет   программу   пропустить   подпрограмму
threegraphs.


     9.3.4  РИСОВАНИЕ ГРАФИКОВ

     Если  функция  fourcolors  возвращает  .TRUE.,  то   главная
программа  вызывает  подпрограмму threegraphs, которая рисует три
графика.

CC  THREEGRAPHS - эта подпрограмма рисует три графика для REALG.

      SUBROUTINE threegraphs()

      INCLUDE  'FGRAPH.FD'

      INTEGER*2            dummy, halfx, halfy
      INTEGER*2            xwidth, yheight, cols, rows
      RECORD /videoconfig/ screen
      COMMON               screen

      CALL clearscreen( $GCLEARSCREEN )
      xwidth  = screen.numxpixels
      yheight = screen.numypixels
      cols    = screen.numtextcols
      rows    = screen.numtextrows
      halfx   = xwidth / 2
      halfy   = (yheight / rows) * (rows / 2)
C
C     Первое окно в мировых координатах.
C
      CALL setviewport( 0, 0, halfx - 1, halfy - 1 )
      CALL settextwindow( 1, 1, rows / 2, cols / 2 )
      dummy = setwindow( .FALSE., -2.0, -2.0, 2.0, 2.0 )
      CALL gridshape( INT2( rows / 2 ) )
      dummy = rectangle( $GBORDER, 0, 0, halfx - 1, halfy - 1 )
C
C     Второе окно.
C


                               300



      CALL setviewport( halfx, 0, xwidth - 1, halfy - 1 )
      CALL settextwindow( 1, (cols / 2) + 1, rows / 2, cols )
      dummy = setwindow( .FALSE., -3.0, -3.0, 3.0, 3.0 )
      CALL gridshape( INT2( rows / 2 ) )
      dummy = rectangle_w( $GBORDER, -3.0, -3.0, 3.0, 3.0 )   
C  
C     Третье окно.
C
      CALL setviewport( 0, halfy, xwidth - 1, yheight - 1 )
      CALL settextwindow( (rows / 2 ) + 1, 1, rows, cols )
      dummy = setwindow( .TRUE., -3.0, -1.5, 1.5, 1.5 )
      CALL gridshape( INT2( (rows / 2) + MOD( rows, 2 ) ) )
      dummy = rectangle_w( $GBORDER, -3.0, -1.5, 1.5, 1.5 )
   
      READ (*,*)         ! ждет нажатия клавиши ENTER
      dummy = setvideomode( $DEFAULTMODE )
      END

     Несмотря на то, что ввод графического  режима  автоматически
очищает  экран,  подпрограмма threegraphs, тем не менее, вызывает
процедуру clearscreen:

      CALL clearscreen( $GCLEARSCREEN )

     Константа  $GCLEARSCREEN  очищает  весь  физический   экран.
Другими   значениями   этого   параметра  являются  $GVIEWPORT  и
$GWINDOW,  которые  очищают  текущее  окно  просмотра  и  текущее
текстовое окно, соответственно.

     После    присваивания    значений    некоторым    переменным
подпрограмма threegraphs создает первое окно:

      CALL setviewport( 0, 0, halfx - 1, halfy - 1 )
      CALL settextwindow( 1, 1, rows / 2, cols / 2 )
      dummy = setwindow( .FALSE., -2.0, -2.0, 2.0, 2.0 )

     Первая строка определяет окно просмотра, которое захватывает
верхнюю левую четверть экрана.  Затем определяется текстовое окно
с  заданными  границами.   Обратите   внимание,   что   нумерация
начинается  с  1  и  номер  строки  предшествует  номеру столбца.
Наконец, третья  строка  создает  окно  с  координатами  x  и  y,
изменяющимися  от -2.0 до 2.0.  Константа .FALSE.  заставляет ось
y увеличиваться  сверху  вниз,  что  является  обратным  обычному
представлению.

     Затем вызывается подпрограмм gridshape, которая рисует сетку
и график, и к окну добавляется внешняя рамка:

      CALL gridshape( INT2( rows / 2 ) )
      dummy = rectangle( $GBORDER, 0, 0, halfx - 1, halfy - 1 )


                               301



     Отметьте, что это стандартная процедура  rectangle,  которая
принимает координаты, относящиеся к окну просмотра, а не к окну в
мировых координатах.

     Два других окна аналогичны  первому.   Для  всех  трех  окон
вызывается   подпрограмма  gridshape  (описанная  ниже),  которая
рисует сетку из ячейки (-1.0,-1.0) в (1.0,1.0).  Сетка появляется
разных  размеров,  поскольку меняются координаты в окнах.  Второе
окно изменяется от  (-3.0,-3.0)  до  (3.0,3.0),  а  третье  -  от
(-3.0,-1.5) до (1.5,1.5), так что ширина меняется соответственно.

     Обратите также внимание, что третье окно  содержит  аргумент
инверсии .TRUE..  Это заставляет ось y увеличиваться снизу вверх,
а  не  сверху  вниз.   В  результате,  этот   график   появляется
перевернутым по отношению к первым двум.

     После вызова  gridshape  программа  обрамляет  каждое  окно,
используя оператор, подобный следующему:

      dummy = rectangle_w( $GBORDER, -3.0, -1.5, 1.5, 1.5 )

     Все три функции содержат флаг заполнения в качестве  первого
аргумента.    Процедура   rectangle  принимает  целые  аргументы,
которые  относятся  к  координатам  окна  просмотра.    Процедура
rectangle_w   принимает   плавающие  значения  двойной  точности,
которые относятся к окну в мировых координатах:  верхний левый x,
верхний левый y, нижний правый x и нижний правый y.

     Процедура gridshape рисует данные на экране:

CC  GRIDSHAPE - эта подпрограмма рисует данные для
CC              программы REALG.

      SUBROUTINE gridshape( numc )

      INCLUDE  'FGRAPH.FD'

      INTEGER*2            dummy, numc, i
      CHARACTER*2          str
      DOUBLE PRECISION     bananas(21), x
      RECORD /videoconfig/ screen
      RECORD /wxycoord/    wxy
      RECORD /rccoord/     curpos
      COMMON               screen
C
C     Данные для графика.
C
      DATA bananas /-0.3  , -0.2 , -0.224, -0.1, -0.5  ,
     +               0.21 ,  2.9 ,  0.3  ,  0.2,  0.0  ,
     +              -0.885, -1.1 , -0.3  , -0.2,  0.001,


                               302



     +               0.005,  0.14,  0.0  , -0.9, -0.13 , 0.31 /

C
C     Печатает на экране слова в цвете.
C
      IF( screen.numcolors .LT. numc ) numc = screen.numcolors - 1
      DO i = 1, numc
         CALL settextposition( i, 2, curpos )
         dummy = settextcolor( i )
         WRITE (str, '(I2)') i
         CALL outtext( 'Color ' // str )
      END DO
C
C     Рисует ограничивающий прямоугольник вокруг графика.
C
      dummy = setcolor( 1 )
      dummy = rectangle_w( $GBORDER, -1.00, -1.00, 1.00, 1.00 )
      dummy = rectangle_w( $GBORDER, -1.02, -1.02, 1.02, 1.02 )
C
C     Рисует точки.
C
      x = -0.90
      DO i = 1, 19
         dummy = setcolor( 2 )
         CALL    moveto_w( x, -1.0, wxy )
         dummy = lineto_w( x,  1.0 )
         CALL    moveto_w( -1.0, x, wxy )
         dummy = lineto_w(  1.0, x )
         dummy = setcolor( 14 )
         CALL    moveto_w( x - 0.1, bananas( i ), wxy )
         dummy = lineto_w( x, bananas( i + 1 ) )
         x     = x + 0.1
      END DO

      CALL    moveto_w( 0.9, bananas( i ), wxy )
      dummy = lineto_w( 1.0, bananas( i + 1 ) )
      dummy = setcolor( 3 )
      END

     Подпрограмма gridshape сначала присваивает  переменной  rows
число  доступных  индексов цвета, а цикл DO выводит все доступные
цвета:

      IF( screen.numcolors .LT. numc )
     +               numc = screen.numcolors - 1
      DO i = 1, numc
         CALL settextposition( i, 2, curpos )
         dummy = settextcolor( i )
         WRITE (str, '(I2)') i
         CALL outtext( 'Color ' // str )


                               303



      END DO

     Имена функций являются самодокументируемыми.   Использование
функции outtext в графическом режиме позволяет вам контролировать
цвет и позицию текста на экране (в отличие от WRITE).

     Процедуры с именами,  которые  оканчиваются  "_w",  работают
точно   так  же,  как  их  эквиваленты  для  окон  просмотра,  за
исключением того, что вы передаете им плавающие значения  двойной
точности  вместо  целых.  Например, для lineto вы передаете целые
аргументы, а для lineto_w - значения двойной точности.

     После того, как вы научились создавать различные графические
элементы,  вы  можете  использовать процедуры, ориентированные на
шрифты,  и  наводить   глянец   выводом   названий,   заголовков,
комментариев  или меток.  В следующей главе подробно описано, как
печатать текст различными шрифтами, поставляемыми  с  графической
библиотекой MSФортрана.


































                               304
