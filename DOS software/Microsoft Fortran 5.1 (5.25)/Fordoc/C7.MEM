







                               ГЛАВА 7

                         ОПТИМИЗАЦИЯ ПРОГРАММ

     В этой главе описаны методы создания меньших  по  размеру  и
более  быстрых  по  исполнению  программ  с  помощью  компилятора
MSФортрана.  Хотя некоторые из излагаемых идей применимы только к
определенному   классу   программ,   другие   можно  использовать
практически для всех программ.

     Охватываемые  темы  включают  структуру  программ  и   опции
компилятора,   которые   повышают   его   эффективность,   методы
написания,  уменьшающие   размер   файлов   данных,   создаваемых
программой,  редактирование связей и методы использования памяти,
условия  использования  целых  и   вещественных   переменных,   и
эффективное использование массивов.


     7.1  МЕТОДЫ КОМПИЛЯЦИИ И РЕДАКТИРОВАНИЯ СВЯЗЕЙ

     Различные опции компиляции и редактирования связей  Фортрана
улучшают управление программой и ее отладку, но некоторые из этих
опций осуществляют это управление за счет размера и скорости.   С
помощью немногих продуманных мер вы можете уменьшить размер ваших
программ и иногда увеличить скорость их выполнения.  В  следующих
разделах   описаны  опции  компиляции  и  редактирования  связей,
которые уменьшают размер  исполняемых  файлов  и  увеличивают  их
скорость.


     7.1.1  ИСПОЛЬЗОВАНИЕ ОПЦИЙ ОТЛАДКИ И ЦЕЛОГО РАЗМЕРА

     Три опции командной строки FL могут значительно повлиять  на
количество памяти, необходимое для вашей исходной программы:  это
опции /4Yb (отладка), /Zi (отладка с  помощью  CodeView)  и  /4I2
(целый размер).

     ЗАМЕЧАНИЕ:  Опции /4Yb  и  /4I2  соответствуют  метакомандам
$DEBUG и $STORAGE:2, соответственно, и имеют то же действие.

     Программы,  скомпилированные  без  $DEBUG,  являются   более
компактными.

     Программа, которая включает  информацию,  сгенерированную  с
помощью  отладочной  опции,  может  содержать код на 40 процентов


                               246



больший, чем та же программа без  отладочной  информации.   После
успешной компиляции, редактирования связей и выполнения программы
вы можете уменьшить ее размер  и  улучшить  скорость  выполнения,
перекомпилировав  исходную  программу  без  опции  /4Yb  (или без
метакоманд $DEBUG).

     Аналогичным образом, опция /Zi готовит  код  для  отладки  с
помощью   отладчика   CodeView.    Она  создает  объектный  файл,
содержащий полную  символьную  отладочную  информацию  -  включая
таблицу   символов   и   номера   строк  -  для  использования  с
ориентированным на  окна  отладчиком  CodeView  фирмы  Microsoft.
Если вы завершили отладку с помощью отладчика CodeView, то можете
сократить размер файла, перекомпилировав конечную  программу  без
опции /Zi.

     Если ваша программа  не  требует  четырех  байт  памяти  для
переменных  INTEGER  и  LOGICAL  (т.е.  вам явно не нужны длинные
целые  и  логические  переменные),  то  для  сокращения   размера
сгенерированного  кода вы можете во время компиляции задать опцию
/4I2.  Эта опция выделяет по два байта памяти (вместо четырех, по
умолчанию)  для  каждой  переменной INTEGER и LOGICAL, которую вы
объявляете без явной  спецификации  длины.   Такое  распределение
памяти   сокращает   размер   программы,  поскольку  двухбайтовые
арифметические операции требуют меньше поддерживающего кода,  чем
четырехбайтовые операции.


     7.1.2  ИСПОЛЬЗОВАНИЕ МАТЕМАТИЧЕСКИХ ОПЦИЙ 8087/287/387

     Во  время  компиляции  программы  вы  можете  задать   опцию
плавающей   точки,  которая  выбирает  математический  пакет  для
использования программой и умалчиваемую библиотеку для связывания
(редактирования   связей).    Если   вы   имеете   математический
сопроцессор 8087, 80287 или 80387, то можете выбрать опции /FPi87
или /FPc87, каждая из которых генерирует команды для сопроцессора
в исполняемом файле.  Если вы редактируете связи  с  библиотекой,
которая  поддерживает сопроцессоры 8087/287/387 (LLIBFOR7.LIB или
MLIBFOR7.LIB), то конечные исполняемые файлы  будут  меньше,  чем
исполняемые  файлы,  созданные  с  помощью  других математических
опций.   Математический  сопроцессор  ускоряет  также  программы,
которые широко используют вычисления с плавающей точкой.

     Программная эмуляция процессоров плавающей точки увеличивает
размер  программы.  Вы можете сократить размер исполняемых файлов
почти на 7K, выбрав  одну  из  этих  опций  сопроцессора.   Более
подробная  информация  находится в главе "Управление операциями с
плавающей точкой".





                               247



     7.1.3 ИСПОЛЬЗОВАНИЕ ОВЕРЛЕЕВ

     Во  время  редактирования  связей  задание   соответствующих
программных  модулей  в качестве оверлеев сокращает размер файла.
Оверлей относится к двум или более  модулям,  которые  используют
одно  и  то  же  пространство  памяти  во  время  их  выполнения.
Предположим, например, что два различных модуля A  и  B  содержат
процедуры,  необходимые  главной  программе  (см.   рисунок 7.1).
Если программа вызывает процедуру из модуля A, то она загружает A
с  диска  в  определенное  место памяти.  Если программа вслед за
этим вызывает процедуру из модуля B, то она загружает модуль B  в
то же самое место, ранее занимаемое модулем A.

+---------------------------------------------------------------+
|                                                               |
|   +----------------+               |           |              |
|   | Подпрограмма A |                                          |
|   | .              |               |           |              |
|   | .              |               +-----------+              |
|   | .              |-------------> |           |  Секция в    |
|   +----------------+     +-------> |           |  памяти      |
|                          |         |           |              |
|                          |         +-----------+              |
|                          |         |           |              |
|   +----------------+     |         |           |              |
|   | Подпрограмма B |     |         |           |              |
|   | .              |-----+         +-----------+              |
|   | .              |               |           |              |
|   | .              |                                          |
|   +----------------+               |           |              |
|                                                               |
+---------------------------------------------------------------+
Рисунок 7.1  Использование оверлеев

     Программа загружает оверлейные модули в одно и то  же  место
памяти  только  тогда,  когда это необходимо.  Вообще, программа,
использующая оверлеи, меньше по размерам и требует меньше памяти,
нежели программа, не использующая их.  Однако, программы, которые
используют  оверлеи,  будут  выполняться  более  медленно   из-за
дополнительного времени, необходимого для считывания и повторного
считывания оверлейного кода с диска в память.


     7.2  МЕТОДЫ КОДИРОВАНИЯ

     Способ написания вами программы может  существенно  повлиять
как  на  ее скорость, так и на ее размер.  Типы и размеры файлов,
переменных и массивов, которые вы создаете, а также эффективность
их  использования  вами  -  все  это  может улучшить или ухудшить
характеристики вашей программы.


                               248



     В следующих разделах описаны способы, придерживаясь которых,
вы  сможете  так  писать  исходные программ, чтобы минимизировать
количество  памяти,  необходимое  компилятору,  и  минимизировать
размеры объектных и исполняемых файлов.


     7.2.1  УДАЛЕНИЕ ТЕКСТА СООБЩЕНИЙ ОБ ОШИБКАХ ВО ВРЕМЯ
            ВЫПОЛНЕНИЯ ПРОГРАММЫ SETUP

     SETUP дает вам  две  опции  для  управления  сообщениями  об
ошибках:   построить  библиотеку,  которая  выводит  полный текст
сообщений об ошибках (умолчание), или библиотеку, которая выводит
только   номер   сообщения  об  ошибке,  по  которому  вы  можете
посмотреть само сообщение.  Использование библиотеки  без  текста
сообщений  об ошибках приведет к тому, что исполняемый файл будет
иметь размер приблизительно на 2K меньше.


     7.2.2  ИСПОЛЬЗОВАНИЕ СОВМЕСТИМЫХ МЕТОДОВ ДОСТУПА
            К ФАЙЛАМ И ТИПОВ ФОРМАТОВ

     Каждый формат файла (форматированный, неформатированный  или
двоичный)  и  вид  доступа (последовательный или прямой) требуют,
чтобы компилятор внес соответствующий поддерживающий код  в  вашу
программу.   Если  замысел  программы  позволяет,  то попытайтесь
ограничиться меньшим числом типов доступа и форматов.


     7.2.3  СПЕЦИФИКАЦИЯ СПИСКОВ РЕДАКТИРОВАНИЯ

     Списки редактирования, которые  вы  задаете  для  операторов
ввода-вывода,  существенно  влияют на количество процедур времени
выполнения,  поддерживающих  вашу  программу.   Если  вы  удалите
информацию   о   форматировании   или  будете  использовать  один
спецификатор для  нескольких  вызовов,  например,  три  оператора
WRITE,  обращающихся  к  одному  оператору  FORMAT,  то тем самым
уменьшите размер  программы.   В  следующих  разделах  предложены
рекомендации для сокращения размера кода.


     7.2.3.1  ЛЕВАЯ ТАБУЛЯЦИЯ

     Дескриптор редактирования TL (или использование  дексриптора
редактирования  T  для  выполнения  левой  табуляции) увеличивает
размер исполняемых файлов.  Код времени выполнения,  используемый
для  поддержки  левой  табуляции,  включается  всякий  раз, когда
компилятор обнаруживает  явное  использование  этих  дескрипторов
редактирования, или когда используемая переменная содержит строку
формата с дескриптором.  В результате вы можете уменьшить  размер
ваших  исполняемых  файлов,  если  будете  избегать использования


                               249



левой табуляции везде, где это возможно.


     7.2.3.2  ФОРМАТНЫЙ ИЛИ УПРАВЛЯЕМЫЙ СПИСКОМ ВВОД-ВЫВОД

     Вы создадите меньшие по  размерам  исполняемые  файлы,  если
будете   последовательно   использовать   либо   форматные,  либо
управляемые списком операторы ввода-вывода, и будете избегать  их
смешивания.    Это  потребует  меньшего  числа  процедур  времени
выполнения для поддержки вашей программы и приведет к  уменьшению
ее размера.


     7.2.3.3  СИМВОЛЬНЫЕ ПЕРЕМЕННЫЕ В КАЧЕСТВЕ СПЕЦИФИКАТОРОВ
              ФОРМАТА

     MSФортран транслирует  строки  формата  в  более  компактный
внутренний  вид  везде, где это можно.  Однако, если формат задан
как символьная переменная, то эта трансляция  должна  выполняться
во  время выполнения, а не во время трансляции.  Связанный с этим
код   времени   выполнения   значительно    увеличивает    размер
исполняемого  файла.   Поэтому  вы  создадите меньшие по размерам
исполняемые  файлы,   если   будете   использовать   в   качестве
спецификатора формата символьные константы или операторы FORMAT.


     7.2.4  ИСПОЛЬЗОВАНИЕ ОПЦИИ BLOCKSIZE

     Использование  опции  BLOCKSIZE  в  операторах   OPEN   дает
возможность   выбрать   подходящий   компромисс  между  скоростью
выполнения и потребностями в памяти для программы.

     Опция BLOCKSIZE  позволяет  управлять  размером  внутреннего
буфера,  связанного  с  каждым  файлом,  который  ваша  программа
открывает.  Этот буфер создается для ускорения времени выполнения
при  считывании  или  записывании  большого  количества небольших
элементов в  файл.   По  умолчанию,  система  времени  выполнения
назначает  для файлов с последовательным доступом размер буфера в
1024 байта.  Однако, вы можете использовать опцию  BLOCKSIZE  для
размещения буфера другого размера.

     Использование опции BLOCKSIZE дает вам  следующий  комромисс
между скоростью программы и потребностями в памяти:

      o  Большие размеры буфера ускоряют  операции  ввода-вывода,
         но  увеличивают  количество  памяти, выделяемой для этих
         операций.

      o  Меньшие   размеры   буфера   приводят    к    замедлению
         ввода-вывода, но сохраняют память для других целей.


                               250



     Поскольку буферы создаются только  при  открытии  файла,  то
использование  опции BLOCKSIZE не повлияет на размер исполняемого
файла программы.  Однако, если программа приближается к  пределам
памяти  машины,  то  меньшие  размеры  буферов позволят программе
остаться в этих пределах.

     Значение, задаваемое для опции  BLOCKSIZE,  только  косвенно
определяет  буфер.   По  соображениям  эффективности это значение
округляется   до   значения,   кратного   512,   для   файлов   с
последовательным  доступом.   DOS  обычно  форматирует  диски  на
секторы по 512 байт и выполняет операции ввода-вывода с дисковыми
файлами  в  соответствии  с  этими  границами секторов.  Поэтому,
наиболее эффективный ввод-вывод выполняется, если  размер  буфера
также кратен 512 для файлов последовательного доступа.

     Таким образом, если вы задаете BLOCKSIZE = 1800 при открытии
последовательного  файла,  то  действительный размер буфера будет
равен ближайшему сверху значению, кратному  512,  и  не  меньшему
1800,  то есть, будет равен 2048 (4*512).  BLOCKSIZE поддерживает
буферы максимум до  32256  байт:   любые  значения,  передаваемые
BLOCKSIZE  и превышающие это число, все равно дадут буфер в 32256
байт.


     7.2.5  ИСПОЛЬЗОВАНИЕ ЦЕЛЫХ И ВЕЩЕСТВЕННЫХ ПЕРЕМЕННЫХ

     Несмотря на то, что большинство программ Фортрана используют
как  плавающие, так и целые данные, программы, которые используют
только целые данные, значительно  меньше  программ,  использующих
плавающие  данные.   Помните, что в некоторых ситуациях вы можете
использовать целые числа  вместо  плавающих.   В  зависимости  от
ситуации  иногда  можно  умножить  плавающие  числа  на известный
коэффициент  для  преобразования  их  в  целые,  выполнить  любые
манипуляции  и  перед конечной печатью преобразовать их обратно в
вещественные.

     Если вы пишете программу, которая  использует  только  целые
данные  (например,  программу,  которая  печатает  время и ничего
больше), то не забывайте либо явно описывать переменные  с  типом
INTEGER, либо использовать имена переменных, которые начинаются с
букв, по умолчанию дающих тип  INTEGER.   По  умолчанию  таковыми
являются  буквы  от  "I"  до  "N".  Для того, чтобы задать другие
умалчиваемые  буквы  для  каждого  типа,   используйте   оператор
IMPLICIT.


     7.2.6  ИСПОЛЬЗОВАНИЕ МАССИВОВ И ОПЕРАТОРОВ EQUIVALENCE

     Способы описания массивов и их  использование  в  операторах
EQUIVALENCE  могут значительно повлиять на количество информации,


                               251



необходимой  для  компиляции  вашей   программы.    Использование
массивов  может  повлиять  на то, выйдет ли компилятор за пределы
отведенной памяти  при  обработке  ваших  исходных  файлов.   Чем
меньше  допущений,  которые  компилятор  должен  делать о типах и
использовании массивов, тем более эффективна компиляция.

     В  следующих   разделах   даны   рекомендации   для   такого
использования  массивов,  чтобы минимизировать количество данных,
необходимых компилятору.


     7.2.6.1  МИНИМИЗАЦИЯ ИСПОЛЬЗОВАНИЯ КОНСТАНТ В ОПИСАНИЯХ
              МАССИВОВ

     Насколько возможно,  уменьшайте  число  различных  констант,
которые вы используете в описаниях массивов.  Кроме того, первыми
располагайте описания  массивов,  которые  используют  одинаковые
константы.   Такие  действия  повысят  эффективность  компиляции,
поскольку компилятор  сохраняет  копии  констант  и  повторно  их
использует, если возможно.

     Это иллюстрируется следующими  двумя  примерами.   Описания,
показанные   в   первом   примере,   будут  скомпилированы  более
эффективно, если переменные  X,  Y  и  Z  описать  с  одинаковыми
границами, как показано во втором примере:

      INTEGER X(11), Y(10), Z(11)

      INTEGER X(11), Y(11), Z(11)

     Если все-таки необходимо описать массив Y с границей 10,  то
программа  будет скомпилирована более эффективно, если описания X
и Z, которые имеют одинаковые  границы,  поместить  первыми,  как
показано ниже:

      INTEGER X(11), Z(11)

      INTEGER Y(10)


     7.2.6.2  МИНИМИЗАЦИЯ ЭЛЕМЕНТОВ, ОПИСЫВАЕМЫХ В КАЖДОМ
              ОПЕРАТОРЕ ТИПА

     В  каждом  операторе  типа  описывайте  как   можно   меньше
элементов.   Это  уменьшает  сложность  каждого  оператора  и,  в
результате,  сохраняет  пространство   данных   компилятора   при
обработке  каждого  описания.   Этот метод дает особенно заметный
результат для описаний массивов.




                               252



     7.2.6.3  ОПИСАНИЕ ТИПОВ МАССИВОВ ПЕРЕД РАЗМЕРНОСТЬЮ

     Тип массива описывайте явно  до  описания  его  размерности.
Кроме   того,   перед   использованием   массивов   в  операторах
EQUIVALENCE  убедитесь,  что  все  массивы  в  списке   оператора
полностью  описаны,  образмерены,  и  (если необходимо) внесены в
оператор COMMON.

     Ниже в примере показано, как описать массив A  для  наиболее
эффективного использования памяти во время компиляции.

      INTEGER A(10,20)

      INTEGER A
      DIMENSION A(10,20)

      INTEGER A
      COMMON A(10,20)

     В  описаниях,  показанных   ниже,   компилятору   необходимо
дополнительное  пространство  для данных, поскольку тип массива X
задан после использования X в операторе EQUIVALENCE.

      DIM X(20)
      EQUIVALENCE (X(1), J)
      INTEGER X

     В следующих описаниях компилятору необходимо  дополнительное
пространство  для данных, поскольку он не может определить типы A
и B до обработки второй строки;  он  не  знает,  что  B  является
массивом  до  обработки  второй  строки  и  не  знает,  что A и B
находятся в COMMON-блоке до обработки третьей строки:

      EQUIVALENCE (A(10,20), B)
      INTEGER A, B(20,30)
      COMMON /CBA/A, /CBB/B

     В каждом  случае  компилятор  должен  делать  предположения,
которые  увеличивают  объем обработки и объем памяти, необходимой
для  содержания   промежуточных   результатов   обработки.    Для
повышения эффективности перепишите описания следующим образом:

      INTEGER A(10,20), B(20,30)
      COMMON /CBA/A, /CBB/B
      EQUIVALENCE (A(10,20), B(1,1))

     В этой последовательности описаний компилятор  сразу  знает,
что  A  и  B  являются двумерными целыми массивами и знает размер
каждого.  Последующие обращения к A и B не оставляют неясностей у
компилятора.


                               253
