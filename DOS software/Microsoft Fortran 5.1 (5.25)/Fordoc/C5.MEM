







                               ГЛАВА 5

                    ПЕРЕДАЧА ДАННЫХ МЕЖДУ ЯЗЫКАМИ

     В  главе  4  были  введены  основные  понятия   о   передаче
параметров  по  ссылке  (адресу)  и  по  значению.   В  некоторых
ситуациях вам  может  понадобиться  передавать  параметры  особым
методом   или   передавать  различные  типы  данных  (логические,
строковые  или  массивы  -  в  противоположность  чисто  числовым
данным).  В этой главе представлена необходимая вам информация.

     В первом разделе этой главы  обсуждаются  способы  изменения
стандартного  метода  передачи  данных  в  каждом  языке.  Второй
раздел охватывает числовые,  логические  и  строковые  данные;  в
третьем  описаны специальные ситуации, включая структурные данные
(например, массивы) и данные, доступные извне.


     5.1  ПЕРЕДАЧА ПО ССЫЛКЕ ИЛИ ПО ЗНАЧЕНИЮ

     В этом  разделе  описано,  как  обойти  умалчиваемый  метод,
который  используется  каждым языком для передачи данных.  Раздел
состоит из четырех частей, в каждой из которых дан обзор  методов
передачи  параметров  отдельным языком, и описано, как передавать
аргументы по значению, по ближней ссылке  и  по  дальней  ссылке.
Для  того,  чтобы  успешно  передавать  данные между языками, вам
необходимо учитывать, как каждый параметр  передается  вызывающей
процедурой,   и   как   каждый   из  них  принимается  вызываемой
процедурой.


     5.1.1  АРГУМЕНТЫ БЕЙСИКА

     По  умолчанию  Бейсик  передает  все  аргументы  по  ближней
ссылке.  Каждая подпрограмма или функция Бейсика всегда принимает
параметры также по ближней ссылке.

     Бейсик  передает  аргумент  по  значению,  если   вызываемая
процедура  описана  с  помощью  оператора  DECLARE, и к аргументу
приставлено ключевое слово BYVAL.  Обратите внимание,  что  BYVAL
действует только на один аргумент; если ваша программа использует
три аргумента и вы хотите передавать каждый из них  по  значению,
то должны поставить опцию BYVAL перед каждым аргументом.

     Бейсик будет передавать каждый аргумент  вызова  по  дальней


                               217



ссылке,   если   для   вызова   процедуры   используется   CALLS.
Использование  SEG  для  изменения  параметра  в   предшествующем
операторе DECLARE также заставит Бейсик передать этот параметр по
дальней ссылке.


     5.1.2  АРГУМЕНТЫ СИ

     Умолчанием для Си является передача всех массивов по  ссылке
(ближней  или  дальней,  в  зависимости от модели памяти), а всех
других  типов  данных  -  по  значению.   Си  использует  дальние
указатели для компактной, большой и гигантской моделей, и ближние
указатели для маленькой и средней моделей.  Фортран  поддерживает
среднюю, большую и гигантскую модели памяти.

     Все немассивы (сюда входят все типы данных, кроме  тех,  что
явно  описаны  как  массивы)  язык  Си  по  умолчанию передает по
значению.

     Массивы могут передаваться по значению при описании  их  как
единственного члена структуры.

     Передача  указателя  на  объект  в  языке  Си   эквивалентна
передаче  объекта  по  ссылке.   Умолчанием для массивов является
передача по ссылке.  В Си ближняя ссылкя является умолчанием  для
передачи  указателей  в  маленькой  и  средней  моделях.  Дальняя
ссылка является умолчанием в  компактной,  большой  и  гигантской
моделях.


     5.1.3  АРГУМЕНТЫ ФОРТРАНА

     Фортран, по умолчанию, все аргументы передает и принимает по
ссылке.  Размер передаваемого адреса зависит от модели памяти.

     Параметр передается по значению, если он описан с  атрибутом
VALUE.   Это описание может находиться либо в операторе INTERFACE
(который определяет,  как  передается параметр), либо  в  описании
функции  или  подпрограммы  (которое  определяет, как принимается
параметр).

     Функция или подпрограмма, описанная с атрибутом  PASCAL  или
C,  будет  передавать  по  значению все параметры, описанные в ее
списке  аргументов,  за  исключением  параметров,   описанных   с
атрибутом   REFERENCE.    Это  изменение  в  умалчиваемом  методе
передачи действует на определения функций и подпрограмм, а  также
на оператор INTERFACE.

     Передача  по  ссылке  является  умолчанием   для   Фортрана.
Однако,  если  на  описание  функции  или  подпрограммы действует


                               218



атрибут  C  или  PASCAL,  то  вам  необходимо  задавать   атрибут
REFERENCE  для  любого  параметра  процедуры,  который  вы хотите
передавать по ссылке.

     Ближняя  ссылка  является   умолчанием   для   фортрановских
программ  средней модели, а дальняя ссылка - для программ большой
и гигантской моделей.

     ЗАМЕЧАНИЕ:   Версии  Фортрана  до   4.0   всегда   выполняют
компиляцию в большой модели памяти.

     Для параметра, передаваемого по ссылке, можно задать атрибут
NEAR  (ближняя  ссылка)  или  FAR (дальняя ссылка).  Эти ключевые
слова замещают умолчание, но не действуют,  если  они  определяют
тот же метод, что и умолчание.

     Для данного параметра можно задать более чем  один  атрибут.
В  этом  случае  атрибуты  разделяются  запятой  и  заключаются в
скобки:

      REAL*4 X (NEAR, REFERENCE)


     5.1.4  АРГУМЕНТЫ ПАСКАЛЯ

     Паскаль по умолчанию передает  все  аргументы  по  значению.
Параметры  передаются по ближней ссылке, если они описаны как VAR
или CONST.  Кроме того, параметры передаются по  ближней  ссылке,
если   ADR  или  указатель  переменной  передаются  по  значению.
Другими словами, сначала определяется адрес переменной,  а  затем
передается  по  значению.  По существу, это тот же метод, который
используется в Си.

     Параметры передаются по дальней ссылке, если они описаны как
VARS  или  CONSTS.   Кромет того, параметры передаются по дальней
ссылке, если ADRS переменной передается по значению.


     5.2  ПЕРЕДАЧА ЧИСЛОВЫХ, ЛОГИЧЕСКИХ И СТРОКОВЫХ ДАННЫХ

     В этом разделе описаны процедуры передачи и приема различных
типов  данных.  Акцент делается на различиях в строковых форматах
и на методах передачи строк между Фортраном и другими языками.


     5.2.1  ЦЕЛЫЕ И ВЕЩЕСТВЕННЫЕ ЧИСЛА

     Целые и вещественные числа это, как правило,  самые  простые
типы  данных  для передачи между языками.  Однако, в каждом языке
тип числовых данных называется по разному и, более того,  не  все


                               219



типы  данных  доступны в каждом языке и в некоторых случаях могут
быть заменены другим типом.

     В таблице 5.1 показаны эквивалентные типы  данных  в  каждом
языке.

Таблица 5.1  Эквивалентные типы числовых данных
-----------------------------------------------------------------
BASIC       C                  FORTRAN           Pascal
-----------------------------------------------------------------
x%          short              INTEGER*2         INTEGER2
INTEGER     int                ---               INTEGER (умолч.)
---         unsigned short (*) ---               WORD
---         unsigned           ---               ---
x&          long               INTEGER*4         INTEGER4
LONG        ---                INTEGER (умолч.)  ---
---         unsigned long (*)  ---               ---
x!          float (+)          REAL*4            REAL4
x (умолч.)  ---                REAL              REAL (умолч.)
SINGLE      ---                ---               ---
x#          double             REAL*8            REAL8
DOUBLE      ---                DOUBLE PRECISION  ---
---         unsigned char (^)  CHARACTER*1 (~)   BOOLEAN
-----------------------------------------------------------------
* Не доступен в Бейсике, Фортране или Паскале. Может быть заменен
  знаковым целым, но с осторожностью, чтобы не превысить диапазон.
+ Си автоматически преобразует float в double в операциях
  присваивания или при передаче по значению.
^ Си автоматически преобразует char и unsigned char в int в
  операциях присваивания или при передаче по значению.
~ Фортрановский тип CHARACTER*1 не то же самое, что LOGICAL. Тип
  данных LOGICAL описан в разделе 5.2.3.

-----------------------------------------------------------------
ПРЕДУПРЕЖДЕНИЕ:      Си     иногда    выполняет    автоматическое
преобразование данных, чего не делают другие  языки.   Вы  можете
воспрепятствовать  Си  выполнять  такие  преобразования, описывая
переменную в виде единственного члена структуры и  передавая  эту
структуру.   Например,  можно  передать  переменную x типа float,
описывая ее как структуру.  Если вы  передадите  переменную  типа
char   или   float   по   значению   и   не   примете  этой  меры
предосторожности, то автоматическое преобразование может привести
к ошибке в программе.
-----------------------------------------------------------------


     5.2.2  ТИПЫ COMPLEX ФОРТРАНА

     Фортрановские  типы  COMPLEX*8   и   COMPLEX*16   прямо   не
реализованы  ни  в  одном  другом языке.  Тем не менее, вы можете


                               220



написать полностью эквивалентные структуры в Си, записи в Паскале
или типы, определяемые пользователем, в Бейсике.

     Тип   COMPLEX*8   имеет   два   поля:    первое   поле   это
четырехбайтовое  плавающее число, которое содержит действительный
компонент, а второе поле  это  четырехбайтовое  плавающее  число,
которое содержит мнимый компонент.

     Тип COMPLEX*16  аналогичен  COMPLEX*8,  только  каждое  поле
содержит  восьмибайтовое плавающее число.  Тип COMPLEX аналогичен
типу COMPLEX*8.

+-----------------------------+----------------------------+
| Плавающий действ. компонент | Плавающий мнимый компонент |
+-----------------------------+----------------------------+
:           4 байта           :           4 байта          :

Формат данных COMPLEX Фортрана


     5.2.3  ТИП LOGICAL ФОРТРАНА

     Фортрановский тип LOGICAL не эквивалентен  ни  паскалевскому
BOOLEAN, ни типу char в Си.  Фортрановский LOGICAL*2 хранится как
однобайтовое флаговое  значение  (1=true,  0=false),  за  которым
следует  неиспользуемый  байт.   Фортрановский LOGICAL*4 хранится
как  однобайтовое  флаговое  значение,  за  которым  следуют  три
неиспользуемых  байта.   Тип LOGICAL эквивалентен LOGICAL*4, если
не действует $STORAGE:2.

     Для того,  чтобы  получить  или  принять  фортрановский  тип
LOGICAL,   опишите   структуру   в   Си,  запись  в  Паскале  или
определяемый  пользователем  тип  в  Бейсике  с  соответствующими
полями.


     5.2.4  СТРОКИ

     Для хранения строк используется множество форматов.  Поэтому
для  передачи  строк  между  языками  часто  требуется  некоторое
преобразование.

     В этом разделе описаны форматы строк, используемые в  каждом
языке, и методы передачи строк из Фортрана в эти языки.


     5.2.4.1  СТРОКИ БЕЙСИКА

     Строки    в    Бейсике    представляются    четырехбайтовыми
дескрипторами строк, как показаано ниже:


                               221



+----------------------+----------------------+
|         Длина        |   Адрес (смещение)   |
+----------------------+----------------------+
:        2 байта       :        2 байта       :

Формат дексриптора строки Бейсика

     Первое поле дескриптора строки содержит двухбайтовое  целое,
обозначающее  действительную  длину  строки  текста.  Второе поле
содержит адрес этого текста.  Этот  адрес  является  смещением  в
умалчиваемой   области  данных.   Процедуры  управления  строками
Бейсика переопределяют этот  адрес  всякий  раз,  когда  меняется
длина  строки,  однако эти процедуры управления доступны только в
Бейсике.  Поэтому Фортран не должен изменять длину строк Бейсика.

-----------------------------------------------------------------
ПРЕДУПРЕЖДЕНИЕ:   Если  вы передаете строку из Бейсика в Фортран,
то вызываемая процедура ни в коем случае не должна  менять  длину
строки.   Процедуры  управления  строками  Бейсика  отсутствуют в
других языках.  Поэтому  изменение  длины  строки  Бейсика  может
разрушить  часть  пространства  строки.   Однако,  изменения,  не
влияющие на длину, относительно  безопасны.   Процедура,  которая
принимает   строку,   не  должна  вызывать  какую-либо  процедуру
Бейсика.   Иначе  процедуры  управления  строками  Бейсика  могут
изменить адрес строковых данных без предупреждения.
-----------------------------------------------------------------

     Фортран должен принимать по ближней ссылке.  Это делается  с
помощью  атрибута  NEAR, поскольку по умолчанию Фортран принимает
по дальней ссылке.


     5.2.4.2  СТРОКИ СИ

     Си хранит строки в виде  простых  массивов  и  использует  в
качестве  ограничителя нулевой символ (числовой нуль, ASCII NUL).
Рассмотрим, например, строку, описанную следующим образом:

char str[] = "String of text"

Строка хранится в 15 байтах памяти следующим образом:

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| S | t | r | i | n | g |   | o | f |   | t | e | x | t |\0 |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
Формат строки Си

     Поскольку str является массивом, подобным любому другому, то
он  передается  по ссылке, как и другие массивы Си.  Для передачи
по значению массив следует описать как член структуры.


                               222



     Если  строка  Си  появляется  в  списке  аргументов,  то  Си
передает   адрес  строки.   Си  может  легко  передать  данные  в
фортрановскую строку фиксированной длины.

     При передаче  строк  в  Фортран  убедитесь,  что  вызываемая
процедура  получает  строку  по  ссылке  и захватывает достаточно
пространства.  Фортран ожидает приема строки фиксированной длины.
Кстати,  Си не может передавать Фортрану строки переменной длины:
строковые данные Фортрана  не  размещаются  в  стеке,  а  требуют
специальных   переменных   низкого  уровня,  доступных  только  в
Фортран-программе.


     5.2.4.3  СТРОКИ ПАСКАЛЯ

     Паскаль имеет два типа строк, каждый из  которых  использует
различный  формат:   тип STRING фиксированной длины и тип LSTRING
переменной длины.

     Формат, используемый для  STRING,  идентичен  формату  строк
Фортрана.    Формат   LSTRING   хранит   длину  в  первом  байте.
Рассмотрим, например, LSTRING, описанную как

VAR STR:LSTRING(14);
STR: := 'String of text'

     Строка хранится в 15-ти байтах памяти.  Первый байт содержит
длину строки текста.  Остальные байты содержат сам текст:

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|14 | S | t | r | i | n | g |   | o | f |   | t | e | x | t |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
Формат строки Паскаля

     Тип  данных  LSTRING  Паскаля  не  совместим   с   форматом,
используемым  в  Фортране.   Однако, вы можете передавать LSTRING
косвенно, присваивая  его  сначала  переменной  STRING.   Паскаль
поддерживает  такие присваивания, выполняя преобразование данных.
Типы STRING Паскаля и CHARACTER*n Фортрана эквивалентны.  Поэтому
паскалевские строковые переменные фиксированной длины легко могут
передаваться Фортрану.


     5.2.4.4  СТРОКИ ФОРТРАНА

     Фортран хранит  строки  в  виде  последовательности  байт  в
фиксированных    ячейках    памяти.    Заметьте,   что   никакого
ограничителя в конце строк нет, как  в  Си.   Рассмотрим  строку,
описанную следующим образом:



                               223



      STR = 'String of text'

     Строка хранится в 14-ти байтах памяти следующим образом:

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| S | t | r | i | n | g |   | o | f |   | t | e | x | t |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
Формат строки Фортрана

     Строки передаются по ссылке, подобно другим данным Фортрана.
Строки  переменной  длины типа CHARACTER*(*) (доступные в версиях
4.0 и выше)  не  могут  эффективно  передаваться  другим  языкам.
Однако, строки фиксированной длины могут передаваться без больших
затруднений; основное ограничение в том, что  оператор  INTERFACE
Фортрана должен описывать длину строки заранее.

     По умолчанию, Фортран передает строки  по  ссылке.   Однако,
если  на  процедуру действует атрибут C или PASCAL, то умолчанием
становится передача по значению.  Действительные строковые данные
не   включают   ограничитель,   если  только  вы  не  используете
особенность строк Си, описанную ниже.

     Фортран не может прямо передавать строки Бейсику,  поскольку
Бейсик   ожидает  приема  дексриптора  строки  при  ее  передаче.
Имеется, однако, следующий непрямой метод:

     1.  Зарезервируйте в Фортране  строку  фиксированной  длины,
         опишите  массив  двухбайтовых целых и рассматривайте его
         как дескриптор строки.

     2.  Первому  элементу  присвойте  адрес  строки  (с  помощью
         функции LOC), а второму элементу присвойте длину строки.

     3.  Передайте сам массив  целых  по  ссылке.   Бейсик  может
         принять  и  обработать  этот  массив  точно  так же, как
         дескриптор строки.

     Особенность строк Си перекрывает обычный формат  Фортрана  и
создает  строки,  которыми  можно эффективно манипулировать в Си.
Если  используется  особенность  строк  Си,  то  в  конец  строки
присоединяется  нулевой  байт,  а  обратные  слэши  (\),  которые
появляются в строке, трактуются как спецсимволы escape.

     Строки  Фортрана  преобразуются  в  строки  Си   добавлением
символа  C  сразу после строковой константы.  При этом между ними
нельзя  вставлять  запятые   или   любую   другую   промежуточную
пунктуацию,   кроме   пробелов.    Отметьте,   что  длина  строки
увеличивается на один байт из-за дополнительного нулевого  байта.
Это вам необходимо учитывать при описании строковой переменной.



                               224



     В следующем примере Фортран  передает  адрес  строки  в  Си.
Строка имеет формат Си.

      INTERFACE TO SUBROUTINE CONV [C] (S1)
      CHARACTER*5 S1 [REFERENCE]
      END
C
      CHARACTER*5 S1
      S1 = 'abcd' C
      CALL CONV (S1)

     Обратите внимание, что для S1  резервируется  дополнительный
байт   с   учетом  того,  что  при  преобразовании  в  строку  Си
добавляется нулевой байт (что выполняется в строке над оператором
CALL).    Заметьте  также,  что  ключевое  слово  REFERENCE  было
необходимо,  поскольку  атрибут  C  в  первой   строке   изменяет
умалчиваемый метод передачи параметра на передачу по значению.

     Фортран  и  Паскаль   используют   одинаковые   типы   строк
фиксированной  длины и поэтому могут легко передавать строки друг
другу.

     Модули Фортрана должны передавать в  Паскаль  строки  только
фиксированной  длины.   Процедуры Паскаля, в свою очередь, должны
ожидать приема строк фиксированной  длины.   Для  того,  чтобы  в
Паскале   задать  строковый  параметр  фиксированной  длины,  вам
необходимо сначала описать тип, как в примере ниже.

C     FORTRAN SOURCE CODE
C
      INTERFACE TO SUBROUTINE PS (S1)
      CHARACTER*4 S1
      END
C
      S1 = 'wxyz'
      CALL PS (S1)
      END

{ Pascal module }

module Psmod;
type stype4 = string(4);
procedure ps (vars str1 : stype4);


     5.3  ОБРАБОТКА СПЕЦИАЛЬНЫХ ТИПОВ ДАННЫХ

     Специальные типы данных, которые являются либо  структурными
(содержат  более чем одно поле), либо доступными извне, нуждаются
в специальном обсуждении  за  рамками  уже  рассмотренных  типов.


                               225



Например,  не  все  языки индексируют массивы одинаковым образом.
Обычные структуры, созданные в  одном  языке,  могут  неправильно
взаимодействовать с другим языком.


     5.3.1  МАССИВЫ

     Если вы программируете на нескольких языках,  то  помните  о
двух проблемах, специфичных для массивов:

     1.  Массивы иначе реализованы в Бейсике, поэтому  вы  должны
         принимать  особые меры предосторожности, когда передаете
         массив из Бейсика в Фортран.

     2.  Массивы  описываются  и  индексируются  по   разному   в
         различных языках.

     В этом разделе по очереди рассмотрены обе эти проблемы.

     ЗАМЕЧАНИЕ:  В Си массивы не могут передаваться по  значению,
если  только  не  описаны  в  структуре.  Но учтите, что передача
массивов по ссылке является, как правило, самой эффективной.


     5.3.1.1  ПРЕДОСТОРОЖНОСТИ ПРИ ПЕРЕДАЧЕ МАССИВОВ БЕЙСИКА

     Большинство языков фирмы Microsoft  позволяют  обращаться  к
массивам  непосредственно.   Например,  в  MSФортране  имя адреса
эквивалентно адресу первого элемента.  Такая  простая  реализация
возможна   потому,  что  адрес  данных  для  массива  никогда  не
меняется.

     Однако, Бейсик использует "дескриптор  массива",  который  в
некотором   отношении   аналогичен  дескриптору  строки  Бейсика.
Дескриптор массива необходим,  поскольку  Бейсик  может  сдвигать
положение   массива   в  памяти:   Бейсик  динамически  управляет
распределением памяти для массивов.

     Фортран не имеет эквивалента  дескриптору  массива  Бейсика.
И,  кроме  того, он лишен доступа к процедурам управления памятью
для массивов Бейсика.  Поэтому, вы  можете  безопасно  передавать
массивы  из  Бейсика только, если будете следовать следующим трем
правилам:

     1.  Передавайте адрес массива,  применяя  функцию  VARPTR  к
         первому   элементу  массива  и  передавая  результат  по
         значению.   Для  того,  чтобы  передать  дальний   адрес
         массива,   примемяйте   функции   VARPTR   и   VARSEG  и
         передавайте каждый результат по  значению.   Принимающий
         язык получает адрес первого элемента и рассматривает его


                               226



         как адрес всего массива.  После этого к  массивам  можно
         обращаться,  используя  обычный синтаксис индексирования
         массива.  Ниже приведен пример, иллюстрирующий, как  все
         это работает.

     2.  Процедура,  которая  принимает  массив,  не  должна,  по
         некоторым    обстоятельствам,    осуществлять   обратное
         обращение к  Бейсику.   Иначе  положение  массива  может
         измениться  и  адрес,  который  был  передан  процедуре,
         станет бессмысленным.

     3.  Бейсик может передать любой элемент массива по значению.
         При    этом   можно   не   следовать   указанным   мерам
         предосторожности.

     Следующий  пример  показывает,  как  массив  Бейсика   можно
передать в Фортран:

REM   BASIC SOURCE FILE
OPTION BASE 1
DEFINT A-Z
DIM A(20)
DECLARE SUB ArrFix(BYVAL Addr AS INTEGER)
.
.
.
CALL ArrFix(VARPTR(A(1)))
PRINT A(1)
END

C     FORTRAN SOURCE CODE
C
      SUBROUTINE ARRFIX (ARR)
      INTEGER*2 ARR [NEAR] (20)
      ARR(1) = 5
      END

     В этом примере Бейсик  считает,  что  передаваемый  аргумент
является  ближним  адресом элемента массива.  Фортран считает его
ближним адресом самого массива.   Со  стороны  обоих  языков  все
корректно.

     Параметр был описан как BYVAL  Addr  AS  INTEGER,  поскольку
необходимо  передать  ближний  (двухбайтовый)  адрес.  Если нужно
передать дальний (четырехбайтовый) адрес,  тогда  соответствующий
код выглядел бы следующим образом:

      DECLARE SUB ArrFix (BYVAL SegAddr AS INTEGER,
     + BYVAL Addr AS INTEGER)
      CALL ArrFix (VARSEG(A(0)), VARPTR(A(0)))


                               227



     Первым полем является сегмент, возвращенный функцией VARSEG.
Если   вы  используете  CDECL,  то  обязательно  передайте  адрес
смещения  перед  адресом  сегмента,  поскольку   CDECL   вызывает
передачу параметров в обратном порядке:

      DECLARE SUB ArrFix CDECL (BYVAL Addr AS INTEGER,
     + BYVAL SegAddr AS INTEGER)
      CALL ArrFix (VARPTR(A(0)), VARSEG(A(0)))

     Отметьте, что вы можете применить к массиву Бейсика  функции
LBOUND  и  UBOUND,  чтобы  определить  нижнюю и верхнюю границы и
передать результаты другой процедуре.  При этом размер массива не
нужно определять заранее.


     5.3.1.2  ОПИСАНИЕ И ИНДЕКСАЦИЯ МАССИВОВ

     Каждый язык имеет различный  способ  описания  и  индексации
массивов.   Индексация массива является чисто языковой концепцией
и не влечет  за  собой  преобразования  данных.   Ниже  приведены
различия в способах индексации элементов в каждом языке:

Метод
индексации       Объяснение
----------       ----------
Умалчиваемая     По умолчанию, Фортран индексирует первый элемент
нижняя           массива  единицей.  Бейсик и Си нулем.   Паскаль
граница          разрешает программисту начать индексацию с любого
                 целого  значения.  Последние  версии  MSФортрана
                 также позволяют задавать нижние границы с  любых
                 целых значений.

Индексация       Касается  только  массивов  с  более  чем  одной
по строкам или   размерностью.    При   пересчете   по   строкам,
по столбцам      используемом в Си и Паскале, самый правый индекс
                 меняется  быстрее.  При  пересчете  по столбцам,
                 используемом в Фортране и Бейсике (по умолчанию),
                 быстрее  меняется  самый  левый  индекс.   Таким
                 образом, в Паскале первыми  четырьмя  элементами
                 массива X(3,3) являются:
                 X[1,1] X[1,2] X[1,3] X[2,1]
                 В Фортране:
                 X(1,1) X(2,1) X(3,1) X(1,2)

     В этом примере предполагается, что нижние  границы  массивов
Паскаля  и  Фортрана  начинаются  с  1.   В  таблице 5.2 показаны
эквивалентные описания массивов в каждом языке.  В этой таблице r
относится  к  номеру  элементов  в строке (который меняется более
медленно), а c относится к номеру элементов  в  столбце  (который
меняется более быстро).


                               228



Таблица 5.2  Эквивалентные описания массивов
-----------------------------------------------------------------
Язык      Описание массива             Комментарий
-----------------------------------------------------------------
FORTRAN   type x(c,r)                  Умалчиваемые нижние
                                       границы равны 1

C         type x[r][c]                 При передаче по ссылке
          struct{type x[r][c];}x       При передаче по значению

Pascal    x:array[a..a+r-1,b..b+c-1]   Умалчиваемые нижние
          of type                      границы равны 1

BASIC     DIM x(c-1,r-1)               Умалчиваемые нижние
                                       границы равны 0
-----------------------------------------------------------------

     Приведенные  описания  распространяются   на   любое   число
размерностей.  Например, описание в Си

int arr1 [2][10][15][20]

эквивалентно описанию в Фортране

      INTEGER*2 ARR1(20,15,10,2)

     Каждое из следующих выражений описывает одно и то же место в
памяти для массива в соответствующем языке:

ARR1(9,3)    ! В Фортране, предполагая нижние границы равными 1

arr1[2][8]   /* В Си */

Arr1[3,9]    { В Паскале, предполагая нижние границы равными 1 }

ARR1(8,2)    ( В Бейсике, предполагая нижние границы равными 0 )

     В Бейсике, действующий  по  умолчанию  постолбцовый  порядок
хранения  элементов  массива  можно  изменить на построчный.  Для
этого на этапе компиляции в командной строке BL необходимо задать
опцию /R.

     ЗАМЕЧАНИЕ:   Константы,  используемые  в   Си   в   описании
массивов,  представляют  размерности, а не верхние границы, как в
других  языках.   Поэтому,  последним  элементом  в  массиве  Си,
описанном как int arr[5][5], является не arr[5][5], а arr[4][4].






                               229



     5.3.2  СТРУКТУРЫ, ЗАПИСИ И ТИПЫ, ОПРЕДЕЛЯЕМЫЕ ПОЛЬЗОВАТЕЛЕМ

     Тип struct в Си, тип, определяемый пользователем, в Бейсике,
тип  STRUCTURE  в  Фортране  и  тип  record  в  Паскале  являются
эквивалентными.  Поэтому эти типы данных могут передаваться между
языками Си, Паскаль, Фортран и Бейсик.

     Однако, на эти  типы  может  повлиять  метод  хранения.   По
умолчанию,   Си,   Фортран   и   Паскаль   используют   пословное
выравнивание (неупакованное  хранение)  для  всех  данных,  кроме
объектов  размером  с байт и массивов таких объектов.  На рисунке
5.1 показана разница между упакованным и неупакованным хранением.

Упакованное                  Выравненное по словам
(Си, Паскаль,                (только Си, Паскаль,
Бейсик, Фортран)             Фортран)
+-------------------+        +-------------------+
|       fld 1       |        |       fld 1       |
|- - - - -+---------+        |- - - - -+---------+
|  fld 1  |  fld 2  |        |  fld 1  |XXXXXXXXX|
+---------+- - - - -+        +---------+---------+
|       fld 2       |        |       fld 2       |
|- - - - -+---------+        |- - - - - - - - - -|
|  fld 2  |  fld 3  |        |       fld 2       |
+---------+- - - - -|        +-------------------+
|       fld 3       |        |       fld 3       |
+-------------------+        |- - - - -+---------+
                             |  fld 3  |XXXXXXXXX|
                             +---------+---------+
Рис.5.1  Хранение структур и записей

     Метод неупакованного хранения определяет, что для заполнения
могут быть добавлены произвольные байты, так что объекты из слова
или двойного слова начинаются с четной границы.  Кроме того,  все
вложенные структуры и записи начинаются с границы слова.

     Если структура или  запись  передаются  между  вызывающей  и
вызываемой  процедурами,  то  обе  процедуры  должны использовать
одинаковый метод хранения.  В противном случае  данные  не  будут
правильно    передаваться.    Простейшим   способом   обеспечения
совместимости между всеми тремя  языками  является  использование
упаковки  для модулей Си, Фортрана и Паскаля.  Метод упакованного
хранения может привести к некоторой потере скорости, но он  имеет
преимущество в создании меньших по размерам исполняемых файлов.

     В следующем примере  показано,  как  Фортран  может  создать
структуру.    Эта   же   самая  структура  имеется  в  FGRAPH.FD,
include-файле   графической   библиотеки,   который    инициирует
графические  процедуры.   Некоторые  из этих графических процедур
используют  подобные  структуры  для   хранения   координат   или


                               230



родственной информации.

ПРИМЕР

Пример структуры xycoord показан ниже.

      INTERFACE TO SUBROUTINE getcurrentposition
     + [FAR,C,ALIAS:"__f_getcurrentposition"](s)
      STRUCTURE/xycoord/
        INTEGER*2 xcoord ! Этот пример создает структуру,
        INTEGER*2 ycoord ! содержащую два значения INTEGER*2
      END STRUCTURE
      RECORD/xycoord/s
      END


     5.3.3  ВНЕШНИЕ ДАННЫЕ

     Вы  всегда  можете  совместно  использовать   данные   между
Фортраном  и  другими  языками  с помощью передачи параметров.  В
случае локальных переменных и всех  переменных  Бейсика  передача
параметров  является  единственным  удобным  способом совместного
использования данных.

     Тем не менее, процедуры Фортрана, Си и Паскаля  могут  прямо
обращаться  к  "внешним"  данным  (данным,  к которым можно прямо
обращаться из любого другого модуля).  Слово "внешние"  относится
к  данным,  которые являются как статическими, так и открытыми, -
то есть, к данным, которые хранятся в определенном  месте  памяти
(статические данные) и сделаны общедоступными для других модулей.
Компилятор  делает  объекты  данных  (переменные,  структуры  или
массивы)  доступными,  помещая в объектный файл их имена вместе с
информацией о размерах и типах.

     Внешние данные могут быть определены в модуле Фортрана,  Си,
Паскаля  или  ассемблера.   Обратите  внимание,  что  определение
данных отличается от внешнего описания.   Определение  заставляет
компилятор  создать объект данных, а внешнее описание информирует
компилятор, что объект должен находиться в другом модуле.

     Существует три требования для  программ,  которые  совместно
используют внешние данные несколькими языками:

     1.  Один из модулей должен определять статические данные.

     2.  Вы  можете  определить  объект  статических   данных   в
         Фортране  или  Си,  определяя  объект  данных  вне  всех
         функций и подпрограмм.  (Не используйте  в  Си  ключевое
         слово  static  для  объекта  данных,  который  вы хотите
         объявить общим).


                               231



     3.  Другие модули, которые будут обращаться к данным, должны
         объявить их внешними.

         В Фортране и Паскале вы можете объявить данные внешними,
         добавляя  к  описанию  данных  атрибут  EXTERN.  В Си вы
         можете объявить данные  внешними,  используя  декларацию
         extern, подобно декларации extern для функций.

     4.  Различия в соглашениях об именах должны быть разрешены.

         В Фортране и Паскале вы  можете  принять  соглашение  об
         именах  Си,  используя  атрибут  C  в  описании  данных.
         Аналогично, в Си вы можете принять соглашение об  именах
         Фортрана/Паскаля/ Бейсика, воздействуя атрибутом fortran
         или pascal на описание данных.

     ПРИМЕРЫ

     Следующие примеры иллюстрируют основные языковые особенности
внешних данных, описанные выше.

/* C source code */

int     thing1;      /* thing1 является общим и статическим */
extern  int thing2;  /* thing2 определено в другом модуле */
static  int thing3;  /* thing3 явл-ся статическим, но не общим */

ctest()
{
.
.
.
C     FORTRAN SOURCE CODE
C
      INTEGER*2 THING1 [C, EXTERN]
      INTEGER*2 THING2 [C]
C
C     THING1 определено в другом модуле с использованием
C     соглашения Си (_thing1)
C
C     THING2 определено здесь с использованием соглашения Си
C     (_thing2)
.
.
.
{ Pascal source code }
module Ptest;
 procedure Test;
    var
       thing1 [C, EXTERN] : integer; { обе переменных определены }


                               232



       thing2 [C, EXTERN] : integer; { извне и используют        }
.                                    { соглашение об именах Си   }
.
.

     В этих примерах переменные  thing1  и  thing2  определены  и
объявлены  в соответствии с соглашением об именах Си, так что они
будут помещены в каждый объектный файл  как  _thing1  и  _thing2.
Тем  не  менее,  вы  можете задать соглашение об именах Фортрана/
Паскаля/Бейсика с помощью следующих операторов Си:

int     fortran  thing1;
extern  int  fortran thing2;

     После этого атрибут C может быть  убран  из  исходного  кода
Фортрана  и Паскаля.  Каждый объектный файл будет содержать имена
THING1 и THING2.


     5.3.4  УКАЗАТЕЛИ И АДРЕСНЫЕ ПЕРЕМЕННЫЕ

     Вместо прямой передачи данных вы можете передать адрес части
данных.   Передача адреса эквивалентна передаче данных по ссылке.
В некоторых случаях, например,  для  массивов  Бейсика,  передача
адреса  является  единственным способом совместного использования
определенного вида данных двумя языками.

     В отличие от Паскаля  и  Си,  Фортран  не  имеет  формальных
адресных  типов.   Тем  не  менее,  Фортран  обеспечивает способы
хранения и передачи адресов.

     Фортран-программы определяют  ближние  и  дальние  адреса  с
помощью  функций LOC, LOCFAR и LOCNEAR.  Результат вы запоминаете
как INTEGER*2 (для LOCNEAR) или как INTEGER*4 (для LOCFAR).   LOC
имеет  то  же назначение, что и LOCNEAR в средней модели памяти и
LOCFAR в большой модели памяти.

     Если вы передаете результат LOC, LOCNEAR или LOCFAR в другой
язык, то удостоверьтесь, что передаете по значению.


     5.3.5  ОБЩИЕ БЛОКИ

     Вы  можете  передавать  отдельные  элементы   общих   блоков
Фортрана  или Бейсика в списке аргументов точно так же, как любые
другие данные.  Однако, можно сразу  дать  модулю  другого  языка
доступ ко всему общему блоку.

     Модули Паскаля и Си  могут  обращаться  к  элементам  общего
блока,   описав   структуру   или   запись   с   полями,  которые


                               233



соответствуют переменным  общего  блока.   Модули  Бейсика  также
используют  определяемый  пользователем  тип  для доступа к полям
общего блока Фортрана.

     Имея определенную структуру, запись или пользовательский тип
с  соответствующими  полями,  модуль  Паскаля или Си должен затем
связаться  с  самим   общим   блоком.    В   следующих   разделах
представлены методы получения доступа к общим блокам.


     5.3.5.1  ПЕРЕДАЧА АДРЕСА ОБЩЕГО БЛОКА

     Для передачи адреса  общего  блока  передайте  просто  адрес
первой  переменной  в блоке (то есть, передайте первую переменную
по ссылке).  Принимающий модуль Си  или  Паскаля  должен  ожидать
приема структуры или записи по ссылке.

     ПРИМЕР

     В этом примере Си-функция initcb принимает адрес  переменной
N,  который  она рассматривает как указатель на структуру с тремя
полями:

C     FORTRAN SOURCE CODE
C
      COMMON /CBLOCK/N,X,Y
      INTEGER*2 N
      REAL*8 X,Y
.
.
.
      CALL INITCB(N)
.
.
.
/* C source code */

struct block_type {
        int     n;
        double  x;
        double  y;
};

initcb(block_hed)
struct block_type *block_hed;
{
        block_hed->n = 1;
        block_hed->x = 10.0;
        block_hed->y = 20.0;
}


                               234



     5.3.5.2  ПРЯМОЙ ДОСТУП К ОБЩИМ БЛОКАМ

     Вы  можете  прямо  обращаться  к  общим   блокам   Фортрана,
определяя  структуру  (или  запись  в Паскале) с соответствующими
полями и используя затем методы,  описанные  в  разделе  "Внешние
данные".

     ПРИМЕР

     В этом примере cblock объявлена как внешняя  структура.   Вы
можете   обращаться  к  отдельным  полям  cblock,  которые  будут
соответствовать  полям  общего  блока  CBLOCK  в  исходном  файле
Фортрана.

struct block_type {
        int     n;
        double  x;
        double  y;
};

extern struct block_type fortran cblock;


     5.3.6  ИСПОЛЬЗОВАНИЕ ПЕРЕМЕННОГО ЧИСЛА ПАРАМЕТРОВ

     Некоторые функции Си,  например  printf,  могут  каждый  раз
вызываться  с различным числом параметров.  Для того, чтобы такую
функцию вызвать из Фортрана,  вам  необходимо  подавить  проверку
типов,  которая  обычно  вынуждает  делать  вызов с фиксированным
числом  параметров.   Вы  можете  вызывать  такие   процедуры   с
переменным  числом  параметров,  включая  в  интерфейс  процедуры
атрибут VARYING вместе с атрибутом C.  Атрибут C  вам  необходимо
использовать,  поскольку  переменное число параметров осуществимо
только с соглашением о вызовах Си.

     Атрибут    VARYING    препятствует    Фортрану     выполнять
сопоставление  числа параметров.  Каждый раз при вызове процедуры
вы сможете передавать больше или меньше параметров, чем описано в
интерфейсе процедуры.  Тем не менее, каждый фактический параметр,
который вы передаете, будет проверяться на соответствие с  типами
формальных   параметров,   объявленных   в  интерфейсе.   Фортран
сравнивает тип первого фактического  параметра  с  типом  первого
формального параметра (если имеется), второй фактический параметр
со вторым формальным параметром и т.д.

     Поскольку число параметров  не  фиксировано,  то  вызываемая
процедура  должна  обладать  некоторым механизмом для определения
того,  как  много  параметров  ожидать.   Часто  эта   информация
определяется  первым  параметром.   Например,  Си-функция  printf
просматривает строку формата,  передаваемую  в  качестве  первого


                               235



параметра.   Число  полей  в строке формата определяет, как много
дополнительных параметров должна ожидать функция.

     ПРИМЕР

     В примере продемонстрировано использование атрибута  VARYING
для   вызова   printf   непосредственно  из  Фортрана  (программу
необходимо скомпилировать и связать с большой моделью памяти  Си,
так чтобы printf была доступна).

      INTERFACE TO INTEGER*2 FUNCTION printf [C, VARYING]
      END

      CHARACTER*30 str1, str2
      INTEGER*2 n, printf
      str1 = 'This is %s string, number %d.'C
      str2 = 'formatted'C
      n = 1
      n = printf(LOC(str1), LOC(str2), n)
      END

     Вы может написать интерфейс к printf в Фортране  так,  чтобы
строка  формата  могла  быть  переменной длины, используя функцию
LOC.




























                               236
