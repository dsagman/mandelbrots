


                          Приложение  А

                           МЕТАКОМАНДЫ

     В этом приложении описаны  все  метакоманды  MSФортрана.   В
отдельном   разделе  объясняется,  как  используются  метакоманды
условной компиляции для управления компиляцией  отдельных  секций
программы.    Завершающая   часть  представляет  собой  подробное
описание всех метакоманд в алфавитном порядке.

     Метакоманды указывают компилятору MSФортрана, как вы  хотите
компилировать  исходный  код.   Обратите  внимание, что некоторые
опции  командной  строки  дублируют  функции  метакоманд.    Если
имеется   противоречие  между  метакомандой  и  опцией  командной
строки, то метакоманда имеет приоритет.

     Ниже  в  таблице  перечислены  все  метакоманды  MSФортрана.
Некоторые  метакоманды  (например,  $DO66  или  $FREEFORM)  могут
использоваться в программе только один раз, в то время как другие
могут  появляться  в  любом месте программы.  Это позволяет гибко
управлять   некоторыми   особенностями   компиляции    (например,
оптимизацией циклов).

МЕТАКОМАНДЫ
-----------------------------------------------------------------
Метакоманда         Действие                      Умолчание
-----------------------------------------------------------------
$DEBUG[[:string]]   Включает проверку времени     $NODEBUG
                    выполнения для целых арифме-
                    тических операций и некоторые
                    другие проверки. $NODEBUG
                    выключает проверку.

$DECLARE            Генерирует предупреждения     $NODECLARE
                    о неинициированных перемен-
                    ных. $NODECLARE отключает
                    эти сообщения.

$DEFINE symbol-     Создает (и, при необходимо-   $UNDEFINE
name[[=val]]        сти, присваивает значение)
                    переменной, существование
                    которой может быть проверено
                    во время условной компиляции.
                    $UNDEFINE удаляет символи-
                    ческое имя переменной.

$DO66               Использует семантику Фор-     $DO66 не
                    трана 66 для операторов DO.   установлено
-----------------------------------------------------------------



                               403



-----------------------------------------------------------------
Метакоманда         Действие                      Умолчание
-----------------------------------------------------------------
$ELSE               Помечает начало блока ус-     Нет
                    ловной компиляции, который
                    компилируется, если логичес-
                    кое условие в метакоманде
                    $IF дает .FALSE.

$ELSEIF expr        Помечает начало нового блока  Нет
                    условной компиляции, к-рый
                    компилируется, если логичес-
                    кое условие в метакоманде $IF
                    равно .FALSE., а expr равно
                    .TRUE.

$ENDIF              Завершает блоки условной      Нет
                    компиляции $IF, $IF...$ELSE
                    или $IF...$ELSEIF.

$FLOATCALLS         Генерирует вызовы подпрог-    $NOFLOATCALLS
                    рамм из библ-ки эмулятора.
                    $NOFLOATCALLS заставляет
                    компилятор генерировать
                    встроенные команды преры-
                    вания.

$FREEFORM           Использует свободный формат   $NOFREEFORM
                    для исходного кода.
                    $NOFREEFORM использует фик-
                    сированный формат.

$IF expr            Помечает начало блока ус-     Нет
                    ловной компиляции. Последую-
                    щие операторы компилируются,
                    если условное выражение
                    дает .TRUE.

$INCLUDE:'file'     Содержимое файла file         Нет
                    вставляется в данном месте
                    текущего исходного файла.

$LARGE[[:name       Помечает именованные массивы  Нет
[[,name]]]]...      для адресации вне сегмента
                    DGROUP. $NOTLARGE отменяет
                    $LARGE для именованного
                    массива. Если name опущено,
                    то эти метакоманды влияют на
                    все массивы.
-----------------------------------------------------------------


                               404



-----------------------------------------------------------------
Метакоманда         Действие                      Умолчание
-----------------------------------------------------------------
$LINESIZE:n         Последующие страницы лис-     $LINESIZE:80
                    тинга делает шириной n стол-
                    бцов. Минимальное n равно
                    40, максимальное n равно 132.

$LIST               Начинает генерацию листин-    $LIST
                    говой информации, к-рая
                    помещается в файл листинга.
                    $NOLIST отменяет генерацию
                    листинга.

$LOOPOPT            Оптимизирует циклы в после-   $LOOPOPT
                    дующем коде. $NOLOOPOPT от-
                    меняет оптимизацию циклов.

$MESSAGE:string     Передает строку символов      Нет
                    на стандартное выходное
                    устройство.

$PACK:n             Устанавливает число байтов    $PACK:2
                    для размера упаковки.
                    n должно быть равно 1, 2
                    или 4.

$PAGE               Начинает новую страницу       Нет
                    листинга.

$PAGESIZE:n         Задает длину страницы лис-    $PAGESIZE:63
                    тинга. Минимальное n равно
                    15.

$STORAGE:n          Резервирует n байт памяти     $STORAGE:4
                    (2 или 4) для всех перемен-
                    ных LOGICAL или INTEGER.

$STRICT             Запрещает возможности MS-     $NOTSTRICT
                    Фортрана, не входящие в
                    полный стандарт языка 1977.
                    $NOTSTRICT разрешает их.

$SUBTITLE:subtitle  Дает подзаголовок для         $SUBTITLE:"C (1)
                    последующих страниц
                    листинга.

$TITLE:title        Дает заголовок для следую-    $TITLE:"C (1)
                    щих страниц листинга.
-----------------------------------------------------------------


                               405



-----------------------------------------------------------------
Метакоманда         Действие                      Умолчание
-----------------------------------------------------------------
$TRUNCATE           Усекает переменные до шести   $NOTRUNCATE
                    символов. $NOTRUNCATE выклю-
                    чает отсекание.
-----------------------------------------------------------------
(1) Пустая строка C, то есть, нет заголовка или подзаголовка.

     Любая  строка   со   знаком   доллара   в   первом   столбце
интерпретируется   как   метакоманда.    Метакоманда   вместе   с
аргументами  (если  есть)  должна  помещаться  в  одной  исходной
строке; символы продолжения не допускаются.


     ИСПОЛЬЗОВАНИЕ МЕТАКОМАНД УСЛОВНОЙ КОМПИЛЯЦИИ

     Операторы условного  выполнения  Фортрана  IF...THEN...ELSE,
ELSE  и  ELSEIF контролируют выполнение блоков операторов.  Точно
так же, метакоманды условной компиляции  контролируют  компиляцию
отдельных  секций  исходного  кода.   Эти специальные метакоманды
облегчают включение или пропуск  проверочного  кода,  настраивают
код  для конкретных приложений, позволяя контролировать включение
отдельных  секций  или  опускать  незавершенный  код   во   время
разработки программы.

     Как и все другие,  метакоманды  условной  компиляции  должны
начинаться в первом столбце со знака доллара:

$IF cond-expr
$ELSE
$ELSEIF cond-expr
$ENDIF

     В  метакомандах  условной  компиляции   условные   выражения
(cond-exprs) могут принимать несколько форм.  Простейшим является
логическое значение Фортрана, .TRUE.  или .FALSE..

$IF .TRUE.
      WRITE (*, '('' Это компилируется, если .TRUE.'')')
$ELSE
      WRITE (*, '('' Это компилируется, если .FALSE.'')')
$ENDIF

     В этом примере компилируется  первый  блок  кода,  а  второй
игнорируется.     При    смене    .TRUE.    на   .FALSE.    будет
компилироваться  только  второй  блок.    Хорошей   альтернативой
является  создание  одного  или  нескольких  символических имен в
начале программы с помощью метакоманды $DEFINE.



                               406



$DEFINE symbol-name

     Наличие или отсутствие конкретного определения проверяется с
помощью  условного  выражения  DEFINED(symbol) в метакоманде $IF.
DEFINED(symbol)  равно  .TRUE.,  если  symbol   определен   ранее
метакомандой  $DEFINE  без  присвоения  ему какого-либо значения.
Преимущество этого способа в том, что  программист  может  менять
смысл  символа  по  ходу  программы,  просто  вставляя или убирая
отдельную метакоманду.

     Например, в следующем примере  truthvar  определен  заранее,
поэтому  DEFINED  (truthvar) равно .TRUE.  и компилируется первый
блок операторов.  Если метакоманду $DEFINE truthvar  удалить,  то
будет компилироваться второй блок операторов.

$DEFINE truthvar

$IF DEFINED (truthvar)
   WRITE (*,'(''Это компилируется, если truthvar     DEFINED'')')
$ELSE
   WRITE (*,'(''Это компилируется, если truthvar not DEFINED'')')
$ENDIF

     Метакоманда  $UNDEFINE  отменяет  определение  символа.    В
следующем  примере  $UNDEFINE  отменяет  truthvar, а в результате
будет компилироваться второй блок операторов.

$DEFINE truthvar
$UNDEFINE truthvar

$IF DEFINED (truthvar)
   WRITE (*,'(''Это компилируется, если truthvar     DEFINED'')')
$ELSE
   WRITE (*,'(''Это компилируется, если truthvar not DEFINED'')')
$ENDIF

     Вы можете определять сколько  угодно  символических  имен  в
любом  месте программы, причем эти символы не будут конфликтовать
с  идентификаторами  или  именами  переменных  Фортрана.    Можно
определять  такие  имена,  как  data,  sin, equivalence или имена
внешних процедур.

     Метакоманда $DEFINE может также  присваивать  символическому
имени   целое   значение   (допускается  любое  4-байтовое  целое
значение):

$DEFINE choice = 100000

$IF choice .NE. 100000
      WRITE (*, '(''Это компилируется, если choice.NE.100000'')')


                               407



$ELSE
      WRITE (*, '(''Это компилируется, если choice.EQ.100000'')')
$ENDIF

     В этом примере будет компилироваться второй блок операторов.
(DEFINED(choice)   также  даст  .FALSE.,  поскольку  choice  было
присвоено  значение).   Пример  показывает  также,  что  условное
выражение  может  включать  операторы  отношения  Фортрана (.EQ.,
.NE.,  .LT.,  .LE.,  .GT.,  .GE.).   Может  использоваться  также
оператор .NOT.:

$DEFINE choice = 100000
$DEFINE receiv = choice

$IF .NOT. (receiv .NE. 100000)
      WRITE (*, '(''Это компилируется, если receiv.EQ.100000'')')
$ELSE
      WRITE (*, '(''Это компилируется, если receiv.NE.100000'')')
$ENDIF

     Возможность присвоения символическим именам  значений  целых
переменных  дает  программисту  больший  контроль над компиляцией
блоков операторов:

$DEFINE upper = 3
$DEFINE lower = -1

$IF upper .LT. 3
   WRITE (*,'(''Компилируется, если upper .LT. 3'')')
$ELSEIF lower .GT. -2
   WRITE (*,'(''Компилируется, если upper.GE.3 и lower.GT.-2'')')
$ENDIF

     Могут использоваться также условные операторы Фортрана .AND.
и .OR.:

$DEFINE upper
$DEFINE lower = -1

$IF (DEFINED (upper) .OR. (lower .LE. -2)) .AND. middle
   WRITE (*,'(''Компилируется, если все условия удовлетворены'')')
$ENDIF

     В этом примере оценка полного выражения дает .FALSE.  и блок
операторов не будет компилироваться.

     В конце строки  метакоманды  могут  находиться  комментарии,
начинающиеся с восклицательного знака:

$DEFINE test       ! контролирует компиляцию проверочного кода


                               408



     ОПИСАНИЕ МЕТАКОМАНД

     Далее  в  алфавитном   порядке   описаны   все   метакоманды
MSФортрана.


-----------------
$DEBUG и $NODEBUG
-----------------

     $DEBUG  предписывает  компилятору  выполнить  дополнительную
проверку  и  расширенную  обработку  ошибок  и, кроме того, может
использоваться  для  условной  компиляции.    $NODEBUG   отменяет
действие $DEBUG.

     $[NO]DEBUG[:string]

     Умолчанием  является  $NODEBUG.    Эти   метакоманды   могут
появляться в любом месте программы, разрешая или отменяя средства
отладки.   Если  действует  $DEBUG,   то   компилятор   выполняет
следующие действия:

      o  Проверяет целую арифметику на переполнение.

      o  Проверяет значения GOTO (присваиваемого) по списку меток
         в операторе присваиваемого GOTO.

      o  Обеспечивает систему обработки ошибок времени выполнения
         именами   файлов   и  номерами  строк.   Если  во  время
         выполнения происходит ошибка, то на экране высвечивается
         имя файла и номер строки.

      o  Проверяет диапазоны индексов и подстрок.

      o  Проверяет диапазон присваивания.  Ошибки возникают, если
         большие  целые  переменные  присваиваются  меньшим целым
         переменным,   например,   если   переменная    INTEGER*4
         присваивается  переменной  INTEGER*2.   Если  $DEBUG  не
         действует,  то  переменная  усекается,  об   ошибке   не
         сообщается,   и   программа  возвращает  непредсказуемые
         результаты.   В  случае  вещественных  чисел  об  ошибке
         всегда сообщается.

      o  Проверяет  оператор  CASE  DEFAULT.   Если  в  операторе
         SELECT  CASE  нет  CASE  DEFAULT и значение проверяемого
         выражения не соответствует ни одному из  значений  ни  в
         одном  из  CASE,  то выполнение программы прекращается с
         сообщением  об  ошибке.   (Без  $DEBUG  об   ошибке   не
         сообщается  и  управление  передается  на  следующий  за
         SELECT CASE оператор).


                               409



     Если задан необязательный  параметр  string,  то  символы  в
string  определяют, что все строки текста программы, начинающиеся
в  первом  столбце  с  этих  символов,  должны   компилироваться.
Поскольку  буква  C  всегда  обозначает комментарий, то появление
этой буквы в string игнорируется.   $DEBUG  может  использоваться
для  условной  компиляции  только  в  том  случае, если не задана
метакоманда $FREEFORM.

     Пример:

C  Если была задана метакоманда $FREEFORM, то
C  следующая строка вызовет сообщение об ошибке.
$DEBUG:'ABCD'
A     I = 1
E     I + 2
B     I = I + 1
F     I = I * I
C  Это всегда является комментарием. I равно 2, поскольку
C  выполняются только операторы A и B.


---------------------
$DECLARE и $NODECLARE
---------------------

     $DECLARE генерирует предупреждения для  переменных,  которые
не были инициированы.  $NODECLARE отменяет эти сообщения.

     $[NO]DECLARE

     Умолчанием является $NODECLARE.  Если  задана  $DECLARE,  то
предупреждение   генерируется   при  первом  использовании  любой
переменной,   которой   ранее   не   было   присвоено   значение.
Метакоманда   $DECLARE   является,   главным  образом,  средством
отладки, выявляющим переменные, которые не  были  соответствующим
образом   инициированы,   или   были   определены,  но  нигде  не
использовались.

     Пример:

$DECLARE
C   Поскольку переменной z не было присвоено значение, то
C   ее использование в операторе с меткой 100 вызовет ошибку.
      REAL x, y, z
      y = 1.0
100   x = y + z






                               410



-------------------
$DEFINE и $NODEFINE
-------------------

     $DEFINE создает символическую переменную, существование  или
значение  которой  может  быть проверено при условной компиляции;
$UNDEFINE устраняет символ.

$DEFINE symbol-name[=val]
$NODEFINE symbol-name

Параметр       Описание
--------       --------
symbol-name    Алфавитноцифровой  идентификатор длиной до 31 сим-
               волов.  Может включать символы доллара и подчерки-
               вания, но не может начинаться с числа или  символа
               подчеркивания.
val            Любое положительное или отрицательное число в диа-
               пазоне INTEGER*4.

     Умолчанием является  $NODEFINE.   Существование  symbol-name
проверяется  в  условном  выражении  DEFINED(symbol-name).   Если
symbol-name было присвоено  значение,  то  в  условном  выражении
DEFINED  оно  дает  .FALSE..   Символические  имена  локальны  по
отношению к  метакомандам  и  могут  дублировать  ключевые  слова
Фортрана,  встроенные функции или пользовательские идентификаторы
без каких-либо конфликтов.

     Метакоманды $DEFINE и $NODEFINE  могут  находиться  в  любом
месте программы.

     Пример:

$DEFINE  testflag
$DEFINE  testval = 2
.
.
$UNDEFINE  testflag


-----
$DO66
-----

     $DO66  заставляет  операторы  DO  соответствовать  семантике
Фортрана 66.

     $DO66




                               411



     Вы должны  соблюдать  следующие  правила  при  использовании
$DO66:

      o  $DO66  должна  предшествовать   первому   описанию   или
         исполняемому  оператору  исходного  файла, в котором она
         находится.

      o  Перед $DO66 может стоять только строка  комментария  или
         другая метакоманда.

      o  $DO66 может появляться в исходном файле только один раз.

     Если действует $DO66, то  используется  следующая  семантика
Фортрана 66:

      o  Операторы внутри цикла DO всегда выполняются по  крайней
         мере один раз.

      o  Допускается передача управления  внутрь  тела  оператора
         DO.


     Заметьте, что в Фортране 77 цикл DO может не выполниться  ни
разу и не допускается передача управления внутрь цикла.

-----
$ELSE
-----
     Отмечает начало блока метакоманды $ELSE.

     $ELSE

     Если логическое выражение в соответствующей метакоманде  $IF
или  $ELSEIF  дает  .FALSE.,  то  компилируется блок $ELSE.  Блок
$ELSE состоит из любых операторов  между  метакомандами  $ELSE  и
$ENDIF на одном и том же уровне $IF.  Пример:

$DEFINE flag
$IF DEFINED (flag)
      WRITE (*,'(''Компилируется, если flag определен'')')
$ELSE
      WRITE (*,'(''Компилируется, если flag не определен'')')
$ENDIF

-------
$ELSEIF
-------

     Вызывает компиляцию блока операторов, если  expression  дает
.TRUE., а соответствующая метакоманда $IF дает .FALSE..


                               412



     $ELSEIF(expression)

     где expression - логическое выражение.

     Логическое выражение в метакоманде $ELSEIF может  иметь  два
вида.   Первым  является оператор условной компиляции DEFINED, за
которым следует символическое имя в скобках.  Если  символическое
имя  было ранее определено в метакоманде $DEFINE без присваивания
значения, то DEFINED(symbol_name) даст .TRUE..  Если  symbol_name
не  определено  метакомандой $DEFINE или определено со значением,
то DEFINED(symbol_name) даст .FALSE..

     Второй формой является логическое  сравнение,  где  значение
символа  сравнивается  с  целой  константой или значением другого
символа с помощью операторов Фортрана  .EQ.,  .NE.,  .GT.,  .LT.,
.GE.,  .LE.   и  .NOT..   Далее результаты такого сравнения могут
оцениваться с помощью операторов .AND., .OR., .XOR.  и .NOT..

     Соответствующий блок $ELSEIF состоит  из  любых  выполняемых
операторов  между метакомандой $ELSEIF и следующими метакомандами
$ELSEIF, $ELSE или $ENDIF на этом же уровне $IF.

     Пример:

$DEFINE flag
$DEFINE testval = 3
$IF (.NOT. DEFINED (flag))
   WRITE (*,'(''Компилируется, если flag не определен'')')
$ELSEIF (testval .GT. 3)
      WRITE (*,'(''Компилируется, если flag определен .AND.
     +testval .GT. 3'')')
$ELSE
      WRITE (*,'(''Компилируется, если flag определен .AND.
     +testval .LE. 3'')')
$ENDIF
$ENDIF

------
$ENDIF
------

     Заканчивает блок метакоманды $IF.

     $ENDIF

     В программной единице  для  каждой  метакоманды  $IF  должна
иметься соответствующая метакоманда $ENDIF.  Пример:

$DEFINE flag
$DEFINE testval = 3


                               413



$IF DEFINED (flag)
      WRITE (*,'(''Компилируется, если flag определен'')')
$ENDIF
.
.
$IF (testval .LT. 1) .AND. .NOT. DEFINED (flag)
      WRITE (*,'(''Компилируется, если flag .EQ. 3'')')
$ELSE
      WRITE (*,'(''Компилируется, если flag .NE. 3'')')
$ENDIF


---------------------------
$FLOATCALLS и $NOFLOATCALLS
---------------------------

     $FLOATCALLS заставляет выполнять операции с плавающей точкой
с   помощью   вызова   библиотечных  подпрограмм.   $NOFLOATCALLS
заставляет выполнять эти операции с помощью встроенных инструкций
сопроцессора, генерируемых компилятором.

     $[NO]FLOATCALLS

     Умолчанием является $NOFLOATCALLS.  Пример:

$FLOATCALLS
      REAL x, sine

      WRITE (*, 100)
 100     FORMAT (1X, 'ENTER x: '\)
      READ  (*, '(F10.5)') x

      WRITE (*, 200) x, SINE (x, .00001)
 200  FORMAT (1X, 'THE SINE OF ', F10.5, ' = ', F9.6)
      END

C     Функция вычисляет синус X.
C     Вместо встроенных инструкций генерируются библиотечные
C     вызовы, что позволяет выполнять программу на машинах
C     без сопроцессора.

      REAL FUNCTION SINE (x, eps)
      REAL x, y, z, next, i, eps
      z    = AMOD (x, 6.2831853)
      y    = z
      i    = 4.0
      next = -z * z * z / 6.0
 100  IF (ABS (next) .GE. eps) THEN
         y    = y + next
         next = -next * z * z / (i * (i + 1.0))


                               414



         i    = i + 2.0
         GOTO 100
      END IF
      SINE = y
      END


-----------------------
$FREEFORM и $NOFREEFORM
-----------------------

     $NOFREEFORM определяет, что исходный файл имеет  стандартный
формат  Фортрана.   $FREEFORM определяет, что исходный файл имеет
свободный формат.

     $[NO]FREEFORM

     Эта метакоманда (если задана)  должна  предшествовать  любым
операторам Фортрана.  По умолчанию действует $NOFREEFORM, который
говорит компилятору, что исходный код  имеет  стандартный  формат
Фортрана:   метки  в  столбцах  с  1  по 5, символы продолжения в
столбце 6, операторы в столбцах с 7 по 72, а символы за  столбцом
72 игнорируются.  $FREEFORM говорит компилятору, что исходный код
имеет следующий формат:

      o  Двойная  кавычка   в   столбце   1   обозначает   строку
         комментария.   Восклицательный  знак  за  символьной или
         холлеритовской  константой   также   обозначает   начало
         комментария.

      o  Начальные строки могут начинаться с любого столбца.

      o  Первый  непустой  символ  начальной  строки  может  быть
         цифрой   (первой  цифрой  в  номере  оператора).   Номер
         оператора может содержать до пяти цифр.   Для  отделения
         номера оператора от первого символа оператора пробелы не
         требуются.

      o  Если последним непустым символом  строки  является  знак
         минус   (исключая   комментарий),  то  следующая  строка
         рассматривается   как   строка   продолжения.     Строка
         продолжения может начинаться с любого столбца.

      o  В  столбце  1  в   качестве   маркера   комментария   не
         допускаются символы алфавита и звездочки.

     Пример:





                               415



$FREEFORM
"
" Вычисляется синус числа x.
"
REAL x, epsi, z, sine, next
epsi = 0.0001

      WRITE (*, 100)
 100     FORMAT (1X, 'ENTER x: '\)
      READ  (*, '(F10.5)') x

      z    = AMOD (x, 6.2831853)
      sine = z
      i    = 4.0
      next = -z * z * z / 6.0

 200  IF (ABS (next) .GE. epsi) THEN
         sine = sine + next
         next = -next * z * z / (i * (i + 1.0))
         i    = i + 2.0
         GOTO 200
      END IF

      WRITE (*, 300) x, sine
 300  FORMAT (1X, 'THE SINE OF ', F10.5, ' = ', F12.10)
      END


---
$IF
---

     Если expression дает .TRUE., то  компилируются  операторы  в
блоке $IF; если expression дает .FALSE., то управление передается
на следующую метакоманду $ELSE, $ELSEIF или $ENDIF того же уровня
$IF.

     $IF expression

     где expression - логическое выражение.

     Логическое выражение в метакоманде $IF может иметь два вида.
Первым  является  ключевое  слово  DEFINED,  за  которым  следует
символическое имя в скобках.  Если символическое имя  было  ранее
определено  в  метакоманде  $DEFINE  без  присвоения значения, то
DEFINED(symbol_name) даст .TRUE..  Если symbol_name не определено
метакомандой    $DEFINE   или   определено   со   значением,   то
DEFINED(symbol_name) даст .FALSE..




                               416



     Второй формой является логическое  сравнение,  где  значение
символа  сравнивается  с  целой  константой или значением другого
символа с помощью операторов Фортрана  .EQ.,  .NE.,  .GT.,  .LT.,
.GE.,  .LE.   и  .NOT..   Далее результаты такого сравнения могут
оцениваться с помощью операторов .AND., .OR., .XOR.  и .NOT..

     Пример:

$DEFINE flag
$DEFINE testval = 3

$IF DEFINED (flag)
   WRITE (*,'(''Компилируется, если flag определен'')')
$ENDIF
.
.
$IF (testval .LT. 1) .AND. .NOT. DEFINED (flag)
      WRITE (*,'(''Testval .LT. 1 .AND. flag .NOT. DEFINED'')')
$ELSE
      WRITE (*,'(''Testval .GE. 1 .OR.  flag       DEFINED'')')
$ENDIF


--------
$INCLUDE
--------

     Вставляет содержимое  заданного  текстового  файла  в  место
расположения метакоманды $INCLUDE.

     $INCLUDE:'filename'

     где filename - имя текстового файла.

     Аргумент filename должен быть  действительной  спецификацией
файла  для  операционной  системы.  Компилятор считает содержимое
включаемого  файла  частью  файла  программы  и  компилирует  его
немедленно.   По  окончании его обработки компилятор возобновляет
обработку исходного файла со строки,  следующей  за  метакомандой
$INCLUDE.

     Include-файлы используются, главным образом, для данных  или
программных  единиц,  которые появляются в нескольких программах.
Эти файлы чаще всего содержат подпрограммы  и  функции,  описания
общих блоков и операторы EXTERNAL, INTERFACE TO и INTRINSIC.

     Include-файлы  могут  содержать  также  другие   метакоманды
$INCLUDE   и  операторы  INCLUDE  (вложенные  включаемые  файлы).
Компилятор  допускает  до  десяти  уровней  вложения   метакоманд
$INCLUDE или операторов INCLUDE в различных комбинациях.


                               417



     Пример:

     Эта программа реализует стек, описывая общие данные стека во
включаемом  файле.   Содержимое  файла STKVARS.FOR (показан ниже)
вставляется в исходный код вместо  каждой  метакоманды  $INCLUDE.
Это  гарантирует,  что  все ссылки на общую память для переменных
стека согласуются.

      INTEGER i
      REAL    x
$INCLUDE:'stkvars.for'

C     считывает пять вещественных чисел
      DO 100 i = 1, 5
         READ (*, '(F10.5)') x
         CALL Push (x)
 100  CONTINUE

C     записывает числа в обратном порядке
      WRITE (*, *) ' '
      DO 200 i = 1,5
         CALL Pop (x)
         WRITE (*, *) x
 200  CONTINUE
      END

      SUBROUTINE Push (x)
C     Загружает элемент x на верхушку стека.
      REAL x
$INCLUDE:'stkvars.for'

      top = top + 1
      IF (top .GT. stacksize)  STOP 'Стек переполнен'
      stack(top) = x
      END

      SUBROUTINE Pop (x)
C     Перемещает элемент из верхушки стека в x.
      REAL x
$INCLUDE:'stkvars.for'

      IF (top .LE. 0)  STOP 'Стек пустой'
      x = stack(top)
      top = top - 1
      END

     Далее приведен файл STKVARS.FOR:

C     Этот файл содержит описание общего блока для реализации
C     стека. Поскольку этот файл содержит оператор присваивания,


                               418



C     то он должен располагаться только после всех описаний в
C     каждой программной единице.

      REAL    stack(500)
      INTEGER top, stacksize
      COMMON  /stackbl/ stack, top
      stacksize = 500


------------------
$LARGE и $NOTLARGE
------------------

     $LARGE определяет, что фактический аргумент  может  занимать
более   одного   сегмента   (64K);   $NOTLARGE   определяет,  что
фактический аргумент не может занимать более одного сегмента.

     $[NOT]LARGE[:names]

     где names - одно или более имен массивов.  Если задано более
одного  имени,  то они разделяются запятыми.  Если names задано в
метакоманде $LARGE, то оно означает, что  массив  или  формальный
аргумент-массив может занимать более одного сегмента.  Если names
задано  в  метакоманде  $NOTLARGE,  то  оно  ограждает   заданные
элементы   от  действия  метакоманды  $LARGE,  которая  не  имеет
аргументов.

     Умолчанием  является  $NOTLARGE.   Массивы,   которые   явно
превышают  64K,  автоматически размещаются в нескольких сегментах
вне умалчиваемого сегмента данных и для  них  не  нужно  задавать
$LARGE.   В  одной  программной единице могут находиться не более
одной метакоманды $LARGE или не более одной метакоманды $NOTLARGE
без аргументов.  Обратите внимание, что использование метакоманды
$LARGE для всей программы соответствует гигантской модели памяти.


---------
$LINESIZE
---------

     $LINESIZE форматирует последующие страницы листинга  шириной
n столбцов.

     $LINESIZE:n

     где n - целое число в диапазоне от 80  до  132.   Умолчанием
является 80.





                               419



     Пример:

$LINESIZE:100
C     Листинг этой программы будет шириной 100 столбцов:
      REAL x
      x = 20
      WRITE (*, 100) x, SQRT(x)
 100  FORMAT(' Квадратный корень от ',f5.2,' равен ',f7.4)
      END


---------------
$LIST и $NOLIST
---------------

     $LIST передает последующую  листинговую  информацию  в  файл
листинга,  заданный  при  старте  компилятора;  $NOLIST запрещает
дальнейшую  генерацию   листинговой   информации   до   появления
следующей метакоманды $LIST.

     $[NO]LIST

     Умолчанием является $LIST.  Если при вызове компилятора файл
листинга не задан, то метакоманда не действует.


--------
$LOOPOPT
--------

     $LOOPOPT  включает  оптимизацию   циклов   компилятором,   а
$NOLOOPOPT запрещает ее.

     $[NO]LOOPOPT

     $LOOPOPT является умолчанием.   Оптимизация  цикла  включает
размещение   инвариантных   выражений   вне   цикла  и  упрощение
вычислений в цикле для ускорения вычислений.  Оптимизация  циклов
не  всегда  целесообразна,  поскольку  при  этом могут возникнуть
нежелательные последствия.


--------
$MESSAGE
--------

     $MESSAGE посылает строку символов  на  стандартное  выходное
устройство при первом проходе компилятора.




                               420



     $MESSAGE:string

     где string - символьная константа.

     Строка  должна  быть  заключена  в  кавычки  или  апострофы.
Пример:  $MESSAGE:'Компиляция программы'


-----
$PACK
-----

     Контролирует начальные адреса переменных в структурах.

     $PACK[:{1|2|4}]

     Если  в  файле   нет   метакоманды   $PACK,   то   структуры
организуются   по   следующим  правилам:   переменные  INTEGER*1,
LOGICAL*1 и все переменные  CHARACTER  начинаются  со  следующего
доступного  байта  независимо  от того, четный он или нечетный, а
все другие переменные начинаются  со  следующего  четного  байта.
Такое   размещение   несколько   увеличивает  расход  памяти,  но
сокращает время доступа к элементам структур.

     Если  задана  $PACK:1,  то  все  переменные  начинаются   со
следующего доступного байта независимо от его четности.  Хотя это
немного увеличивает время доступа, но сохраняет память.

     Если   задана   $PACK:2,   то   упаковка   выполняется    по
вышеописанным правилам.

     Если задана $PACK:4, то переменные  INTEGER*1,  LOGICAL*1  и
все  переменные  CHARACTER  начинаются  со  следующего доступного
байта независимо от того, четный он или нечетный,  а  все  другие
переменные начинаются с четырехбайтовых границ.


-----
$PAGE
-----

     $PAGE  начинает  следующую  страницу  в  листинге  исходного
файла.

     $PAGE

     Если первым символом строки исходного текста является символ
перевода страницы (код 0C ASCII), то это то же самое, что наличие
метакоманды $PAGE перед этой строкой.



                               421



     Пример:

C     Это первая страница. Следующая метакоманда начинает новую
C     страницу в листинге исходного файла:
$PAGE
C     Это страница два. Следующая строка начинается с символа
C     перевода страницы, который также начинает новую страницу
C     в листинге исходного файла:

C     Это страница 3.
      STOP ' '
      END


---------
$PAGESIZE
---------

     $PAGESIZE   форматирует   последующие   страницы   исходного
листинга длиной n строк.

     $PAGESIZE:n

     где аргумент n не может быть меньше 15.  По умолчанию размер
страницы равен 63 строкам.  Пример:

$PAGESIZE:60


--------
$STORAGE
--------

     $STORAGE распределяет n байт  памяти  для  всех  переменных,
описанных как целые или логические переменные.

     $STORAGE:n

     Аргумент n должен быть равен 2 или 4.   Умолчанием  является
4.

     Метакоманда $STORAGE не влияет на распределение  памяти  для
переменных,  явно описанных с заданием длины, таких как INTEGER*2
или LOGICAL*4.

     Пример:

$STORAGE:2

C     b и c описаны без задания длины, поэтому в соответствии с


                               422



C     аргументом метакоманды $STORAGE будут занимать по два байта.
C     a и d занимают по 4 байта.

      INTEGER*4 a, d
      INTEGER   b, c
      a = 65537
      b = 1024
C     Поскольку c занимает 2 байта, то при присвоении получит
C     значение двух младших байтов a+b.
      c = a + b
      d = a + b
C     Следующий оператор даст:  1025    65561
      WRITE (*, *) c, d
      END

--------------------
$STRICT и $NOTSTRICT
--------------------

     $STRICT подавляет специфические особенности  MSФортрана,  не
имеющиеся в стандарте Фортрана 77, а $NOTSTRICT разрешает их.

     $[NOT]STRICT

     Умолчанием является $NOTSTRICT.  $NOTSTRICT и $STRICT  могут
появляться в любом месте исходного файла.

     Пример:

$STRICT
C     Следующий оператор даст ошибку, поскольку INTEGER*2 не
C     входит в стандарт Фортрана 77:
      INTEGER*2  i

C     Имя переменной (balance) будет усечено до 6 символов:
      REAL  balance(500)

C     Следующий оператор даст ошибку, поскольку MODE=option не
C     входит в стандарт Фортрана 77:
      OPEN (2, FILE = 'BALANCE.DAT', MODE = 'READ')

      DO 100 i = 1, 500
C     Следующий оператор даст ошибку, поскольку встроенная
C     функция EOF не входит в стандарт Фортрана 77
C     (EOF рассматривается как функция REAL).
         IF (EOF (2)) GOTO 200
         READ (2, '(F7.2)') balance(i)
 100  CONTINUE
 200  CONTINUE
      END


                               423



---------
$SUBTITLE
---------

     $SUBTITLE назначает заданный  подзаголовок  для  последующих
страниц исходного листинга.

     $SUBTITLE:subtitle

     где subtitle - любая действительная символьная константа.

     Если  программа  не  содержит  метакоманду   $SUBTITLE,   то
подзаголовком  является  пустая строка.  Значение строки subtitle
печатается в левом верхнем углу страниц листинга исходного файла,
ниже заголовка, если он есть.

     Пример:

     Следующая  программа  создает  листинг,  в  котором   каждая
страница   имеет   заголовок   GAUSS   (имя  программы).   Каждая
подпрограмма  начинается  с  новой  страницы  листинга,   а   имя
подпрограммы появляется в качестве подзаголовка.

$TITLE:'GAUSS'

C     основная программа здесь...
      END

$SUBTITLE:'Row Division'
$PAGE
      SUBROUTINE divide (row, matrix, pivot)
C     тело подпрограммы...
      RETURN
      END

$SUBTITLE:'Back Substitution'
$PAGE
      SUBROUTINE BackSub (matrix)
C     тело подпрограммы...
      RETURN
      END


------
$TITLE
------

     $TITLE назначает заданный заголовок для последующих  страниц
исходного листинга.



                               424



     $TITLE:title

     где title - любая действительная символьная константа.

     Если программа не содержит метакоманду $TITLE, то заголовком
является пустая строка.

     Пример в описании метакоманды $SUBTITLE.


-----------------------
$TRUNCATE и $NOTRUNCATE
-----------------------

     $TRUNCATE  усекает  все  переменные  и  имена   программ   и
подпрограмм  до  шести символов.  $NOTRUNCATE подавляет умолчание
или предыдущую метакоманду $TRUNCATE.

     $[NO]TRUNCATE

     Умолчанием является $NOTRUNCATE.  Если действует  умолчание,
то первые 31 символов в имени являются значащими.  Если действует
$TRUNCATE или $STRICT, то имена длиннее шести символов генерируют
предупреждение.    Это   может   облегчить   переносимость  вашей
программы на другие системы.

     Пример:

C     Эта программа выполняет следующий вывод:
C
C     74 Las Vegas Street
C     74 Las Vegas Street
C
C     Barry Floyd
C     3 Prospect Drive

      IMPLICIT CHARACTER*20 (s)

$TRUNCATE
      studentname    = 'Enrique Pieras'
      studentaddress = '74 Las Vegas Street'
      WRITE (*, 100) studentname, studentaddress

$NOTRUNCATE
      studentname    = 'Barry Floyd'
      studentaddress = '3 Prospect Drive'
      WRITE (*, 100) studentname, studentaddress

 100  FORMAT (/ 1X, A20, / 1X, A20)
      END


                               425
